"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [737], {
        9477: function(e, t, i) {
            let n;
            i.d(t, {
                $V: function() {
                    return ot
                },
                CP7: function() {
                    return rA
                },
                CdI: function() {
                    return v
                },
                D1R: function() {
                    return C
                },
                DvJ: function() {
                    return t9
                },
                EJi: function() {
                    return a8
                },
                EoG: function() {
                    return g
                },
                F5T: function() {
                    return tI
                },
                FM8: function() {
                    return en
                },
                IEO: function() {
                    return rF
                },
                IOt: function() {
                    return B
                },
                Ilk: function() {
                    return e_
                },
                Kj0: function() {
                    return t7
                },
                L5s: function() {
                    return sW
                },
                LY2: function() {
                    return x
                },
                LgZ: function() {
                    return f
                },
                Ltg: function() {
                    return ew
                },
                Lun: function() {
                    return rf
                },
                M8C: function() {
                    return ei
                },
                Mig: function() {
                    return sV
                },
                N$j: function() {
                    return rB
                },
                NMF: function() {
                    return I
                },
                OdW: function() {
                    return rG
                },
                OoA: function() {
                    return b
                },
                Ox3: function() {
                    return sk
                },
                PMe: function() {
                    return sD
                },
                Pa4: function() {
                    return eC
                },
                QRU: function() {
                    return sH
                },
                QmN: function() {
                    return a
                },
                RsA: function() {
                    return r
                },
                SPe: function() {
                    return rY
                },
                SUY: function() {
                    return sj
                },
                Syv: function() {
                    return R
                },
                TUv: function() {
                    return rU
                },
                TlE: function() {
                    return tz
                },
                Tme: function() {
                    return tx
                },
                TyD: function() {
                    return S
                },
                UY4: function() {
                    return r7
                },
                UlW: function() {
                    return D
                },
                Vkp: function() {
                    return er
                },
                VzW: function() {
                    return L
                },
                WMw: function() {
                    return u
                },
                WdD: function() {
                    return ib
                },
                Wid: function() {
                    return a7
                },
                Wl3: function() {
                    return o
                },
                Xaj: function() {
                    return c
                },
                Xcj: function() {
                    return s7
                },
                YBo: function() {
                    return a9
                },
                YGz: function() {
                    return _
                },
                YLQ: function() {
                    return w
                },
                ZAu: function() {
                    return ry
                },
                Zp0: function() {
                    return sG
                },
                ZzF: function() {
                    return eR
                },
                _12: function() {
                    return iM
                },
                _C8: function() {
                    return sa
                },
                _Li: function() {
                    return l
                },
                _fP: function() {
                    return eA
                },
                a$l: function() {
                    return tF
                },
                aH4: function() {
                    return T
                },
                aLr: function() {
                    return eY
                },
                aNw: function() {
                    return sy
                },
                bGH: function() {
                    return d
                },
                blk: function() {
                    return r6
                },
                cBK: function() {
                    return sT
                },
                cPb: function() {
                    return io
                },
                cek: function() {
                    return sB
                },
                dUE: function() {
                    return sd
                },
                dd2: function() {
                    return eT
                },
                dpR: function() {
                    return sE
                },
                ehD: function() {
                    return h
                },
                ejS: function() {
                    return r5
                },
                fO1: function() {
                    return ar
                },
                ghN: function() {
                    return p
                },
                hH6: function() {
                    return sS
                },
                iKG: function() {
                    return iI
                },
                iLg: function() {
                    return sf
                },
                iMs: function() {
                    return s8
                },
                iUV: function() {
                    return s4
                },
                jyz: function() {
                    return ia
                },
                kB5: function() {
                    return rR
                },
                knz: function() {
                    return z
                },
                lRF: function() {
                    return rp
                },
                lb7: function() {
                    return rW
                },
                m7l: function() {
                    return sv
                },
                mSO: function() {
                    return U
                },
                nls: function() {
                    return rZ
                },
                ntZ: function() {
                    return s
                },
                pBf: function() {
                    return G
                },
                qyh: function() {
                    return A
                },
                rDY: function() {
                    return ir
                },
                rnI: function() {
                    return O
                },
                rpg: function() {
                    return y
                },
                u9r: function() {
                    return tX
                },
                uL9: function() {
                    return m
                },
                uWy: function() {
                    return M
                },
                vBJ: function() {
                    return tD
                },
                vpT: function() {
                    return rL
                },
                wem: function() {
                    return E
                },
                wk1: function() {
                    return P
                },
                woe: function() {
                    return ai
                },
                x12: function() {
                    return r3
                },
                xEZ: function() {
                    return eS
                },
                xo$: function() {
                    return a3
                },
                xsS: function() {
                    return rC
                },
                y8_: function() {
                    return oi
                },
                yC1: function() {
                    return sg
                },
                yGw: function() {
                    return e4
                },
                z$h: function() {
                    return N
                }
            });
            let r = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                },
                a = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                },
                s = 2,
                o = 0,
                l = 1,
                h = 2,
                u = 2,
                c = 5,
                d = 100,
                p = 201,
                f = 205,
                m = 0,
                g = 1,
                v = 2,
                _ = 3,
                x = 4,
                y = 1e3,
                M = 1001,
                b = 1002,
                S = 1003,
                w = 1004,
                T = 1005,
                E = 1006,
                A = 1007,
                C = 1008,
                L = 1015,
                P = 1023,
                R = 2300,
                I = 2301,
                D = 1,
                N = 2,
                O = 3e3,
                z = 3001,
                U = 3201,
                B = 0,
                F = "srgb",
                k = "srgb-linear",
                V = "300 es";
            class G {
                addEventListener(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    let i = this._listeners;
                    void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t)
                }
                hasEventListener(e, t) {
                    if (void 0 === this._listeners) return !1;
                    let i = this._listeners;
                    return void 0 !== i[e] && -1 !== i[e].indexOf(t)
                }
                removeEventListener(e, t) {
                    if (void 0 === this._listeners) return;
                    let i = this._listeners,
                        n = i[e];
                    if (void 0 !== n) {
                        let r = n.indexOf(t); - 1 !== r && n.splice(r, 1)
                    }
                }
                dispatchEvent(e) {
                    if (void 0 === this._listeners) return;
                    let t = this._listeners,
                        i = t[e.type];
                    if (void 0 !== i) {
                        e.target = this;
                        let n = i.slice(0);
                        for (let r = 0, a = n.length; r < a; r++) n[r].call(this, e);
                        e.target = null
                    }
                }
            }
            let W = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"],
                H = 1234567,
                j = Math.PI / 180,
                q = 180 / Math.PI;

            function X() {
                let e = 4294967295 * Math.random() | 0,
                    t = 4294967295 * Math.random() | 0,
                    i = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    r = W[255 & e] + W[e >> 8 & 255] + W[e >> 16 & 255] + W[e >> 24 & 255] + "-" + W[255 & t] + W[t >> 8 & 255] + "-" + W[t >> 16 & 15 | 64] + W[t >> 24 & 255] + "-" + W[63 & i | 128] + W[i >> 8 & 255] + "-" + W[i >> 16 & 255] + W[i >> 24 & 255] + W[255 & n] + W[n >> 8 & 255] + W[n >> 16 & 255] + W[n >> 24 & 255];
                return r.toLowerCase()
            }

            function J(e, t, i) {
                return Math.max(t, Math.min(i, e))
            }

            function Y(e, t) {
                return (e % t + t) % t
            }

            function Z(e, t, i) {
                return (1 - i) * e + i * t
            }

            function K(e) {
                return (e & e - 1) == 0 && 0 !== e
            }

            function Q(e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            }

            function $(e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            }

            function ee(e, t) {
                switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint16Array:
                        return e / 65535;
                    case Uint8Array:
                        return e / 255;
                    case Int16Array:
                        return Math.max(e / 32767, -1);
                    case Int8Array:
                        return Math.max(e / 127, -1);
                    default:
                        throw Error("Invalid component type.")
                }
            }

            function et(e, t) {
                switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint16Array:
                        return Math.round(65535 * e);
                    case Uint8Array:
                        return Math.round(255 * e);
                    case Int16Array:
                        return Math.round(32767 * e);
                    case Int8Array:
                        return Math.round(127 * e);
                    default:
                        throw Error("Invalid component type.")
                }
            }
            var ei = Object.freeze({
                __proto__: null,
                DEG2RAD: j,
                RAD2DEG: q,
                generateUUID: X,
                clamp: J,
                euclideanModulo: Y,
                mapLinear: function(e, t, i, n, r) {
                    return n + (e - t) * (r - n) / (i - t)
                },
                inverseLerp: function(e, t, i) {
                    return e !== t ? (i - e) / (t - e) : 0
                },
                lerp: Z,
                damp: function(e, t, i, n) {
                    return Z(e, t, 1 - Math.exp(-i * n))
                },
                pingpong: function(e, t = 1) {
                    return t - Math.abs(Y(e, 2 * t) - t)
                },
                smoothstep: function(e, t, i) {
                    return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e)
                },
                smootherstep: function(e, t, i) {
                    return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10)
                },
                randInt: function(e, t) {
                    return e + Math.floor(Math.random() * (t - e + 1))
                },
                randFloat: function(e, t) {
                    return e + Math.random() * (t - e)
                },
                randFloatSpread: function(e) {
                    return e * (.5 - Math.random())
                },
                seededRandom: function(e) {
                    void 0 !== e && (H = e);
                    let t = H += 1831565813;
                    return t = Math.imul(t ^ t >>> 15, 1 | t), (((t ^= t + Math.imul(t ^ t >>> 7, 61 | t)) ^ t >>> 14) >>> 0) / 4294967296
                },
                degToRad: function(e) {
                    return e * j
                },
                radToDeg: function(e) {
                    return e * q
                },
                isPowerOfTwo: K,
                ceilPowerOfTwo: Q,
                floorPowerOfTwo: $,
                setQuaternionFromProperEuler: function(e, t, i, n, r) {
                    let a = Math.cos,
                        s = Math.sin,
                        o = a(i / 2),
                        l = s(i / 2),
                        h = a((t + n) / 2),
                        u = s((t + n) / 2),
                        c = a((t - n) / 2),
                        d = s((t - n) / 2),
                        p = a((n - t) / 2),
                        f = s((n - t) / 2);
                    switch (r) {
                        case "XYX":
                            e.set(o * u, l * c, l * d, o * h);
                            break;
                        case "YZY":
                            e.set(l * d, o * u, l * c, o * h);
                            break;
                        case "ZXZ":
                            e.set(l * c, l * d, o * u, o * h);
                            break;
                        case "XZX":
                            e.set(o * u, l * f, l * p, o * h);
                            break;
                        case "YXY":
                            e.set(l * p, o * u, l * f, o * h);
                            break;
                        case "ZYZ":
                            e.set(l * f, l * p, o * u, o * h);
                            break;
                        default:
                            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                    }
                },
                normalize: et,
                denormalize: ee
            });
            class en {
                constructor(e = 0, t = 0) {
                    en.prototype.isVector2 = !0, this.x = e, this.y = t
                }
                get width() {
                    return this.x
                }
                set width(e) {
                    this.x = e
                }
                get height() {
                    return this.y
                }
                set height(e) {
                    this.y = e
                }
                set(e, t) {
                    return this.x = e, this.y = t, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                applyMatrix3(e) {
                    let t = this.x,
                        i = this.y,
                        n = e.elements;
                    return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
                }
                clampLength(e, t) {
                    let i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y
                }
                cross(e) {
                    return this.x * e.y - this.y * e.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    let e = Math.atan2(-this.y, -this.x) + Math.PI;
                    return e
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    let t = this.x - e.x,
                        i = this.y - e.y;
                    return t * t + i * i
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                }
                lerpVectors(e, t, i) {
                    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this
                }
                rotateAround(e, t) {
                    let i = Math.cos(t),
                        n = Math.sin(t),
                        r = this.x - e.x,
                        a = this.y - e.y;
                    return this.x = r * i - a * n + e.x, this.y = r * n + a * i + e.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y
                }
            }
            class er {
                constructor() {
                    er.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
                }
                set(e, t, i, n, r, a, s, o, l) {
                    let h = this.elements;
                    return h[0] = e, h[1] = n, h[2] = s, h[3] = t, h[4] = r, h[5] = o, h[6] = i, h[7] = a, h[8] = l, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                copy(e) {
                    let t = this.elements,
                        i = e.elements;
                    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this
                }
                extractBasis(e, t, i) {
                    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(e) {
                    let t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    let i = e.elements,
                        n = t.elements,
                        r = this.elements,
                        a = i[0],
                        s = i[3],
                        o = i[6],
                        l = i[1],
                        h = i[4],
                        u = i[7],
                        c = i[2],
                        d = i[5],
                        p = i[8],
                        f = n[0],
                        m = n[3],
                        g = n[6],
                        v = n[1],
                        _ = n[4],
                        x = n[7],
                        y = n[2],
                        M = n[5],
                        b = n[8];
                    return r[0] = a * f + s * v + o * y, r[3] = a * m + s * _ + o * M, r[6] = a * g + s * x + o * b, r[1] = l * f + h * v + u * y, r[4] = l * m + h * _ + u * M, r[7] = l * g + h * x + u * b, r[2] = c * f + d * v + p * y, r[5] = c * m + d * _ + p * M, r[8] = c * g + d * x + p * b, this
                }
                multiplyScalar(e) {
                    let t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                }
                determinant() {
                    let e = this.elements,
                        t = e[0],
                        i = e[1],
                        n = e[2],
                        r = e[3],
                        a = e[4],
                        s = e[5],
                        o = e[6],
                        l = e[7],
                        h = e[8];
                    return t * a * h - t * s * l - i * r * h + i * s * o + n * r * l - n * a * o
                }
                invert() {
                    let e = this.elements,
                        t = e[0],
                        i = e[1],
                        n = e[2],
                        r = e[3],
                        a = e[4],
                        s = e[5],
                        o = e[6],
                        l = e[7],
                        h = e[8],
                        u = h * a - s * l,
                        c = s * o - h * r,
                        d = l * r - a * o,
                        p = t * u + i * c + n * d;
                    if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    let f = 1 / p;
                    return e[0] = u * f, e[1] = (n * l - h * i) * f, e[2] = (s * i - n * a) * f, e[3] = c * f, e[4] = (h * t - n * o) * f, e[5] = (n * r - s * t) * f, e[6] = d * f, e[7] = (i * o - l * t) * f, e[8] = (a * t - i * r) * f, this
                }
                transpose() {
                    let e;
                    let t = this.elements;
                    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                }
                getNormalMatrix(e) {
                    return this.setFromMatrix4(e).invert().transpose()
                }
                transposeIntoArray(e) {
                    let t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                }
                setUvTransform(e, t, i, n, r, a, s) {
                    let o = Math.cos(r),
                        l = Math.sin(r);
                    return this.set(i * o, i * l, -i * (o * a + l * s) + a + e, -n * l, n * o, -n * (-l * a + o * s) + s + t, 0, 0, 1), this
                }
                scale(e, t) {
                    return this.premultiply(ea.makeScale(e, t)), this
                }
                rotate(e) {
                    return this.premultiply(ea.makeRotation(-e)), this
                }
                translate(e, t) {
                    return this.premultiply(ea.makeTranslation(e, t)), this
                }
                makeTranslation(e, t) {
                    return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
                }
                makeRotation(e) {
                    let t = Math.cos(e),
                        i = Math.sin(e);
                    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this
                }
                makeScale(e, t) {
                    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
                }
                equals(e) {
                    let t = this.elements,
                        i = e.elements;
                    for (let n = 0; n < 9; n++)
                        if (t[n] !== i[n]) return !1;
                    return !0
                }
                fromArray(e, t = 0) {
                    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    let i = this.elements;
                    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
                }
                clone() {
                    return new this.constructor().fromArray(this.elements)
                }
            }
            let ea = new er;

            function es(e) {
                for (let t = e.length - 1; t >= 0; --t)
                    if (e[t] >= 65535) return !0;
                return !1
            }

            function eo(e) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", e)
            }

            function el(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }

            function eh(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
            let eu = {
                    [F]: {
                        [k]: el
                    },
                    [k]: {
                        [F]: eh
                    }
                },
                ec = {
                    legacyMode: !0,
                    get workingColorSpace() {
                        return k
                    },
                    set workingColorSpace(colorSpace) {
                        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
                    },
                    convert: function(e, t, i) {
                        if (this.legacyMode || t === i || !t || !i) return e;
                        if (eu[t] && void 0 !== eu[t][i]) {
                            let n = eu[t][i];
                            return e.r = n(e.r), e.g = n(e.g), e.b = n(e.b), e
                        }
                        throw Error("Unsupported color space conversion.")
                    },
                    fromWorkingColorSpace: function(e, t) {
                        return this.convert(e, this.workingColorSpace, t)
                    },
                    toWorkingColorSpace: function(e, t) {
                        return this.convert(e, t, this.workingColorSpace)
                    }
                },
                ed = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                ep = {
                    r: 0,
                    g: 0,
                    b: 0
                },
                ef = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                em = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function eg(e, t, i) {
                return (i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6) ? e + (t - e) * 6 * i : i < .5 ? t : i < 2 / 3 ? e + (t - e) * 6 * (2 / 3 - i) : e
            }

            function ev(e, t) {
                return t.r = e.r, t.g = e.g, t.b = e.b, t
            }
            class e_ {
                constructor(e, t, i) {
                    if (this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, void 0 === t && void 0 === i) return this.set(e);
                    return this.setRGB(e, t, i)
                }
                set(e) {
                    return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
                }
                setScalar(e) {
                    return this.r = e, this.g = e, this.b = e, this
                }
                setHex(e, t = F) {
                    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, ec.toWorkingColorSpace(this, t), this
                }
                setRGB(e, t, i, n = ec.workingColorSpace) {
                    return this.r = e, this.g = t, this.b = i, ec.toWorkingColorSpace(this, n), this
                }
                setHSL(e, t, i, n = ec.workingColorSpace) {
                    if (e = Y(e, 1), t = J(t, 0, 1), i = J(i, 0, 1), 0 === t) this.r = this.g = this.b = i;
                    else {
                        let r = i <= .5 ? i * (1 + t) : i + t - i * t,
                            a = 2 * i - r;
                        this.r = eg(a, r, e + 1 / 3), this.g = eg(a, r, e), this.b = eg(a, r, e - 1 / 3)
                    }
                    return ec.toWorkingColorSpace(this, n), this
                }
                setStyle(e, t = F) {
                    let i;

                    function n(t) {
                        void 0 !== t && 1 > parseFloat(t) && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                    }
                    if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                        let r;
                        let a = i[1],
                            s = i[2];
                        switch (a) {
                            case "rgb":
                            case "rgba":
                                if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, ec.toWorkingColorSpace(this, t), n(r[4]), this;
                                if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, ec.toWorkingColorSpace(this, t), n(r[4]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
                                    let o = parseFloat(r[1]) / 360,
                                        l = parseFloat(r[2]) / 100,
                                        h = parseFloat(r[3]) / 100;
                                    return n(r[4]), this.setHSL(o, l, h, t)
                                }
                        }
                    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                        let u = i[1],
                            c = u.length;
                        if (3 === c) return this.r = parseInt(u.charAt(0) + u.charAt(0), 16) / 255, this.g = parseInt(u.charAt(1) + u.charAt(1), 16) / 255, this.b = parseInt(u.charAt(2) + u.charAt(2), 16) / 255, ec.toWorkingColorSpace(this, t), this;
                        if (6 === c) return this.r = parseInt(u.charAt(0) + u.charAt(1), 16) / 255, this.g = parseInt(u.charAt(2) + u.charAt(3), 16) / 255, this.b = parseInt(u.charAt(4) + u.charAt(5), 16) / 255, ec.toWorkingColorSpace(this, t), this
                    }
                    return e && e.length > 0 ? this.setColorName(e, t) : this
                }
                setColorName(e, t = F) {
                    let i = ed[e.toLowerCase()];
                    return void 0 !== i ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(e) {
                    return this.r = e.r, this.g = e.g, this.b = e.b, this
                }
                copySRGBToLinear(e) {
                    return this.r = el(e.r), this.g = el(e.g), this.b = el(e.b), this
                }
                copyLinearToSRGB(e) {
                    return this.r = eh(e.r), this.g = eh(e.g), this.b = eh(e.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex(e = F) {
                    return ec.fromWorkingColorSpace(ev(this, ep), e), J(255 * ep.r, 0, 255) << 16 ^ J(255 * ep.g, 0, 255) << 8 ^ J(255 * ep.b, 0, 255) << 0
                }
                getHexString(e = F) {
                    return ("000000" + this.getHex(e).toString(16)).slice(-6)
                }
                getHSL(e, t = ec.workingColorSpace) {
                    let i, n;
                    ec.fromWorkingColorSpace(ev(this, ep), t);
                    let r = ep.r,
                        a = ep.g,
                        s = ep.b,
                        o = Math.max(r, a, s),
                        l = Math.min(r, a, s),
                        h = (l + o) / 2;
                    if (l === o) i = 0, n = 0;
                    else {
                        let u = o - l;
                        switch (n = h <= .5 ? u / (o + l) : u / (2 - o - l), o) {
                            case r:
                                i = (a - s) / u + (a < s ? 6 : 0);
                                break;
                            case a:
                                i = (s - r) / u + 2;
                                break;
                            case s:
                                i = (r - a) / u + 4
                        }
                        i /= 6
                    }
                    return e.h = i, e.s = n, e.l = h, e
                }
                getRGB(e, t = ec.workingColorSpace) {
                    return ec.fromWorkingColorSpace(ev(this, ep), t), e.r = ep.r, e.g = ep.g, e.b = ep.b, e
                }
                getStyle(e = F) {
                    return (ec.fromWorkingColorSpace(ev(this, ep), e), e !== F) ? `color(${e} ${ep.r} ${ep.g} ${ep.b})` : `rgb(${255*ep.r|0},${255*ep.g|0},${255*ep.b|0})`
                }
                offsetHSL(e, t, i) {
                    return this.getHSL(ef), ef.h += e, ef.s += t, ef.l += i, this.setHSL(ef.h, ef.s, ef.l), this
                }
                add(e) {
                    return this.r += e.r, this.g += e.g, this.b += e.b, this
                }
                addColors(e, t) {
                    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                }
                addScalar(e) {
                    return this.r += e, this.g += e, this.b += e, this
                }
                sub(e) {
                    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                }
                multiply(e) {
                    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                }
                multiplyScalar(e) {
                    return this.r *= e, this.g *= e, this.b *= e, this
                }
                lerp(e, t) {
                    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                }
                lerpColors(e, t, i) {
                    return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this
                }
                lerpHSL(e, t) {
                    this.getHSL(ef), e.getHSL(em);
                    let i = Z(ef.h, em.h, t),
                        n = Z(ef.s, em.s, t),
                        r = Z(ef.l, em.l, t);
                    return this.setHSL(i, n, r), this
                }
                equals(e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                }
                fromArray(e, t = 0) {
                    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                }
                fromBufferAttribute(e, t) {
                    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
                }
                toJSON() {
                    return this.getHex()
                }*[Symbol.iterator]() {
                    yield this.r, yield this.g, yield this.b
                }
            }
            e_.NAMES = ed;
            class ex {
                static getDataURL(e) {
                    let t;
                    if (/^data:/i.test(e.src) || "undefined" == typeof HTMLCanvasElement) return e.src;
                    if (e instanceof HTMLCanvasElement) t = e;
                    else {
                        void 0 === n && (n = eo("canvas")), n.width = e.width, n.height = e.height;
                        let i = n.getContext("2d");
                        e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = n
                    }
                    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
                }
                static sRGBToLinear(e) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                        let t = eo("canvas");
                        t.width = e.width, t.height = e.height;
                        let i = t.getContext("2d");
                        i.drawImage(e, 0, 0, e.width, e.height);
                        let n = i.getImageData(0, 0, e.width, e.height),
                            r = n.data;
                        for (let a = 0; a < r.length; a++) r[a] = 255 * el(r[a] / 255);
                        return i.putImageData(n, 0, 0), t
                    }
                    if (!e.data) return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e; {
                        let s = e.data.slice(0);
                        for (let o = 0; o < s.length; o++) s instanceof Uint8Array || s instanceof Uint8ClampedArray ? s[o] = Math.floor(255 * el(s[o] / 255)) : s[o] = el(s[o]);
                        return {
                            data: s,
                            width: e.width,
                            height: e.height
                        }
                    }
                }
            }
            class ey {
                constructor(e = null) {
                    this.isSource = !0, this.uuid = X(), this.data = e, this.version = 0
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                toJSON(e) {
                    let t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
                    let i = {
                            uuid: this.uuid,
                            url: ""
                        },
                        n = this.data;
                    if (null !== n) {
                        let r;
                        if (Array.isArray(n)) {
                            r = [];
                            for (let a = 0, s = n.length; a < s; a++) n[a].isDataTexture ? r.push(eM(n[a].image)) : r.push(eM(n[a]))
                        } else r = eM(n);
                        i.url = r
                    }
                    return t || (e.images[this.uuid] = i), i
                }
            }

            function eM(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? ex.getDataURL(e) : e.data ? {
                    data: Array.from(e.data),
                    width: e.width,
                    height: e.height,
                    type: e.data.constructor.name
                } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
            }
            let eb = 0;
            class eS extends G {
                constructor(e = eS.DEFAULT_IMAGE, t = eS.DEFAULT_MAPPING, i = M, n = M, r = E, a = C, s = P, o = 1009, l = eS.DEFAULT_ANISOTROPY, h = O) {
                    super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                        value: eb++
                    }), this.uuid = X(), this.name = "", this.source = new ey(e), this.mipmaps = [], this.mapping = t, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = a, this.anisotropy = l, this.format = s, this.internalFormat = null, this.type = o, this.offset = new en(0, 0), this.repeat = new en(1, 1), this.center = new en(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new er, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
                }
                get image() {
                    return this.source.data
                }
                set image(e) {
                    this.source.data = e
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
                }
                toJSON(e) {
                    let t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    let i = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        image: this.source.toJSON(e).uuid,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        generateMipmaps: this.generateMipmaps,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                transformUv(e) {
                    if (300 !== this.mapping) return e;
                    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                        case y:
                            e.x = e.x - Math.floor(e.x);
                            break;
                        case M:
                            e.x = e.x < 0 ? 0 : 1;
                            break;
                        case b:
                            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                        case y:
                            e.y = e.y - Math.floor(e.y);
                            break;
                        case M:
                            e.y = e.y < 0 ? 0 : 1;
                            break;
                        case b:
                            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                    return this.flipY && (e.y = 1 - e.y), e
                }
                set needsUpdate(e) {
                    !0 === e && (this.version++, this.source.needsUpdate = !0)
                }
            }
            eS.DEFAULT_IMAGE = null, eS.DEFAULT_MAPPING = 300, eS.DEFAULT_ANISOTROPY = 1;
            class ew {
                constructor(e = 0, t = 0, i = 0, n = 1) {
                    ew.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = n
                }
                get width() {
                    return this.z
                }
                set width(e) {
                    this.z = e
                }
                get height() {
                    return this.w
                }
                set height(e) {
                    this.w = e
                }
                set(e, t, i, n) {
                    return this.x = e, this.y = t, this.z = i, this.w = n, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this.w = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setW(e) {
                    return this.w = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this.w += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                }
                applyMatrix4(e) {
                    let t = this.x,
                        i = this.y,
                        n = this.z,
                        r = this.w,
                        a = e.elements;
                    return this.x = a[0] * t + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] * t + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * t + a[6] * i + a[10] * n + a[14] * r, this.w = a[3] * t + a[7] * i + a[11] * n + a[15] * r, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                setAxisAngleFromQuaternion(e) {
                    this.w = 2 * Math.acos(e.w);
                    let t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                }
                setAxisAngleFromRotationMatrix(e) {
                    let t, i, n;
                    let r = e.elements,
                        a = r[0],
                        s = r[4],
                        o = r[8],
                        l = r[1],
                        h = r[5],
                        u = r[9],
                        c = r[2],
                        d = r[6],
                        p = r[10];
                    if (.01 > Math.abs(s - l) && .01 > Math.abs(o - c) && .01 > Math.abs(u - d)) {
                        if (.1 > Math.abs(s + l) && .1 > Math.abs(o + c) && .1 > Math.abs(u + d) && .1 > Math.abs(a + h + p - 3)) return this.set(1, 0, 0, 0), this;
                        let f = (a + 1) / 2,
                            m = (h + 1) / 2,
                            g = (p + 1) / 2,
                            v = (s + l) / 4,
                            _ = (o + c) / 4,
                            x = (u + d) / 4;
                        return f > m && f > g ? f < .01 ? (t = 0, i = .707106781, n = .707106781) : (i = v / (t = Math.sqrt(f)), n = _ / t) : m > g ? m < .01 ? (t = .707106781, i = 0, n = .707106781) : (t = v / (i = Math.sqrt(m)), n = x / i) : g < .01 ? (t = .707106781, i = .707106781, n = 0) : (t = _ / (n = Math.sqrt(g)), i = x / n), this.set(t, i, n, Math.PI), this
                    }
                    let y = Math.sqrt((d - u) * (d - u) + (o - c) * (o - c) + (l - s) * (l - s));
                    return .001 > Math.abs(y) && (y = 1), this.x = (d - u) / y, this.y = (o - c) / y, this.z = (l - s) / y, this.w = Math.acos((a + h + p - 1) / 2), this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
                }
                clampLength(e, t) {
                    let i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                }
                lerpVectors(e, t, i) {
                    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z, yield this.w
                }
            }
            class eT extends G {
                constructor(e = 1, t = 1, i = {}) {
                    super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new ew(0, 0, e, t), this.scissorTest = !1, this.viewport = new ew(0, 0, e, t), this.texture = new eS({
                        width: e,
                        height: t,
                        depth: 1
                    }, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.internalFormat = void 0 !== i.internalFormat ? i.internalFormat : null, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : E, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null, this.samples = void 0 !== i.samples ? i.samples : 0
                }
                setSize(e, t, i = 1) {
                    (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
                    let t = Object.assign({}, e.texture.image);
                    return this.texture.source = new ey(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            class eE extends eS {
                constructor(e = null, t = 1, i = 1, n = 1) {
                    super(null), this.isDataArrayTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: i,
                        depth: n
                    }, this.magFilter = S, this.minFilter = S, this.wrapR = M, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            class eA {
                constructor(e = 0, t = 0, i = 0, n = 1) {
                    this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = n
                }
                static slerpFlat(e, t, i, n, r, a, s) {
                    let o = i[n + 0],
                        l = i[n + 1],
                        h = i[n + 2],
                        u = i[n + 3],
                        c = r[a + 0],
                        d = r[a + 1],
                        p = r[a + 2],
                        f = r[a + 3];
                    if (0 === s) {
                        e[t + 0] = o, e[t + 1] = l, e[t + 2] = h, e[t + 3] = u;
                        return
                    }
                    if (1 === s) {
                        e[t + 0] = c, e[t + 1] = d, e[t + 2] = p, e[t + 3] = f;
                        return
                    }
                    if (u !== f || o !== c || l !== d || h !== p) {
                        let m = 1 - s,
                            g = o * c + l * d + h * p + u * f,
                            v = g >= 0 ? 1 : -1,
                            _ = 1 - g * g;
                        if (_ > Number.EPSILON) {
                            let x = Math.sqrt(_),
                                y = Math.atan2(x, g * v);
                            m = Math.sin(m * y) / x, s = Math.sin(s * y) / x
                        }
                        let M = s * v;
                        if (o = o * m + c * M, l = l * m + d * M, h = h * m + p * M, u = u * m + f * M, m === 1 - s) {
                            let b = 1 / Math.sqrt(o * o + l * l + h * h + u * u);
                            o *= b, l *= b, h *= b, u *= b
                        }
                    }
                    e[t] = o, e[t + 1] = l, e[t + 2] = h, e[t + 3] = u
                }
                static multiplyQuaternionsFlat(e, t, i, n, r, a) {
                    let s = i[n],
                        o = i[n + 1],
                        l = i[n + 2],
                        h = i[n + 3],
                        u = r[a],
                        c = r[a + 1],
                        d = r[a + 2],
                        p = r[a + 3];
                    return e[t] = s * p + h * u + o * d - l * c, e[t + 1] = o * p + h * c + l * u - s * d, e[t + 2] = l * p + h * d + s * c - o * u, e[t + 3] = h * p - s * u - o * c - l * d, e
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(e) {
                    this._w = e, this._onChangeCallback()
                }
                set(e, t, i, n) {
                    return this._x = e, this._y = t, this._z = i, this._w = n, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
                }
                setFromEuler(e, t) {
                    let i = e._x,
                        n = e._y,
                        r = e._z,
                        a = e._order,
                        s = Math.cos,
                        o = Math.sin,
                        l = s(i / 2),
                        h = s(n / 2),
                        u = s(r / 2),
                        c = o(i / 2),
                        d = o(n / 2),
                        p = o(r / 2);
                    switch (a) {
                        case "XYZ":
                            this._x = c * h * u + l * d * p, this._y = l * d * u - c * h * p, this._z = l * h * p + c * d * u, this._w = l * h * u - c * d * p;
                            break;
                        case "YXZ":
                            this._x = c * h * u + l * d * p, this._y = l * d * u - c * h * p, this._z = l * h * p - c * d * u, this._w = l * h * u + c * d * p;
                            break;
                        case "ZXY":
                            this._x = c * h * u - l * d * p, this._y = l * d * u + c * h * p, this._z = l * h * p + c * d * u, this._w = l * h * u - c * d * p;
                            break;
                        case "ZYX":
                            this._x = c * h * u - l * d * p, this._y = l * d * u + c * h * p, this._z = l * h * p - c * d * u, this._w = l * h * u + c * d * p;
                            break;
                        case "YZX":
                            this._x = c * h * u + l * d * p, this._y = l * d * u + c * h * p, this._z = l * h * p - c * d * u, this._w = l * h * u - c * d * p;
                            break;
                        case "XZY":
                            this._x = c * h * u - l * d * p, this._y = l * d * u - c * h * p, this._z = l * h * p + c * d * u, this._w = l * h * u + c * d * p;
                            break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                    }
                    return !1 !== t && this._onChangeCallback(), this
                }
                setFromAxisAngle(e, t) {
                    let i = t / 2,
                        n = Math.sin(i);
                    return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this._onChangeCallback(), this
                }
                setFromRotationMatrix(e) {
                    let t = e.elements,
                        i = t[0],
                        n = t[4],
                        r = t[8],
                        a = t[1],
                        s = t[5],
                        o = t[9],
                        l = t[2],
                        h = t[6],
                        u = t[10],
                        c = i + s + u;
                    if (c > 0) {
                        let d = .5 / Math.sqrt(c + 1);
                        this._w = .25 / d, this._x = (h - o) * d, this._y = (r - l) * d, this._z = (a - n) * d
                    } else if (i > s && i > u) {
                        let p = 2 * Math.sqrt(1 + i - s - u);
                        this._w = (h - o) / p, this._x = .25 * p, this._y = (n + a) / p, this._z = (r + l) / p
                    } else if (s > u) {
                        let f = 2 * Math.sqrt(1 + s - i - u);
                        this._w = (r - l) / f, this._x = (n + a) / f, this._y = .25 * f, this._z = (o + h) / f
                    } else {
                        let m = 2 * Math.sqrt(1 + u - i - s);
                        this._w = (a - n) / m, this._x = (r + l) / m, this._y = (o + h) / m, this._z = .25 * m
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(e, t) {
                    let i = e.dot(t) + 1;
                    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize()
                }
                angleTo(e) {
                    return 2 * Math.acos(Math.abs(J(this.dot(e), -1, 1)))
                }
                rotateTowards(e, t) {
                    let i = this.angleTo(e);
                    return 0 === i || this.slerp(e, Math.min(1, t / i)), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
                }
                multiply(e) {
                    return this.multiplyQuaternions(this, e)
                }
                premultiply(e) {
                    return this.multiplyQuaternions(e, this)
                }
                multiplyQuaternions(e, t) {
                    let i = e._x,
                        n = e._y,
                        r = e._z,
                        a = e._w,
                        s = t._x,
                        o = t._y,
                        l = t._z,
                        h = t._w;
                    return this._x = i * h + a * s + n * l - r * o, this._y = n * h + a * o + r * s - i * l, this._z = r * h + a * l + i * o - n * s, this._w = a * h - i * s - n * o - r * l, this._onChangeCallback(), this
                }
                slerp(e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    let i = this._x,
                        n = this._y,
                        r = this._z,
                        a = this._w,
                        s = a * e._w + i * e._x + n * e._y + r * e._z;
                    if (s < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), s >= 1) return this._w = a, this._x = i, this._y = n, this._z = r, this;
                    let o = 1 - s * s;
                    if (o <= Number.EPSILON) {
                        let l = 1 - t;
                        return this._w = l * a + t * this._w, this._x = l * i + t * this._x, this._y = l * n + t * this._y, this._z = l * r + t * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    let h = Math.sqrt(o),
                        u = Math.atan2(h, s),
                        c = Math.sin((1 - t) * u) / h,
                        d = Math.sin(t * u) / h;
                    return this._w = a * c + this._w * d, this._x = i * c + this._x * d, this._y = n * c + this._y * d, this._z = r * c + this._z * d, this._onChangeCallback(), this
                }
                slerpQuaternions(e, t, i) {
                    return this.copy(e).slerp(t, i)
                }
                random() {
                    let e = Math.random(),
                        t = Math.sqrt(1 - e),
                        i = Math.sqrt(e),
                        n = 2 * Math.PI * Math.random(),
                        r = 2 * Math.PI * Math.random();
                    return this.set(t * Math.cos(n), i * Math.sin(r), i * Math.cos(r), t * Math.sin(n))
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                }
                fromArray(e, t = 0) {
                    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                }
                fromBufferAttribute(e, t) {
                    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}*[Symbol.iterator]() {
                    yield this._x, yield this._y, yield this._z, yield this._w
                }
            }
            class eC {
                constructor(e = 0, t = 0, i = 0) {
                    eC.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i
                }
                set(e, t, i) {
                    return void 0 === i && (i = this.z), this.x = e, this.y = t, this.z = i, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this.z += e.z, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this
                }
                multiplyVectors(e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                }
                applyEuler(e) {
                    return this.applyQuaternion(eP.setFromEuler(e))
                }
                applyAxisAngle(e, t) {
                    return this.applyQuaternion(eP.setFromAxisAngle(e, t))
                }
                applyMatrix3(e) {
                    let t = this.x,
                        i = this.y,
                        n = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[3] * i + r[6] * n, this.y = r[1] * t + r[4] * i + r[7] * n, this.z = r[2] * t + r[5] * i + r[8] * n, this
                }
                applyNormalMatrix(e) {
                    return this.applyMatrix3(e).normalize()
                }
                applyMatrix4(e) {
                    let t = this.x,
                        i = this.y,
                        n = this.z,
                        r = e.elements,
                        a = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
                    return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * a, this
                }
                applyQuaternion(e) {
                    let t = this.x,
                        i = this.y,
                        n = this.z,
                        r = e.x,
                        a = e.y,
                        s = e.z,
                        o = e.w,
                        l = o * t + a * n - s * i,
                        h = o * i + s * t - r * n,
                        u = o * n + r * i - a * t,
                        c = -r * t - a * i - s * n;
                    return this.x = l * o + -(c * r) + -(h * s) - -(u * a), this.y = h * o + -(c * a) + -(u * r) - -(l * s), this.z = u * o + -(c * s) + -(l * a) - -(h * r), this
                }
                project(e) {
                    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                }
                unproject(e) {
                    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                }
                transformDirection(e) {
                    let t = this.x,
                        i = this.y,
                        n = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[4] * i + r[8] * n, this.y = r[1] * t + r[5] * i + r[9] * n, this.z = r[2] * t + r[6] * i + r[10] * n, this.normalize()
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
                }
                clampLength(e, t) {
                    let i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                }
                lerpVectors(e, t, i) {
                    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this
                }
                cross(e) {
                    return this.crossVectors(this, e)
                }
                crossVectors(e, t) {
                    let i = e.x,
                        n = e.y,
                        r = e.z,
                        a = t.x,
                        s = t.y,
                        o = t.z;
                    return this.x = n * o - r * s, this.y = r * a - i * o, this.z = i * s - n * a, this
                }
                projectOnVector(e) {
                    let t = e.lengthSq();
                    if (0 === t) return this.set(0, 0, 0);
                    let i = e.dot(this) / t;
                    return this.copy(e).multiplyScalar(i)
                }
                projectOnPlane(e) {
                    return eL.copy(this).projectOnVector(e), this.sub(eL)
                }
                reflect(e) {
                    return this.sub(eL.copy(e).multiplyScalar(2 * this.dot(e)))
                }
                angleTo(e) {
                    let t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    if (0 === t) return Math.PI / 2;
                    let i = this.dot(e) / t;
                    return Math.acos(J(i, -1, 1))
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    let t = this.x - e.x,
                        i = this.y - e.y,
                        n = this.z - e.z;
                    return t * t + i * i + n * n
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                }
                setFromSpherical(e) {
                    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                }
                setFromSphericalCoords(e, t, i) {
                    let n = Math.sin(t) * e;
                    return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this
                }
                setFromCylindrical(e) {
                    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                }
                setFromCylindricalCoords(e, t, i) {
                    return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this
                }
                setFromMatrixPosition(e) {
                    let t = e.elements;
                    return this.x = t[12], this.y = t[13], this.z = t[14], this
                }
                setFromMatrixScale(e) {
                    let t = this.setFromMatrixColumn(e, 0).length(),
                        i = this.setFromMatrixColumn(e, 1).length(),
                        n = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t, this.y = i, this.z = n, this
                }
                setFromMatrixColumn(e, t) {
                    return this.fromArray(e.elements, 4 * t)
                }
                setFromMatrix3Column(e, t) {
                    return this.fromArray(e.elements, 3 * t)
                }
                setFromEuler(e) {
                    return this.x = e._x, this.y = e._y, this.z = e._z, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
                randomDirection() {
                    let e = (Math.random() - .5) * 2,
                        t = Math.random() * Math.PI * 2,
                        i = Math.sqrt(1 - e ** 2);
                    return this.x = i * Math.cos(t), this.y = i * Math.sin(t), this.z = e, this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z
                }
            }
            let eL = new eC,
                eP = new eA;
            class eR {
                constructor(e = new eC(Infinity, Infinity, Infinity), t = new eC(-1 / 0, -1 / 0, -1 / 0)) {
                    this.isBox3 = !0, this.min = e, this.max = t
                }
                set(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
                setFromArray(e) {
                    let t = Infinity,
                        i = Infinity,
                        n = Infinity,
                        r = -1 / 0,
                        a = -1 / 0,
                        s = -1 / 0;
                    for (let o = 0, l = e.length; o < l; o += 3) {
                        let h = e[o],
                            u = e[o + 1],
                            c = e[o + 2];
                        h < t && (t = h), u < i && (i = u), c < n && (n = c), h > r && (r = h), u > a && (a = u), c > s && (s = c)
                    }
                    return this.min.set(t, i, n), this.max.set(r, a, s), this
                }
                setFromBufferAttribute(e) {
                    let t = Infinity,
                        i = Infinity,
                        n = Infinity,
                        r = -1 / 0,
                        a = -1 / 0,
                        s = -1 / 0;
                    for (let o = 0, l = e.count; o < l; o++) {
                        let h = e.getX(o),
                            u = e.getY(o),
                            c = e.getZ(o);
                        h < t && (t = h), u < i && (i = u), c < n && (n = c), h > r && (r = h), u > a && (a = u), c > s && (s = c)
                    }
                    return this.min.set(t, i, n), this.max.set(r, a, s), this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    let i = eD.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
                }
                setFromObject(e, t = !1) {
                    return this.makeEmpty(), this.expandByObject(e, t)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = Infinity, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e), this.max.max(e), this
                }
                expandByVector(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
                expandByObject(e, t = !1) {
                    e.updateWorldMatrix(!1, !1);
                    let i = e.geometry;
                    if (void 0 !== i) {
                        if (t && void 0 != i.attributes && void 0 !== i.attributes.position) {
                            let n = i.attributes.position;
                            for (let r = 0, a = n.count; r < a; r++) eD.fromBufferAttribute(n, r).applyMatrix4(e.matrixWorld), this.expandByPoint(eD)
                        } else null === i.boundingBox && i.computeBoundingBox(), eN.copy(i.boundingBox), eN.applyMatrix4(e.matrixWorld), this.union(eN)
                    }
                    let s = e.children;
                    for (let o = 0, l = s.length; o < l; o++) this.expandByObject(s[o], t);
                    return this
                }
                containsPoint(e) {
                    return !(e.x < this.min.x) && !(e.x > this.max.x) && !(e.y < this.min.y) && !(e.y > this.max.y) && !(e.z < this.min.z) && !(e.z > this.max.z)
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                }
                getParameter(e, t) {
                    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(e) {
                    return !(e.max.x < this.min.x) && !(e.min.x > this.max.x) && !(e.max.y < this.min.y) && !(e.min.y > this.max.y) && !(e.max.z < this.min.z) && !(e.min.z > this.max.z)
                }
                intersectsSphere(e) {
                    return this.clampPoint(e.center, eD), eD.distanceToSquared(e.center) <= e.radius * e.radius
                }
                intersectsPlane(e) {
                    let t, i;
                    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant
                }
                intersectsTriangle(e) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(eV), eG.subVectors(this.max, eV), eO.subVectors(e.a, eV), ez.subVectors(e.b, eV), eU.subVectors(e.c, eV), eB.subVectors(ez, eO), eF.subVectors(eU, ez), ek.subVectors(eO, eU);
                    let t = [0, -eB.z, eB.y, 0, -eF.z, eF.y, 0, -ek.z, ek.y, eB.z, 0, -eB.x, eF.z, 0, -eF.x, ek.z, 0, -ek.x, -eB.y, eB.x, 0, -eF.y, eF.x, 0, -ek.y, ek.x, 0];
                    return !!(ej(t, eO, ez, eU, eG) && ej(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], eO, ez, eU, eG)) && (eW.crossVectors(eB, eF), ej(t = [eW.x, eW.y, eW.z], eO, ez, eU, eG))
                }
                clampPoint(e, t) {
                    return t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    let t = eD.copy(e).clamp(this.min, this.max);
                    return t.sub(e).length()
                }
                getBoundingSphere(e) {
                    return this.getCenter(e.center), e.radius = .5 * this.getSize(eD).length(), e
                }
                intersect(e) {
                    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
                applyMatrix4(e) {
                    return this.isEmpty() || (eI[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), eI[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), eI[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), eI[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), eI[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), eI[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), eI[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), eI[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(eI)), this
                }
                translate(e) {
                    return this.min.add(e), this.max.add(e), this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            let eI = [new eC, new eC, new eC, new eC, new eC, new eC, new eC, new eC],
                eD = new eC,
                eN = new eR,
                eO = new eC,
                ez = new eC,
                eU = new eC,
                eB = new eC,
                eF = new eC,
                ek = new eC,
                eV = new eC,
                eG = new eC,
                eW = new eC,
                eH = new eC;

            function ej(e, t, i, n, r) {
                for (let a = 0, s = e.length - 3; a <= s; a += 3) {
                    eH.fromArray(e, a);
                    let o = r.x * Math.abs(eH.x) + r.y * Math.abs(eH.y) + r.z * Math.abs(eH.z),
                        l = t.dot(eH),
                        h = i.dot(eH),
                        u = n.dot(eH);
                    if (Math.max(-Math.max(l, h, u), Math.min(l, h, u)) > o) return !1
                }
                return !0
            }
            let eq = new eR,
                eX = new eC,
                eJ = new eC;
            class eY {
                constructor(e = new eC, t = -1) {
                    this.center = e, this.radius = t
                }
                set(e, t) {
                    return this.center.copy(e), this.radius = t, this
                }
                setFromPoints(e, t) {
                    let i = this.center;
                    void 0 !== t ? i.copy(t) : eq.setFromPoints(e).getCenter(i);
                    let n = 0;
                    for (let r = 0, a = e.length; r < a; r++) n = Math.max(n, i.distanceToSquared(e[r]));
                    return this.radius = Math.sqrt(n), this
                }
                copy(e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(e) {
                    return e.distanceTo(this.center) - this.radius
                }
                intersectsSphere(e) {
                    let t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                }
                intersectsBox(e) {
                    return e.intersectsSphere(this)
                }
                intersectsPlane(e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(e, t) {
                    let i = this.center.distanceToSquared(e);
                    return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                }
                getBoundingBox(e) {
                    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
                }
                applyMatrix4(e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                }
                translate(e) {
                    return this.center.add(e), this
                }
                expandByPoint(e) {
                    if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
                    eX.subVectors(e, this.center);
                    let t = eX.lengthSq();
                    if (t > this.radius * this.radius) {
                        let i = Math.sqrt(t),
                            n = (i - this.radius) * .5;
                        this.center.addScaledVector(eX, n / i), this.radius += n
                    }
                    return this
                }
                union(e) {
                    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (eJ.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(eX.copy(e.center).add(eJ)), this.expandByPoint(eX.copy(e.center).sub(eJ))), this)
                }
                equals(e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            let eZ = new eC,
                eK = new eC,
                eQ = new eC,
                e$ = new eC,
                e0 = new eC,
                e1 = new eC,
                e3 = new eC;
            class e2 {
                constructor(e = new eC, t = new eC(0, 0, -1)) {
                    this.origin = e, this.direction = t
                }
                set(e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                }
                copy(e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                }
                at(e, t) {
                    return t.copy(this.direction).multiplyScalar(e).add(this.origin)
                }
                lookAt(e) {
                    return this.direction.copy(e).sub(this.origin).normalize(), this
                }
                recast(e) {
                    return this.origin.copy(this.at(e, eZ)), this
                }
                closestPointToPoint(e, t) {
                    t.subVectors(e, this.origin);
                    let i = t.dot(this.direction);
                    return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin)
                }
                distanceToPoint(e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                }
                distanceSqToPoint(e) {
                    let t = eZ.subVectors(e, this.origin).dot(this.direction);
                    return t < 0 ? this.origin.distanceToSquared(e) : (eZ.copy(this.direction).multiplyScalar(t).add(this.origin), eZ.distanceToSquared(e))
                }
                distanceSqToSegment(e, t, i, n) {
                    let r, a, s, o;
                    eK.copy(e).add(t).multiplyScalar(.5), eQ.copy(t).sub(e).normalize(), e$.copy(this.origin).sub(eK);
                    let l = .5 * e.distanceTo(t),
                        h = -this.direction.dot(eQ),
                        u = e$.dot(this.direction),
                        c = -e$.dot(eQ),
                        d = e$.lengthSq(),
                        p = Math.abs(1 - h * h);
                    if (p > 0) {
                        if (r = h * c - u, a = h * u - c, o = l * p, r >= 0) {
                            if (a >= -o) {
                                if (a <= o) {
                                    let f = 1 / p;
                                    r *= f, a *= f, s = r * (r + h * a + 2 * u) + a * (h * r + a + 2 * c) + d
                                } else s = -(r = Math.max(0, -(h * (a = l) + u))) * r + a * (a + 2 * c) + d
                            } else s = -(r = Math.max(0, -(h * (a = -l) + u))) * r + a * (a + 2 * c) + d
                        } else a <= -o ? (a = (r = Math.max(0, -(-h * l + u))) > 0 ? -l : Math.min(Math.max(-l, -c), l), s = -r * r + a * (a + 2 * c) + d) : a <= o ? (r = 0, s = (a = Math.min(Math.max(-l, -c), l)) * (a + 2 * c) + d) : (a = (r = Math.max(0, -(h * l + u))) > 0 ? l : Math.min(Math.max(-l, -c), l), s = -r * r + a * (a + 2 * c) + d)
                    } else a = h > 0 ? -l : l, s = -(r = Math.max(0, -(h * a + u))) * r + a * (a + 2 * c) + d;
                    return i && i.copy(this.direction).multiplyScalar(r).add(this.origin), n && n.copy(eQ).multiplyScalar(a).add(eK), s
                }
                intersectSphere(e, t) {
                    eZ.subVectors(e.center, this.origin);
                    let i = eZ.dot(this.direction),
                        n = eZ.dot(eZ) - i * i,
                        r = e.radius * e.radius;
                    if (n > r) return null;
                    let a = Math.sqrt(r - n),
                        s = i - a,
                        o = i + a;
                    return s < 0 && o < 0 ? null : s < 0 ? this.at(o, t) : this.at(s, t)
                }
                intersectsSphere(e) {
                    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                }
                distanceToPlane(e) {
                    let t = e.normal.dot(this.direction);
                    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    let i = -(this.origin.dot(e.normal) + e.constant) / t;
                    return i >= 0 ? i : null
                }
                intersectPlane(e, t) {
                    let i = this.distanceToPlane(e);
                    return null === i ? null : this.at(i, t)
                }
                intersectsPlane(e) {
                    let t = e.distanceToPoint(this.origin);
                    if (0 === t) return !0;
                    let i = e.normal.dot(this.direction);
                    return i * t < 0
                }
                intersectBox(e, t) {
                    let i, n, r, a, s, o;
                    let l = 1 / this.direction.x,
                        h = 1 / this.direction.y,
                        u = 1 / this.direction.z,
                        c = this.origin;
                    return (l >= 0 ? (i = (e.min.x - c.x) * l, n = (e.max.x - c.x) * l) : (i = (e.max.x - c.x) * l, n = (e.min.x - c.x) * l), h >= 0 ? (r = (e.min.y - c.y) * h, a = (e.max.y - c.y) * h) : (r = (e.max.y - c.y) * h, a = (e.min.y - c.y) * h), i > a || r > n) ? null : ((r > i || isNaN(i)) && (i = r), (a < n || isNaN(n)) && (n = a), u >= 0 ? (s = (e.min.z - c.z) * u, o = (e.max.z - c.z) * u) : (s = (e.max.z - c.z) * u, o = (e.min.z - c.z) * u), i > o || s > n) ? null : ((s > i || i != i) && (i = s), (o < n || n != n) && (n = o), n < 0) ? null : this.at(i >= 0 ? i : n, t)
                }
                intersectsBox(e) {
                    return null !== this.intersectBox(e, eZ)
                }
                intersectTriangle(e, t, i, n, r) {
                    let a;
                    e0.subVectors(t, e), e1.subVectors(i, e), e3.crossVectors(e0, e1);
                    let s = this.direction.dot(e3);
                    if (s > 0) {
                        if (n) return null;
                        a = 1
                    } else {
                        if (!(s < 0)) return null;
                        a = -1, s = -s
                    }
                    e$.subVectors(this.origin, e);
                    let o = a * this.direction.dot(e1.crossVectors(e$, e1));
                    if (o < 0) return null;
                    let l = a * this.direction.dot(e0.cross(e$));
                    if (l < 0 || o + l > s) return null;
                    let h = -a * e$.dot(e3);
                    return h < 0 ? null : this.at(h / s, r)
                }
                applyMatrix4(e) {
                    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                }
                equals(e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            class e4 {
                constructor() {
                    e4.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
                }
                set(e, t, i, n, r, a, s, o, l, h, u, c, d, p, f, m) {
                    let g = this.elements;
                    return g[0] = e, g[4] = t, g[8] = i, g[12] = n, g[1] = r, g[5] = a, g[9] = s, g[13] = o, g[2] = l, g[6] = h, g[10] = u, g[14] = c, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return new e4().fromArray(this.elements)
                }
                copy(e) {
                    let t = this.elements,
                        i = e.elements;
                    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this
                }
                copyPosition(e) {
                    let t = this.elements,
                        i = e.elements;
                    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this
                }
                setFromMatrix3(e) {
                    let t = e.elements;
                    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
                }
                extractBasis(e, t, i) {
                    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
                }
                makeBasis(e, t, i) {
                    return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(e) {
                    let t = this.elements,
                        i = e.elements,
                        n = 1 / e5.setFromMatrixColumn(e, 0).length(),
                        r = 1 / e5.setFromMatrixColumn(e, 1).length(),
                        a = 1 / e5.setFromMatrixColumn(e, 2).length();
                    return t[0] = i[0] * n, t[1] = i[1] * n, t[2] = i[2] * n, t[3] = 0, t[4] = i[4] * r, t[5] = i[5] * r, t[6] = i[6] * r, t[7] = 0, t[8] = i[8] * a, t[9] = i[9] * a, t[10] = i[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromEuler(e) {
                    let t = this.elements,
                        i = e.x,
                        n = e.y,
                        r = e.z,
                        a = Math.cos(i),
                        s = Math.sin(i),
                        o = Math.cos(n),
                        l = Math.sin(n),
                        h = Math.cos(r),
                        u = Math.sin(r);
                    if ("XYZ" === e.order) {
                        let c = a * h,
                            d = a * u,
                            p = s * h,
                            f = s * u;
                        t[0] = o * h, t[4] = -o * u, t[8] = l, t[1] = d + p * l, t[5] = c - f * l, t[9] = -s * o, t[2] = f - c * l, t[6] = p + d * l, t[10] = a * o
                    } else if ("YXZ" === e.order) {
                        let m = o * h,
                            g = o * u,
                            v = l * h,
                            _ = l * u;
                        t[0] = m + _ * s, t[4] = v * s - g, t[8] = a * l, t[1] = a * u, t[5] = a * h, t[9] = -s, t[2] = g * s - v, t[6] = _ + m * s, t[10] = a * o
                    } else if ("ZXY" === e.order) {
                        let x = o * h,
                            y = o * u,
                            M = l * h,
                            b = l * u;
                        t[0] = x - b * s, t[4] = -a * u, t[8] = M + y * s, t[1] = y + M * s, t[5] = a * h, t[9] = b - x * s, t[2] = -a * l, t[6] = s, t[10] = a * o
                    } else if ("ZYX" === e.order) {
                        let S = a * h,
                            w = a * u,
                            T = s * h,
                            E = s * u;
                        t[0] = o * h, t[4] = T * l - w, t[8] = S * l + E, t[1] = o * u, t[5] = E * l + S, t[9] = w * l - T, t[2] = -l, t[6] = s * o, t[10] = a * o
                    } else if ("YZX" === e.order) {
                        let A = a * o,
                            C = a * l,
                            L = s * o,
                            P = s * l;
                        t[0] = o * h, t[4] = P - A * u, t[8] = L * u + C, t[1] = u, t[5] = a * h, t[9] = -s * h, t[2] = -l * h, t[6] = C * u + L, t[10] = A - P * u
                    } else if ("XZY" === e.order) {
                        let R = a * o,
                            I = a * l,
                            D = s * o,
                            N = s * l;
                        t[0] = o * h, t[4] = -u, t[8] = l * h, t[1] = R * u + N, t[5] = a * h, t[9] = I * u - D, t[2] = D * u - I, t[6] = s * h, t[10] = N * u + R
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromQuaternion(e) {
                    return this.compose(e7, e, e8)
                }
                lookAt(e, t, i) {
                    let n = this.elements;
                    return tt.subVectors(e, t), 0 === tt.lengthSq() && (tt.z = 1), tt.normalize(), e9.crossVectors(i, tt), 0 === e9.lengthSq() && (1 === Math.abs(i.z) ? tt.x += 1e-4 : tt.z += 1e-4, tt.normalize(), e9.crossVectors(i, tt)), e9.normalize(), te.crossVectors(tt, e9), n[0] = e9.x, n[4] = te.x, n[8] = tt.x, n[1] = e9.y, n[5] = te.y, n[9] = tt.y, n[2] = e9.z, n[6] = te.z, n[10] = tt.z, this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    let i = e.elements,
                        n = t.elements,
                        r = this.elements,
                        a = i[0],
                        s = i[4],
                        o = i[8],
                        l = i[12],
                        h = i[1],
                        u = i[5],
                        c = i[9],
                        d = i[13],
                        p = i[2],
                        f = i[6],
                        m = i[10],
                        g = i[14],
                        v = i[3],
                        _ = i[7],
                        x = i[11],
                        y = i[15],
                        M = n[0],
                        b = n[4],
                        S = n[8],
                        w = n[12],
                        T = n[1],
                        E = n[5],
                        A = n[9],
                        C = n[13],
                        L = n[2],
                        P = n[6],
                        R = n[10],
                        I = n[14],
                        D = n[3],
                        N = n[7],
                        O = n[11],
                        z = n[15];
                    return r[0] = a * M + s * T + o * L + l * D, r[4] = a * b + s * E + o * P + l * N, r[8] = a * S + s * A + o * R + l * O, r[12] = a * w + s * C + o * I + l * z, r[1] = h * M + u * T + c * L + d * D, r[5] = h * b + u * E + c * P + d * N, r[9] = h * S + u * A + c * R + d * O, r[13] = h * w + u * C + c * I + d * z, r[2] = p * M + f * T + m * L + g * D, r[6] = p * b + f * E + m * P + g * N, r[10] = p * S + f * A + m * R + g * O, r[14] = p * w + f * C + m * I + g * z, r[3] = v * M + _ * T + x * L + y * D, r[7] = v * b + _ * E + x * P + y * N, r[11] = v * S + _ * A + x * R + y * O, r[15] = v * w + _ * C + x * I + y * z, this
                }
                multiplyScalar(e) {
                    let t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                }
                determinant() {
                    let e = this.elements,
                        t = e[0],
                        i = e[4],
                        n = e[8],
                        r = e[12],
                        a = e[1],
                        s = e[5],
                        o = e[9],
                        l = e[13],
                        h = e[2],
                        u = e[6],
                        c = e[10],
                        d = e[14],
                        p = e[3],
                        f = e[7],
                        m = e[11],
                        g = e[15];
                    return p * (+r * o * u - n * l * u - r * s * c + i * l * c + n * s * d - i * o * d) + f * (+t * o * d - t * l * c + r * a * c - n * a * d + n * l * h - r * o * h) + m * (+t * l * u - t * s * d - r * a * u + i * a * d + r * s * h - i * l * h) + g * (-n * s * h - t * o * u + t * s * c + n * a * u - i * a * c + i * o * h)
                }
                transpose() {
                    let e;
                    let t = this.elements;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                }
                setPosition(e, t, i) {
                    let n = this.elements;
                    return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this
                }
                invert() {
                    let e = this.elements,
                        t = e[0],
                        i = e[1],
                        n = e[2],
                        r = e[3],
                        a = e[4],
                        s = e[5],
                        o = e[6],
                        l = e[7],
                        h = e[8],
                        u = e[9],
                        c = e[10],
                        d = e[11],
                        p = e[12],
                        f = e[13],
                        m = e[14],
                        g = e[15],
                        v = u * m * l - f * c * l + f * o * d - s * m * d - u * o * g + s * c * g,
                        _ = p * c * l - h * m * l - p * o * d + a * m * d + h * o * g - a * c * g,
                        x = h * f * l - p * u * l + p * s * d - a * f * d - h * s * g + a * u * g,
                        y = p * u * o - h * f * o - p * s * c + a * f * c + h * s * m - a * u * m,
                        M = t * v + i * _ + n * x + r * y;
                    if (0 === M) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    let b = 1 / M;
                    return e[0] = v * b, e[1] = (f * c * r - u * m * r - f * n * d + i * m * d + u * n * g - i * c * g) * b, e[2] = (s * m * r - f * o * r + f * n * l - i * m * l - s * n * g + i * o * g) * b, e[3] = (u * o * r - s * c * r - u * n * l + i * c * l + s * n * d - i * o * d) * b, e[4] = _ * b, e[5] = (h * m * r - p * c * r + p * n * d - t * m * d - h * n * g + t * c * g) * b, e[6] = (p * o * r - a * m * r - p * n * l + t * m * l + a * n * g - t * o * g) * b, e[7] = (a * c * r - h * o * r + h * n * l - t * c * l - a * n * d + t * o * d) * b, e[8] = x * b, e[9] = (p * u * r - h * f * r - p * i * d + t * f * d + h * i * g - t * u * g) * b, e[10] = (a * f * r - p * s * r + p * i * l - t * f * l - a * i * g + t * s * g) * b, e[11] = (h * s * r - a * u * r - h * i * l + t * u * l + a * i * d - t * s * d) * b, e[12] = y * b, e[13] = (h * f * n - p * u * n + p * i * c - t * f * c - h * i * m + t * u * m) * b, e[14] = (p * s * n - a * f * n - p * i * o + t * f * o + a * i * m - t * s * m) * b, e[15] = (a * u * n - h * s * n + h * i * o - t * u * o - a * i * c + t * s * c) * b, this
                }
                scale(e) {
                    let t = this.elements,
                        i = e.x,
                        n = e.y,
                        r = e.z;
                    return t[0] *= i, t[4] *= n, t[8] *= r, t[1] *= i, t[5] *= n, t[9] *= r, t[2] *= i, t[6] *= n, t[10] *= r, t[3] *= i, t[7] *= n, t[11] *= r, this
                }
                getMaxScaleOnAxis() {
                    let e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, i, n))
                }
                makeTranslation(e, t, i) {
                    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
                }
                makeRotationX(e) {
                    let t = Math.cos(e),
                        i = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this
                }
                makeRotationY(e) {
                    let t = Math.cos(e),
                        i = Math.sin(e);
                    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(e) {
                    let t = Math.cos(e),
                        i = Math.sin(e);
                    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(e, t) {
                    let i = Math.cos(t),
                        n = Math.sin(t),
                        r = 1 - i,
                        a = e.x,
                        s = e.y,
                        o = e.z,
                        l = r * a,
                        h = r * s;
                    return this.set(l * a + i, l * s - n * o, l * o + n * s, 0, l * s + n * o, h * s + i, h * o - n * a, 0, l * o - n * s, h * o + n * a, r * o * o + i, 0, 0, 0, 0, 1), this
                }
                makeScale(e, t, i) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
                }
                makeShear(e, t, i, n, r, a) {
                    return this.set(1, i, r, 0, e, 1, a, 0, t, n, 1, 0, 0, 0, 0, 1), this
                }
                compose(e, t, i) {
                    let n = this.elements,
                        r = t._x,
                        a = t._y,
                        s = t._z,
                        o = t._w,
                        l = r + r,
                        h = a + a,
                        u = s + s,
                        c = r * l,
                        d = r * h,
                        p = r * u,
                        f = a * h,
                        m = a * u,
                        g = s * u,
                        v = o * l,
                        _ = o * h,
                        x = o * u,
                        y = i.x,
                        M = i.y,
                        b = i.z;
                    return n[0] = (1 - (f + g)) * y, n[1] = (d + x) * y, n[2] = (p - _) * y, n[3] = 0, n[4] = (d - x) * M, n[5] = (1 - (c + g)) * M, n[6] = (m + v) * M, n[7] = 0, n[8] = (p + _) * b, n[9] = (m - v) * b, n[10] = (1 - (c + f)) * b, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this
                }
                decompose(e, t, i) {
                    let n = this.elements,
                        r = e5.set(n[0], n[1], n[2]).length(),
                        a = e5.set(n[4], n[5], n[6]).length(),
                        s = e5.set(n[8], n[9], n[10]).length(),
                        o = this.determinant();
                    o < 0 && (r = -r), e.x = n[12], e.y = n[13], e.z = n[14], e6.copy(this);
                    let l = 1 / r,
                        h = 1 / a,
                        u = 1 / s;
                    return e6.elements[0] *= l, e6.elements[1] *= l, e6.elements[2] *= l, e6.elements[4] *= h, e6.elements[5] *= h, e6.elements[6] *= h, e6.elements[8] *= u, e6.elements[9] *= u, e6.elements[10] *= u, t.setFromRotationMatrix(e6), i.x = r, i.y = a, i.z = s, this
                }
                makePerspective(e, t, i, n, r, a) {
                    let s = this.elements;
                    return s[0] = 2 * r / (t - e), s[4] = 0, s[8] = (t + e) / (t - e), s[12] = 0, s[1] = 0, s[5] = 2 * r / (i - n), s[9] = (i + n) / (i - n), s[13] = 0, s[2] = 0, s[6] = 0, s[10] = -(a + r) / (a - r), s[14] = -2 * a * r / (a - r), s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
                }
                makeOrthographic(e, t, i, n, r, a) {
                    let s = this.elements,
                        o = 1 / (t - e),
                        l = 1 / (i - n),
                        h = 1 / (a - r);
                    return s[0] = 2 * o, s[4] = 0, s[8] = 0, s[12] = -((t + e) * o), s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -((i + n) * l), s[2] = 0, s[6] = 0, s[10] = -2 * h, s[14] = -((a + r) * h), s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
                }
                equals(e) {
                    let t = this.elements,
                        i = e.elements;
                    for (let n = 0; n < 16; n++)
                        if (t[n] !== i[n]) return !1;
                    return !0
                }
                fromArray(e, t = 0) {
                    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    let i = this.elements;
                    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
                }
            }
            let e5 = new eC,
                e6 = new e4,
                e7 = new eC(0, 0, 0),
                e8 = new eC(1, 1, 1),
                e9 = new eC,
                te = new eC,
                tt = new eC,
                ti = new e4,
                tn = new eA;
            class tr {
                constructor(e = 0, t = 0, i = 0, n = tr.DefaultOrder) {
                    this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = n
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(e) {
                    this._order = e, this._onChangeCallback()
                }
                set(e, t, i, n = this._order) {
                    return this._x = e, this._y = t, this._z = i, this._order = n, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(e, t = this._order, i = !0) {
                    let n = e.elements,
                        r = n[0],
                        a = n[4],
                        s = n[8],
                        o = n[1],
                        l = n[5],
                        h = n[9],
                        u = n[2],
                        c = n[6],
                        d = n[10];
                    switch (t) {
                        case "XYZ":
                            this._y = Math.asin(J(s, -1, 1)), .9999999 > Math.abs(s) ? (this._x = Math.atan2(-h, d), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(c, l), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-J(h, -1, 1)), .9999999 > Math.abs(h) ? (this._y = Math.atan2(s, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-u, r), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(J(c, -1, 1)), .9999999 > Math.abs(c) ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-J(u, -1, 1)), .9999999 > Math.abs(u) ? (this._x = Math.atan2(c, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-a, l));
                            break;
                        case "YZX":
                            this._z = Math.asin(J(o, -1, 1)), .9999999 > Math.abs(o) ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(s, d));
                            break;
                        case "XZY":
                            this._z = Math.asin(-J(a, -1, 1)), .9999999 > Math.abs(a) ? (this._x = Math.atan2(c, l), this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-h, d), this._y = 0);
                            break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                    }
                    return this._order = t, !0 === i && this._onChangeCallback(), this
                }
                setFromQuaternion(e, t, i) {
                    return ti.makeRotationFromQuaternion(e), this.setFromRotationMatrix(ti, t, i)
                }
                setFromVector3(e, t = this._order) {
                    return this.set(e.x, e.y, e.z, t)
                }
                reorder(e) {
                    return tn.setFromEuler(this), this.setFromQuaternion(tn, e)
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                }
                fromArray(e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}*[Symbol.iterator]() {
                    yield this._x, yield this._y, yield this._z, yield this._order
                }
                toVector3() {
                    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
                }
            }
            tr.DefaultOrder = "XYZ", tr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            class ta {
                constructor() {
                    this.mask = 1
                }
                set(e) {
                    this.mask = (1 << e | 0) >>> 0
                }
                enable(e) {
                    this.mask |= 1 << e | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(e) {
                    this.mask ^= 1 << e | 0
                }
                disable(e) {
                    this.mask &= ~(1 << e | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(e) {
                    return (this.mask & e.mask) != 0
                }
                isEnabled(e) {
                    return (this.mask & (1 << e | 0)) != 0
                }
            }
            let ts = 0,
                to = new eC,
                tl = new eA,
                th = new e4,
                tu = new eC,
                tc = new eC,
                td = new eC,
                tp = new eA,
                tf = new eC(1, 0, 0),
                tm = new eC(0, 1, 0),
                tg = new eC(0, 0, 1),
                tv = {
                    type: "added"
                },
                t_ = {
                    type: "removed"
                };
            class tx extends G {
                constructor() {
                    super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                        value: ts++
                    }), this.uuid = X(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = tx.DefaultUp.clone();
                    let e = new eC,
                        t = new tr,
                        i = new eA,
                        n = new eC(1, 1, 1);
                    t._onChange(function() {
                        i.setFromEuler(t, !1)
                    }), i._onChange(function() {
                        t.setFromQuaternion(i, void 0, !1)
                    }), Object.defineProperties(this, {
                        position: {
                            configurable: !0,
                            enumerable: !0,
                            value: e
                        },
                        rotation: {
                            configurable: !0,
                            enumerable: !0,
                            value: t
                        },
                        quaternion: {
                            configurable: !0,
                            enumerable: !0,
                            value: i
                        },
                        scale: {
                            configurable: !0,
                            enumerable: !0,
                            value: n
                        },
                        modelViewMatrix: {
                            value: new e4
                        },
                        normalMatrix: {
                            value: new er
                        }
                    }), this.matrix = new e4, this.matrixWorld = new e4, this.matrixAutoUpdate = tx.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = tx.DefaultMatrixWorldAutoUpdate, this.layers = new ta, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                }
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
                }
                applyQuaternion(e) {
                    return this.quaternion.premultiply(e), this
                }
                setRotationFromAxisAngle(e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                }
                setRotationFromEuler(e) {
                    this.quaternion.setFromEuler(e, !0)
                }
                setRotationFromMatrix(e) {
                    this.quaternion.setFromRotationMatrix(e)
                }
                setRotationFromQuaternion(e) {
                    this.quaternion.copy(e)
                }
                rotateOnAxis(e, t) {
                    return tl.setFromAxisAngle(e, t), this.quaternion.multiply(tl), this
                }
                rotateOnWorldAxis(e, t) {
                    return tl.setFromAxisAngle(e, t), this.quaternion.premultiply(tl), this
                }
                rotateX(e) {
                    return this.rotateOnAxis(tf, e)
                }
                rotateY(e) {
                    return this.rotateOnAxis(tm, e)
                }
                rotateZ(e) {
                    return this.rotateOnAxis(tg, e)
                }
                translateOnAxis(e, t) {
                    return to.copy(e).applyQuaternion(this.quaternion), this.position.add(to.multiplyScalar(t)), this
                }
                translateX(e) {
                    return this.translateOnAxis(tf, e)
                }
                translateY(e) {
                    return this.translateOnAxis(tm, e)
                }
                translateZ(e) {
                    return this.translateOnAxis(tg, e)
                }
                localToWorld(e) {
                    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
                }
                worldToLocal(e) {
                    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(th.copy(this.matrixWorld).invert())
                }
                lookAt(e, t, i) {
                    e.isVector3 ? tu.copy(e) : tu.set(e, t, i);
                    let n = this.parent;
                    this.updateWorldMatrix(!0, !1), tc.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? th.lookAt(tc, tu, this.up) : th.lookAt(tu, tc, this.up), this.quaternion.setFromRotationMatrix(th), n && (th.extractRotation(n.matrixWorld), tl.setFromRotationMatrix(th), this.quaternion.premultiply(tl.invert()))
                }
                add(e) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this
                    }
                    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(tv)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
                }
                remove(e) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this
                    }
                    let i = this.children.indexOf(e);
                    return -1 !== i && (e.parent = null, this.children.splice(i, 1), e.dispatchEvent(t_)), this
                }
                removeFromParent() {
                    let e = this.parent;
                    return null !== e && e.remove(this), this
                }
                clear() {
                    for (let e = 0; e < this.children.length; e++) {
                        let t = this.children[e];
                        t.parent = null, t.dispatchEvent(t_)
                    }
                    return this.children.length = 0, this
                }
                attach(e) {
                    return this.updateWorldMatrix(!0, !1), th.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), th.multiply(e.parent.matrixWorld)), e.applyMatrix4(th), this.add(e), e.updateWorldMatrix(!1, !0), this
                }
                getObjectById(e) {
                    return this.getObjectByProperty("id", e)
                }
                getObjectByName(e) {
                    return this.getObjectByProperty("name", e)
                }
                getObjectByProperty(e, t) {
                    if (this[e] === t) return this;
                    for (let i = 0, n = this.children.length; i < n; i++) {
                        let r = this.children[i],
                            a = r.getObjectByProperty(e, t);
                        if (void 0 !== a) return a
                    }
                }
                getObjectsByProperty(e, t) {
                    let i = [];
                    this[e] === t && i.push(this);
                    for (let n = 0, r = this.children.length; n < r; n++) {
                        let a = this.children[n].getObjectsByProperty(e, t);
                        a.length > 0 && (i = i.concat(a))
                    }
                    return i
                }
                getWorldPosition(e) {
                    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
                }
                getWorldQuaternion(e) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(tc, e, td), e
                }
                getWorldScale(e) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(tc, tp, e), e
                }
                getWorldDirection(e) {
                    this.updateWorldMatrix(!0, !1);
                    let t = this.matrixWorld.elements;
                    return e.set(t[8], t[9], t[10]).normalize()
                }
                raycast() {}
                traverse(e) {
                    e(this);
                    let t = this.children;
                    for (let i = 0, n = t.length; i < n; i++) t[i].traverse(e)
                }
                traverseVisible(e) {
                    if (!1 === this.visible) return;
                    e(this);
                    let t = this.children;
                    for (let i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e)
                }
                traverseAncestors(e) {
                    let t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e))
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                }
                updateMatrixWorld(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                    let t = this.children;
                    for (let i = 0, n = t.length; i < n; i++) {
                        let r = t[i];
                        (!0 === r.matrixWorldAutoUpdate || !0 === e) && r.updateMatrixWorld(e)
                    }
                }
                updateWorldMatrix(e, t) {
                    let i = this.parent;
                    if (!0 === e && null !== i && !0 === i.matrixWorldAutoUpdate && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
                        let n = this.children;
                        for (let r = 0, a = n.length; r < a; r++) {
                            let s = n[r];
                            !0 === s.matrixWorldAutoUpdate && s.updateWorldMatrix(!1, !0)
                        }
                    }
                }
                toJSON(e) {
                    let t = void 0 === e || "string" == typeof e,
                        i = {};
                    t && (e = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {},
                        nodes: {}
                    }, i.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    let n = {};

                    function r(t, i) {
                        return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)), i.uuid
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (n.environment = this.environment.toJSON(e).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        n.geometry = r(e.geometries, this.geometry);
                        let a = this.geometry.parameters;
                        if (void 0 !== a && void 0 !== a.shapes) {
                            let s = a.shapes;
                            if (Array.isArray(s))
                                for (let o = 0, l = s.length; o < l; o++) {
                                    let h = s[o];
                                    r(e.shapes, h)
                                } else r(e.shapes, s)
                        }
                    }
                    if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), void 0 !== this.material) {
                        if (Array.isArray(this.material)) {
                            let u = [];
                            for (let c = 0, d = this.material.length; c < d; c++) u.push(r(e.materials, this.material[c]));
                            n.material = u
                        } else n.material = r(e.materials, this.material)
                    }
                    if (this.children.length > 0) {
                        n.children = [];
                        for (let p = 0; p < this.children.length; p++) n.children.push(this.children[p].toJSON(e).object)
                    }
                    if (this.animations.length > 0) {
                        n.animations = [];
                        for (let f = 0; f < this.animations.length; f++) {
                            let m = this.animations[f];
                            n.animations.push(r(e.animations, m))
                        }
                    }
                    if (t) {
                        let g = w(e.geometries),
                            v = w(e.materials),
                            _ = w(e.textures),
                            x = w(e.images),
                            y = w(e.shapes),
                            M = w(e.skeletons),
                            b = w(e.animations),
                            S = w(e.nodes);
                        g.length > 0 && (i.geometries = g), v.length > 0 && (i.materials = v), _.length > 0 && (i.textures = _), x.length > 0 && (i.images = x), y.length > 0 && (i.shapes = y), M.length > 0 && (i.skeletons = M), b.length > 0 && (i.animations = b), S.length > 0 && (i.nodes = S)
                    }
                    return i.object = n, i;

                    function w(e) {
                        let t = [];
                        for (let i in e) {
                            let n = e[i];
                            delete n.metadata, t.push(n)
                        }
                        return t
                    }
                }
                clone(e) {
                    return new this.constructor().copy(this, e)
                }
                copy(e, t = !0) {
                    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                        for (let i = 0; i < e.children.length; i++) {
                            let n = e.children[i];
                            this.add(n.clone())
                        }
                    return this
                }
            }
            tx.DefaultUp = new eC(0, 1, 0), tx.DefaultMatrixAutoUpdate = !0, tx.DefaultMatrixWorldAutoUpdate = !0;
            let ty = new eC,
                tM = new eC,
                tb = new eC,
                tS = new eC,
                tw = new eC,
                tT = new eC,
                tE = new eC,
                tA = new eC,
                tC = new eC,
                tL = new eC;
            class tP {
                constructor(e = new eC, t = new eC, i = new eC) {
                    this.a = e, this.b = t, this.c = i
                }
                static getNormal(e, t, i, n) {
                    n.subVectors(i, t), ty.subVectors(e, t), n.cross(ty);
                    let r = n.lengthSq();
                    return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
                }
                static getBarycoord(e, t, i, n, r) {
                    ty.subVectors(n, t), tM.subVectors(i, t), tb.subVectors(e, t);
                    let a = ty.dot(ty),
                        s = ty.dot(tM),
                        o = ty.dot(tb),
                        l = tM.dot(tM),
                        h = tM.dot(tb),
                        u = a * l - s * s;
                    if (0 === u) return r.set(-2, -1, -1);
                    let c = 1 / u,
                        d = (l * o - s * h) * c,
                        p = (a * h - s * o) * c;
                    return r.set(1 - d - p, p, d)
                }
                static containsPoint(e, t, i, n) {
                    return this.getBarycoord(e, t, i, n, tS), tS.x >= 0 && tS.y >= 0 && tS.x + tS.y <= 1
                }
                static getUV(e, t, i, n, r, a, s, o) {
                    return this.getBarycoord(e, t, i, n, tS), o.set(0, 0), o.addScaledVector(r, tS.x), o.addScaledVector(a, tS.y), o.addScaledVector(s, tS.z), o
                }
                static isFrontFacing(e, t, i, n) {
                    return ty.subVectors(i, t), tM.subVectors(e, t), 0 > ty.cross(tM).dot(n)
                }
                set(e, t, i) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
                }
                setFromPointsAndIndices(e, t, i, n) {
                    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this
                }
                setFromAttributeAndIndices(e, t, i, n) {
                    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, n), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                }
                getArea() {
                    return ty.subVectors(this.c, this.b), tM.subVectors(this.a, this.b), .5 * ty.cross(tM).length()
                }
                getMidpoint(e) {
                    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(e) {
                    return tP.getNormal(this.a, this.b, this.c, e)
                }
                getPlane(e) {
                    return e.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(e, t) {
                    return tP.getBarycoord(e, this.a, this.b, this.c, t)
                }
                getUV(e, t, i, n, r) {
                    return tP.getUV(e, this.a, this.b, this.c, t, i, n, r)
                }
                containsPoint(e) {
                    return tP.containsPoint(e, this.a, this.b, this.c)
                }
                isFrontFacing(e) {
                    return tP.isFrontFacing(this.a, this.b, this.c, e)
                }
                intersectsBox(e) {
                    return e.intersectsTriangle(this)
                }
                closestPointToPoint(e, t) {
                    let i, n;
                    let r = this.a,
                        a = this.b,
                        s = this.c;
                    tw.subVectors(a, r), tT.subVectors(s, r), tA.subVectors(e, r);
                    let o = tw.dot(tA),
                        l = tT.dot(tA);
                    if (o <= 0 && l <= 0) return t.copy(r);
                    tC.subVectors(e, a);
                    let h = tw.dot(tC),
                        u = tT.dot(tC);
                    if (h >= 0 && u <= h) return t.copy(a);
                    let c = o * u - h * l;
                    if (c <= 0 && o >= 0 && h <= 0) return i = o / (o - h), t.copy(r).addScaledVector(tw, i);
                    tL.subVectors(e, s);
                    let d = tw.dot(tL),
                        p = tT.dot(tL);
                    if (p >= 0 && d <= p) return t.copy(s);
                    let f = d * l - o * p;
                    if (f <= 0 && l >= 0 && p <= 0) return n = l / (l - p), t.copy(r).addScaledVector(tT, n);
                    let m = h * p - d * u;
                    if (m <= 0 && u - h >= 0 && d - p >= 0) return tE.subVectors(s, a), n = (u - h) / (u - h + (d - p)), t.copy(a).addScaledVector(tE, n);
                    let g = 1 / (m + f + c);
                    return i = f * g, n = c * g, t.copy(r).addScaledVector(tw, i).addScaledVector(tT, n)
                }
                equals(e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }
            let tR = 0;
            class tI extends G {
                constructor() {
                    super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                        value: tR++
                    }), this.uuid = X(), this.name = "", this.type = "Material", this.blending = 1, this.side = o, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = f, this.blendEquation = d, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                }
                get alphaTest() {
                    return this._alphaTest
                }
                set alphaTest(e) {
                    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
                }
                onBuild() {}
                onBeforeRender() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString()
                }
                setValues(e) {
                    if (void 0 !== e)
                        for (let t in e) {
                            let i = e[t];
                            if (void 0 === i) {
                                console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                                continue
                            }
                            let n = this[t];
                            if (void 0 === n) {
                                console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
                                continue
                            }
                            n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i
                        }
                }
                toJSON(e) {
                    let t = void 0 === e || "string" == typeof e;
                    t && (e = {
                        textures: {},
                        images: {}
                    });
                    let i = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function n(e) {
                        let t = [];
                        for (let i in e) {
                            let n = e[i];
                            delete n.metadata, t.push(n)
                        }
                        return t
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), void 0 !== this.sheen && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (i.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (i.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (i.combine = this.combine)), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (i.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (i.size = this.size), null !== this.shadowSide && (i.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i.blending = this.blending), this.side !== o && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (i.flatShading = this.flatShading), !1 === this.visible && (i.visible = !1), !1 === this.toneMapped && (i.toneMapped = !1), !1 === this.fog && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData), t) {
                        let r = n(e.textures),
                            a = n(e.images);
                        r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a)
                    }
                    return i
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                    let t = e.clippingPlanes,
                        i = null;
                    if (null !== t) {
                        let n = t.length;
                        i = Array(n);
                        for (let r = 0; r !== n; ++r) i[r] = t[r].clone()
                    }
                    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
            }
            class tD extends tI {
                constructor(e) {
                    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new e_(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
                }
            }
            let tN = new eC,
                tO = new en;
            class tz {
                constructor(e, t, i = !1) {
                    if (Array.isArray(e)) throw TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = i, this.usage = 35044, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                copy(e) {
                    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
                }
                copyAt(e, t, i) {
                    e *= this.itemSize, i *= t.itemSize;
                    for (let n = 0, r = this.itemSize; n < r; n++) this.array[e + n] = t.array[i + n];
                    return this
                }
                copyArray(e) {
                    return this.array.set(e), this
                }
                applyMatrix3(e) {
                    if (2 === this.itemSize)
                        for (let t = 0, i = this.count; t < i; t++) tO.fromBufferAttribute(this, t), tO.applyMatrix3(e), this.setXY(t, tO.x, tO.y);
                    else if (3 === this.itemSize)
                        for (let n = 0, r = this.count; n < r; n++) tN.fromBufferAttribute(this, n), tN.applyMatrix3(e), this.setXYZ(n, tN.x, tN.y, tN.z);
                    return this
                }
                applyMatrix4(e) {
                    for (let t = 0, i = this.count; t < i; t++) tN.fromBufferAttribute(this, t), tN.applyMatrix4(e), this.setXYZ(t, tN.x, tN.y, tN.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, i = this.count; t < i; t++) tN.fromBufferAttribute(this, t), tN.applyNormalMatrix(e), this.setXYZ(t, tN.x, tN.y, tN.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, i = this.count; t < i; t++) tN.fromBufferAttribute(this, t), tN.transformDirection(e), this.setXYZ(t, tN.x, tN.y, tN.z);
                    return this
                }
                set(e, t = 0) {
                    return this.array.set(e, t), this
                }
                getX(e) {
                    let t = this.array[e * this.itemSize];
                    return this.normalized && (t = ee(t, this.array)), t
                }
                setX(e, t) {
                    return this.normalized && (t = et(t, this.array)), this.array[e * this.itemSize] = t, this
                }
                getY(e) {
                    let t = this.array[e * this.itemSize + 1];
                    return this.normalized && (t = ee(t, this.array)), t
                }
                setY(e, t) {
                    return this.normalized && (t = et(t, this.array)), this.array[e * this.itemSize + 1] = t, this
                }
                getZ(e) {
                    let t = this.array[e * this.itemSize + 2];
                    return this.normalized && (t = ee(t, this.array)), t
                }
                setZ(e, t) {
                    return this.normalized && (t = et(t, this.array)), this.array[e * this.itemSize + 2] = t, this
                }
                getW(e) {
                    let t = this.array[e * this.itemSize + 3];
                    return this.normalized && (t = ee(t, this.array)), t
                }
                setW(e, t) {
                    return this.normalized && (t = et(t, this.array)), this.array[e * this.itemSize + 3] = t, this
                }
                setXY(e, t, i) {
                    return e *= this.itemSize, this.normalized && (t = et(t, this.array), i = et(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this
                }
                setXYZ(e, t, i, n) {
                    return e *= this.itemSize, this.normalized && (t = et(t, this.array), i = et(i, this.array), n = et(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this
                }
                setXYZW(e, t, i, n, r) {
                    return e *= this.itemSize, this.normalized && (t = et(t, this.array), i = et(i, this.array), n = et(n, this.array), r = et(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this
                }
                onUpload(e) {
                    return this.onUploadCallback = e, this
                }
                clone() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
                toJSON() {
                    let e = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.from(this.array),
                        normalized: this.normalized
                    };
                    return "" !== this.name && (e.name = this.name), 35044 !== this.usage && (e.usage = this.usage), (0 !== this.updateRange.offset || -1 !== this.updateRange.count) && (e.updateRange = this.updateRange), e
                }
                copyColorsArray() {
                    console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
                }
                copyVector2sArray() {
                    console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
                }
                copyVector3sArray() {
                    console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
                }
                copyVector4sArray() {
                    console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
                }
            }
            class tU extends tz {
                constructor(e, t, i) {
                    super(new Uint16Array(e), t, i)
                }
            }
            class tB extends tz {
                constructor(e, t, i) {
                    super(new Uint32Array(e), t, i)
                }
            }
            class tF extends tz {
                constructor(e, t, i) {
                    super(new Float32Array(e), t, i)
                }
            }
            let tk = 0,
                tV = new e4,
                tG = new tx,
                tW = new eC,
                tH = new eR,
                tj = new eR,
                tq = new eC;
            class tX extends G {
                constructor() {
                    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                        value: tk++
                    }), this.uuid = X(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    }, this.userData = {}
                }
                getIndex() {
                    return this.index
                }
                setIndex(e) {
                    return Array.isArray(e) ? this.index = new(es(e) ? tB : tU)(e, 1) : this.index = e, this
                }
                getAttribute(e) {
                    return this.attributes[e]
                }
                setAttribute(e, t) {
                    return this.attributes[e] = t, this
                }
                deleteAttribute(e) {
                    return delete this.attributes[e], this
                }
                hasAttribute(e) {
                    return void 0 !== this.attributes[e]
                }
                addGroup(e, t, i = 0) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: i
                    })
                }
                clearGroups() {
                    this.groups = []
                }
                setDrawRange(e, t) {
                    this.drawRange.start = e, this.drawRange.count = t
                }
                applyMatrix4(e) {
                    let t = this.attributes.position;
                    void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                    let i = this.attributes.normal;
                    if (void 0 !== i) {
                        let n = new er().getNormalMatrix(e);
                        i.applyNormalMatrix(n), i.needsUpdate = !0
                    }
                    let r = this.attributes.tangent;
                    return void 0 !== r && (r.transformDirection(e), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                }
                applyQuaternion(e) {
                    return tV.makeRotationFromQuaternion(e), this.applyMatrix4(tV), this
                }
                rotateX(e) {
                    return tV.makeRotationX(e), this.applyMatrix4(tV), this
                }
                rotateY(e) {
                    return tV.makeRotationY(e), this.applyMatrix4(tV), this
                }
                rotateZ(e) {
                    return tV.makeRotationZ(e), this.applyMatrix4(tV), this
                }
                translate(e, t, i) {
                    return tV.makeTranslation(e, t, i), this.applyMatrix4(tV), this
                }
                scale(e, t, i) {
                    return tV.makeScale(e, t, i), this.applyMatrix4(tV), this
                }
                lookAt(e) {
                    return tG.lookAt(e), tG.updateMatrix(), this.applyMatrix4(tG.matrix), this
                }
                center() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(tW).negate(), this.translate(tW.x, tW.y, tW.z), this
                }
                setFromPoints(e) {
                    let t = [];
                    for (let i = 0, n = e.length; i < n; i++) {
                        let r = e[i];
                        t.push(r.x, r.y, r.z || 0)
                    }
                    return this.setAttribute("position", new tF(t, 3)), this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new eR);
                    let e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) {
                        console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new eC(-1 / 0, -1 / 0, -1 / 0), new eC(Infinity, Infinity, Infinity));
                        return
                    }
                    if (void 0 !== e) {
                        if (this.boundingBox.setFromBufferAttribute(e), t)
                            for (let i = 0, n = t.length; i < n; i++) {
                                let r = t[i];
                                tH.setFromBufferAttribute(r), this.morphTargetsRelative ? (tq.addVectors(this.boundingBox.min, tH.min), this.boundingBox.expandByPoint(tq), tq.addVectors(this.boundingBox.max, tH.max), this.boundingBox.expandByPoint(tq)) : (this.boundingBox.expandByPoint(tH.min), this.boundingBox.expandByPoint(tH.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new eY);
                    let e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) {
                        console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new eC, 1 / 0);
                        return
                    }
                    if (e) {
                        let i = this.boundingSphere.center;
                        if (tH.setFromBufferAttribute(e), t)
                            for (let n = 0, r = t.length; n < r; n++) {
                                let a = t[n];
                                tj.setFromBufferAttribute(a), this.morphTargetsRelative ? (tq.addVectors(tH.min, tj.min), tH.expandByPoint(tq), tq.addVectors(tH.max, tj.max), tH.expandByPoint(tq)) : (tH.expandByPoint(tj.min), tH.expandByPoint(tj.max))
                            }
                        tH.getCenter(i);
                        let s = 0;
                        for (let o = 0, l = e.count; o < l; o++) tq.fromBufferAttribute(e, o), s = Math.max(s, i.distanceToSquared(tq));
                        if (t)
                            for (let h = 0, u = t.length; h < u; h++) {
                                let c = t[h],
                                    d = this.morphTargetsRelative;
                                for (let p = 0, f = c.count; p < f; p++) tq.fromBufferAttribute(c, p), d && (tW.fromBufferAttribute(e, p), tq.add(tW)), s = Math.max(s, i.distanceToSquared(tq))
                            }
                        this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
                computeTangents() {
                    let e = this.index,
                        t = this.attributes;
                    if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) {
                        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                        return
                    }
                    let i = e.array,
                        n = t.position.array,
                        r = t.normal.array,
                        a = t.uv.array,
                        s = n.length / 3;
                    !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new tz(new Float32Array(4 * s), 4));
                    let o = this.getAttribute("tangent").array,
                        l = [],
                        h = [];
                    for (let u = 0; u < s; u++) l[u] = new eC, h[u] = new eC;
                    let c = new eC,
                        d = new eC,
                        p = new eC,
                        f = new en,
                        m = new en,
                        g = new en,
                        v = new eC,
                        _ = new eC,
                        x = this.groups;
                    0 === x.length && (x = [{
                        start: 0,
                        count: i.length
                    }]);
                    for (let y = 0, M = x.length; y < M; ++y) {
                        let b = x[y],
                            S = b.start,
                            w = b.count;
                        for (let T = S, E = S + w; T < E; T += 3) ! function(e, t, i) {
                            c.fromArray(n, 3 * e), d.fromArray(n, 3 * t), p.fromArray(n, 3 * i), f.fromArray(a, 2 * e), m.fromArray(a, 2 * t), g.fromArray(a, 2 * i), d.sub(c), p.sub(c), m.sub(f), g.sub(f);
                            let r = 1 / (m.x * g.y - g.x * m.y);
                            isFinite(r) && (v.copy(d).multiplyScalar(g.y).addScaledVector(p, -m.y).multiplyScalar(r), _.copy(p).multiplyScalar(m.x).addScaledVector(d, -g.x).multiplyScalar(r), l[e].add(v), l[t].add(v), l[i].add(v), h[e].add(_), h[t].add(_), h[i].add(_))
                        }(i[T + 0], i[T + 1], i[T + 2])
                    }
                    let A = new eC,
                        C = new eC,
                        L = new eC,
                        P = new eC;

                    function R(e) {
                        L.fromArray(r, 3 * e), P.copy(L);
                        let t = l[e];
                        A.copy(t), A.sub(L.multiplyScalar(L.dot(t))).normalize(), C.crossVectors(P, t);
                        let i = C.dot(h[e]);
                        o[4 * e] = A.x, o[4 * e + 1] = A.y, o[4 * e + 2] = A.z, o[4 * e + 3] = i < 0 ? -1 : 1
                    }
                    for (let I = 0, D = x.length; I < D; ++I) {
                        let N = x[I],
                            O = N.start,
                            z = N.count;
                        for (let U = O, B = O + z; U < B; U += 3) R(i[U + 0]), R(i[U + 1]), R(i[U + 2])
                    }
                }
                computeVertexNormals() {
                    let e = this.index,
                        t = this.getAttribute("position");
                    if (void 0 !== t) {
                        let i = this.getAttribute("normal");
                        if (void 0 === i) i = new tz(new Float32Array(3 * t.count), 3), this.setAttribute("normal", i);
                        else
                            for (let n = 0, r = i.count; n < r; n++) i.setXYZ(n, 0, 0, 0);
                        let a = new eC,
                            s = new eC,
                            o = new eC,
                            l = new eC,
                            h = new eC,
                            u = new eC,
                            c = new eC,
                            d = new eC;
                        if (e)
                            for (let p = 0, f = e.count; p < f; p += 3) {
                                let m = e.getX(p + 0),
                                    g = e.getX(p + 1),
                                    v = e.getX(p + 2);
                                a.fromBufferAttribute(t, m), s.fromBufferAttribute(t, g), o.fromBufferAttribute(t, v), c.subVectors(o, s), d.subVectors(a, s), c.cross(d), l.fromBufferAttribute(i, m), h.fromBufferAttribute(i, g), u.fromBufferAttribute(i, v), l.add(c), h.add(c), u.add(c), i.setXYZ(m, l.x, l.y, l.z), i.setXYZ(g, h.x, h.y, h.z), i.setXYZ(v, u.x, u.y, u.z)
                            } else
                                for (let _ = 0, x = t.count; _ < x; _ += 3) a.fromBufferAttribute(t, _ + 0), s.fromBufferAttribute(t, _ + 1), o.fromBufferAttribute(t, _ + 2), c.subVectors(o, s), d.subVectors(a, s), c.cross(d), i.setXYZ(_ + 0, c.x, c.y, c.z), i.setXYZ(_ + 1, c.x, c.y, c.z), i.setXYZ(_ + 2, c.x, c.y, c.z);
                        this.normalizeNormals(), i.needsUpdate = !0
                    }
                }
                merge() {
                    return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this
                }
                normalizeNormals() {
                    let e = this.attributes.normal;
                    for (let t = 0, i = e.count; t < i; t++) tq.fromBufferAttribute(e, t), tq.normalize(), e.setXYZ(t, tq.x, tq.y, tq.z)
                }
                toNonIndexed() {
                    function e(e, t) {
                        let i = e.array,
                            n = e.itemSize,
                            r = e.normalized,
                            a = new i.constructor(t.length * n),
                            s = 0,
                            o = 0;
                        for (let l = 0, h = t.length; l < h; l++) {
                            s = e.isInterleavedBufferAttribute ? t[l] * e.data.stride + e.offset : t[l] * n;
                            for (let u = 0; u < n; u++) a[o++] = i[s++]
                        }
                        return new tz(a, n, r)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                    let t = new tX,
                        i = this.index.array,
                        n = this.attributes;
                    for (let r in n) {
                        let a = n[r],
                            s = e(a, i);
                        t.setAttribute(r, s)
                    }
                    let o = this.morphAttributes;
                    for (let l in o) {
                        let h = [],
                            u = o[l];
                        for (let c = 0, d = u.length; c < d; c++) {
                            let p = u[c],
                                f = e(p, i);
                            h.push(f)
                        }
                        t.morphAttributes[l] = h
                    }
                    t.morphTargetsRelative = this.morphTargetsRelative;
                    let m = this.groups;
                    for (let g = 0, v = m.length; g < v; g++) {
                        let _ = m[g];
                        t.addGroup(_.start, _.count, _.materialIndex)
                    }
                    return t
                }
                toJSON() {
                    let e = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                        let t = this.parameters;
                        for (let i in t) void 0 !== t[i] && (e[i] = t[i]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    let n = this.index;
                    null !== n && (e.data.index = {
                        type: n.array.constructor.name,
                        array: Array.prototype.slice.call(n.array)
                    });
                    let r = this.attributes;
                    for (let a in r) {
                        let s = r[a];
                        e.data.attributes[a] = s.toJSON(e.data)
                    }
                    let o = {},
                        l = !1;
                    for (let h in this.morphAttributes) {
                        let u = this.morphAttributes[h],
                            c = [];
                        for (let d = 0, p = u.length; d < p; d++) {
                            let f = u[d];
                            c.push(f.toJSON(e.data))
                        }
                        c.length > 0 && (o[h] = c, l = !0)
                    }
                    l && (e.data.morphAttributes = o, e.data.morphTargetsRelative = this.morphTargetsRelative);
                    let m = this.groups;
                    m.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(m)));
                    let g = this.boundingSphere;
                    return null !== g && (e.data.boundingSphere = {
                        center: g.center.toArray(),
                        radius: g.radius
                    }), e
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    let t = {};
                    this.name = e.name;
                    let i = e.index;
                    null !== i && this.setIndex(i.clone(t));
                    let n = e.attributes;
                    for (let r in n) {
                        let a = n[r];
                        this.setAttribute(r, a.clone(t))
                    }
                    let s = e.morphAttributes;
                    for (let o in s) {
                        let l = [],
                            h = s[o];
                        for (let u = 0, c = h.length; u < c; u++) l.push(h[u].clone(t));
                        this.morphAttributes[o] = l
                    }
                    this.morphTargetsRelative = e.morphTargetsRelative;
                    let d = e.groups;
                    for (let p = 0, f = d.length; p < f; p++) {
                        let m = d[p];
                        this.addGroup(m.start, m.count, m.materialIndex)
                    }
                    let g = e.boundingBox;
                    null !== g && (this.boundingBox = g.clone());
                    let v = e.boundingSphere;
                    return null !== v && (this.boundingSphere = v.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            let tJ = new e4,
                tY = new e2,
                tZ = new eY,
                tK = new eC,
                tQ = new eC,
                t$ = new eC,
                t0 = new eC,
                t1 = new eC,
                t3 = new en,
                t2 = new en,
                t4 = new en,
                t5 = new eC,
                t6 = new eC;
            class t7 extends tx {
                constructor(e = new tX, t = new tD) {
                    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
                }
                updateMorphTargets() {
                    let e = this.geometry,
                        t = e.morphAttributes,
                        i = Object.keys(t);
                    if (i.length > 0) {
                        let n = t[i[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let r = 0, a = n.length; r < a; r++) {
                                let s = n[r].name || String(r);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = r
                            }
                        }
                    }
                }
                getVertexPosition(e, t) {
                    let i = this.geometry,
                        n = i.attributes.position,
                        r = i.morphAttributes.position,
                        a = i.morphTargetsRelative;
                    t.fromBufferAttribute(n, e);
                    let s = this.morphTargetInfluences;
                    if (r && s) {
                        t1.set(0, 0, 0);
                        for (let o = 0, l = r.length; o < l; o++) {
                            let h = s[o],
                                u = r[o];
                            0 !== h && (t0.fromBufferAttribute(u, e), a ? t1.addScaledVector(t0, h) : t1.addScaledVector(t0.sub(t), h))
                        }
                        t.add(t1)
                    }
                    return this.isSkinnedMesh && this.boneTransform(e, t), t
                }
                raycast(e, t) {
                    let i;
                    let n = this.geometry,
                        r = this.material,
                        a = this.matrixWorld;
                    if (void 0 === r || (null === n.boundingSphere && n.computeBoundingSphere(), tZ.copy(n.boundingSphere), tZ.applyMatrix4(a), !1 === e.ray.intersectsSphere(tZ)) || (tJ.copy(a).invert(), tY.copy(e.ray).applyMatrix4(tJ), null !== n.boundingBox && !1 === tY.intersectsBox(n.boundingBox))) return;
                    let s = n.index,
                        o = n.attributes.position,
                        l = n.attributes.uv,
                        h = n.attributes.uv2,
                        u = n.groups,
                        c = n.drawRange;
                    if (null !== s) {
                        if (Array.isArray(r))
                            for (let d = 0, p = u.length; d < p; d++) {
                                let f = u[d],
                                    m = r[f.materialIndex],
                                    g = Math.max(f.start, c.start),
                                    v = Math.min(s.count, Math.min(f.start + f.count, c.start + c.count));
                                for (let _ = g; _ < v; _ += 3) {
                                    let x = s.getX(_),
                                        y = s.getX(_ + 1),
                                        M = s.getX(_ + 2);
                                    (i = t8(this, m, e, tY, l, h, x, y, M)) && (i.faceIndex = Math.floor(_ / 3), i.face.materialIndex = f.materialIndex, t.push(i))
                                }
                            } else {
                                let b = Math.max(0, c.start),
                                    S = Math.min(s.count, c.start + c.count);
                                for (let w = b; w < S; w += 3) {
                                    let T = s.getX(w),
                                        E = s.getX(w + 1),
                                        A = s.getX(w + 2);
                                    (i = t8(this, r, e, tY, l, h, T, E, A)) && (i.faceIndex = Math.floor(w / 3), t.push(i))
                                }
                            }
                    } else if (void 0 !== o) {
                        if (Array.isArray(r))
                            for (let C = 0, L = u.length; C < L; C++) {
                                let P = u[C],
                                    R = r[P.materialIndex],
                                    I = Math.max(P.start, c.start),
                                    D = Math.min(o.count, Math.min(P.start + P.count, c.start + c.count));
                                for (let N = I; N < D; N += 3) {
                                    let O = N,
                                        z = N + 1,
                                        U = N + 2;
                                    (i = t8(this, R, e, tY, l, h, O, z, U)) && (i.faceIndex = Math.floor(N / 3), i.face.materialIndex = P.materialIndex, t.push(i))
                                }
                            } else {
                                let B = Math.max(0, c.start),
                                    F = Math.min(o.count, c.start + c.count);
                                for (let k = B; k < F; k += 3) {
                                    let V = k,
                                        G = k + 1,
                                        W = k + 2;
                                    (i = t8(this, r, e, tY, l, h, V, G, W)) && (i.faceIndex = Math.floor(k / 3), t.push(i))
                                }
                            }
                    }
                }
            }

            function t8(e, t, i, n, r, a, s, h, u) {
                e.getVertexPosition(s, tK), e.getVertexPosition(h, tQ), e.getVertexPosition(u, t$);
                let c = function(e, t, i, n, r, a, s, h) {
                    if (null === (t.side === l ? n.intersectTriangle(s, a, r, !0, h) : n.intersectTriangle(r, a, s, t.side === o, h))) return null;
                    t6.copy(h), t6.applyMatrix4(e.matrixWorld);
                    let u = i.ray.origin.distanceTo(t6);
                    return u < i.near || u > i.far ? null : {
                        distance: u,
                        point: t6.clone(),
                        object: e
                    }
                }(e, t, i, n, tK, tQ, t$, t5);
                if (c) {
                    r && (t3.fromBufferAttribute(r, s), t2.fromBufferAttribute(r, h), t4.fromBufferAttribute(r, u), c.uv = tP.getUV(t5, tK, tQ, t$, t3, t2, t4, new en)), a && (t3.fromBufferAttribute(a, s), t2.fromBufferAttribute(a, h), t4.fromBufferAttribute(a, u), c.uv2 = tP.getUV(t5, tK, tQ, t$, t3, t2, t4, new en));
                    let d = {
                        a: s,
                        b: h,
                        c: u,
                        normal: new eC,
                        materialIndex: 0
                    };
                    tP.getNormal(tK, tQ, t$, d.normal), c.face = d
                }
                return c
            }
            class t9 extends tX {
                constructor(e = 1, t = 1, i = 1, n = 1, r = 1, a = 1) {
                    super(), this.type = "BoxGeometry", this.parameters = {
                        width: e,
                        height: t,
                        depth: i,
                        widthSegments: n,
                        heightSegments: r,
                        depthSegments: a
                    };
                    let s = this;
                    n = Math.floor(n), r = Math.floor(r), a = Math.floor(a);
                    let o = [],
                        l = [],
                        h = [],
                        u = [],
                        c = 0,
                        d = 0;

                    function p(e, t, i, n, r, a, p, f, m, g, v) {
                        let _ = a / m,
                            x = p / g,
                            y = a / 2,
                            M = p / 2,
                            b = f / 2,
                            S = m + 1,
                            w = g + 1,
                            T = 0,
                            E = 0,
                            A = new eC;
                        for (let C = 0; C < w; C++) {
                            let L = C * x - M;
                            for (let P = 0; P < S; P++) {
                                let R = P * _ - y;
                                A[e] = R * n, A[t] = L * r, A[i] = b, l.push(A.x, A.y, A.z), A[e] = 0, A[t] = 0, A[i] = f > 0 ? 1 : -1, h.push(A.x, A.y, A.z), u.push(P / m), u.push(1 - C / g), T += 1
                            }
                        }
                        for (let I = 0; I < g; I++)
                            for (let D = 0; D < m; D++) {
                                let N = c + D + S * I,
                                    O = c + D + S * (I + 1),
                                    z = c + (D + 1) + S * (I + 1),
                                    U = c + (D + 1) + S * I;
                                o.push(N, O, U), o.push(O, z, U), E += 6
                            }
                        s.addGroup(d, E, v), d += E, c += T
                    }
                    p("z", "y", "x", -1, -1, i, t, e, a, r, 0), p("z", "y", "x", 1, -1, i, t, -e, a, r, 1), p("x", "z", "y", 1, 1, e, i, t, n, a, 2), p("x", "z", "y", 1, -1, e, i, -t, n, a, 3), p("x", "y", "z", 1, -1, e, t, i, n, r, 4), p("x", "y", "z", -1, -1, e, t, -i, n, r, 5), this.setIndex(o), this.setAttribute("position", new tF(l, 3)), this.setAttribute("normal", new tF(h, 3)), this.setAttribute("uv", new tF(u, 2))
                }
                static fromJSON(e) {
                    return new t9(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
                }
            }

            function ie(e) {
                let t = {};
                for (let i in e)
                    for (let n in t[i] = {}, e[i]) {
                        let r = e[i][n];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[i][n] = r.clone() : Array.isArray(r) ? t[i][n] = r.slice() : t[i][n] = r
                    }
                return t
            }

            function it(e) {
                let t = {};
                for (let i = 0; i < e.length; i++) {
                    let n = ie(e[i]);
                    for (let r in n) t[r] = n[r]
                }
                return t
            }

            function ii(e) {
                return null === e.getRenderTarget() && e.outputEncoding === z ? F : k
            }
            let ir = {
                clone: ie,
                merge: it
            };
            class ia extends tI {
                constructor(e) {
                    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                        derivatives: !1,
                        fragDepth: !1,
                        drawBuffers: !1,
                        shaderTextureLOD: !1
                    }, this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv2: [0, 0]
                    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ie(e.uniforms), this.uniformsGroups = function(e) {
                        let t = [];
                        for (let i = 0; i < e.length; i++) t.push(e[i].clone());
                        return t
                    }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    for (let i in t.glslVersion = this.glslVersion, t.uniforms = {}, this.uniforms) {
                        let n = this.uniforms[i],
                            r = n.value;
                        r && r.isTexture ? t.uniforms[i] = {
                            type: "t",
                            value: r.toJSON(e).uuid
                        } : r && r.isColor ? t.uniforms[i] = {
                            type: "c",
                            value: r.getHex()
                        } : r && r.isVector2 ? t.uniforms[i] = {
                            type: "v2",
                            value: r.toArray()
                        } : r && r.isVector3 ? t.uniforms[i] = {
                            type: "v3",
                            value: r.toArray()
                        } : r && r.isVector4 ? t.uniforms[i] = {
                            type: "v4",
                            value: r.toArray()
                        } : r && r.isMatrix3 ? t.uniforms[i] = {
                            type: "m3",
                            value: r.toArray()
                        } : r && r.isMatrix4 ? t.uniforms[i] = {
                            type: "m4",
                            value: r.toArray()
                        } : t.uniforms[i] = {
                            value: r
                        }
                    }
                    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
                    let a = {};
                    for (let s in this.extensions) !0 === this.extensions[s] && (a[s] = !0);
                    return Object.keys(a).length > 0 && (t.extensions = a), t
                }
            }
            class is extends tx {
                constructor() {
                    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new e4, this.projectionMatrix = new e4, this.projectionMatrixInverse = new e4
                }
                copy(e, t) {
                    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
                }
                getWorldDirection(e) {
                    this.updateWorldMatrix(!0, !1);
                    let t = this.matrixWorld.elements;
                    return e.set(-t[8], -t[9], -t[10]).normalize()
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                updateWorldMatrix(e, t) {
                    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            class io extends is {
                constructor(e = 50, t = 1, i = .1, n = 2e3) {
                    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                }
                setFocalLength(e) {
                    let t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * q * Math.atan(t), this.updateProjectionMatrix()
                }
                getFocalLength() {
                    let e = Math.tan(.5 * j * this.fov);
                    return .5 * this.getFilmHeight() / e
                }
                getEffectiveFOV() {
                    return 2 * q * Math.atan(Math.tan(.5 * j * this.fov) / this.zoom)
                }
                getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                }
                getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                }
                setViewOffset(e, t, i, n, r, a) {
                    this.aspect = e / t, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    let e = this.near,
                        t = e * Math.tan(.5 * j * this.fov) / this.zoom,
                        i = 2 * t,
                        n = this.aspect * i,
                        r = -.5 * n,
                        a = this.view;
                    if (null !== this.view && this.view.enabled) {
                        let s = a.fullWidth,
                            o = a.fullHeight;
                        r += a.offsetX * n / s, t -= a.offsetY * i / o, n *= a.width / s, i *= a.height / o
                    }
                    let l = this.filmOffset;
                    0 !== l && (r += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
                }
            }
            class il extends tx {
                constructor(e, t, i) {
                    super(), this.type = "CubeCamera", this.renderTarget = i;
                    let n = new io(-90, 1, e, t);
                    n.layers = this.layers, n.up.set(0, 1, 0), n.lookAt(1, 0, 0), this.add(n);
                    let r = new io(-90, 1, e, t);
                    r.layers = this.layers, r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), this.add(r);
                    let a = new io(-90, 1, e, t);
                    a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(0, 1, 0), this.add(a);
                    let s = new io(-90, 1, e, t);
                    s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(0, -1, 0), this.add(s);
                    let o = new io(-90, 1, e, t);
                    o.layers = this.layers, o.up.set(0, 1, 0), o.lookAt(0, 0, 1), this.add(o);
                    let l = new io(-90, 1, e, t);
                    l.layers = this.layers, l.up.set(0, 1, 0), l.lookAt(0, 0, -1), this.add(l)
                }
                update(e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    let i = this.renderTarget,
                        [n, r, a, s, o, l] = this.children,
                        h = e.getRenderTarget(),
                        u = e.toneMapping,
                        c = e.xr.enabled;
                    e.toneMapping = m, e.xr.enabled = !1;
                    let d = i.texture.generateMipmaps;
                    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0), e.render(t, n), e.setRenderTarget(i, 1), e.render(t, r), e.setRenderTarget(i, 2), e.render(t, a), e.setRenderTarget(i, 3), e.render(t, s), e.setRenderTarget(i, 4), e.render(t, o), i.texture.generateMipmaps = d, e.setRenderTarget(i, 5), e.render(t, l), e.setRenderTarget(h), e.toneMapping = u, e.xr.enabled = c, i.texture.needsPMREMUpdate = !0
                }
            }
            class ih extends eS {
                constructor(e, t, i, n, r, a, s, o, l, h) {
                    super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : 301, i, n, r, a, s, o, l, h), this.isCubeTexture = !0, this.flipY = !1
                }
                get images() {
                    return this.image
                }
                set images(e) {
                    this.image = e
                }
            }
            class iu extends eT {
                constructor(e = 1, t = {}) {
                    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
                    let i = {
                        width: e,
                        height: e,
                        depth: 1
                    };
                    this.texture = new ih([i, i, i, i, i, i], t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : E
                }
                fromEquirectangularTexture(e, t) {
                    this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                    let i = {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                        },
                        n = new t9(5, 5, 5),
                        r = new ia({
                            name: "CubemapFromEquirect",
                            uniforms: ie(i.uniforms),
                            vertexShader: i.vertexShader,
                            fragmentShader: i.fragmentShader,
                            side: l,
                            blending: 0
                        });
                    r.uniforms.tEquirect.value = t;
                    let a = new t7(n, r),
                        s = t.minFilter;
                    t.minFilter === C && (t.minFilter = E);
                    let o = new il(1, 10, this);
                    return o.update(e, a), t.minFilter = s, a.geometry.dispose(), a.material.dispose(), this
                }
                clear(e, t, i, n) {
                    let r = e.getRenderTarget();
                    for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, i, n);
                    e.setRenderTarget(r)
                }
            }
            let ic = new eC,
                id = new eC,
                ip = new er;
            class im {
                constructor(e = new eC(1, 0, 0), t = 0) {
                    this.isPlane = !0, this.normal = e, this.constant = t
                }
                set(e, t) {
                    return this.normal.copy(e), this.constant = t, this
                }
                setComponents(e, t, i, n) {
                    return this.normal.set(e, t, i), this.constant = n, this
                }
                setFromNormalAndCoplanarPoint(e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                }
                setFromCoplanarPoints(e, t, i) {
                    let n = ic.subVectors(i, t).cross(id.subVectors(e, t)).normalize();
                    return this.setFromNormalAndCoplanarPoint(n, e), this
                }
                copy(e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                }
                normalize() {
                    let e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                }
                negate() {
                    return this.constant *= -1, this.normal.negate(), this
                }
                distanceToPoint(e) {
                    return this.normal.dot(e) + this.constant
                }
                distanceToSphere(e) {
                    return this.distanceToPoint(e.center) - e.radius
                }
                projectPoint(e, t) {
                    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
                }
                intersectLine(e, t) {
                    let i = e.delta(ic),
                        n = this.normal.dot(i);
                    if (0 === n) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                    let r = -(e.start.dot(this.normal) + this.constant) / n;
                    return r < 0 || r > 1 ? null : t.copy(i).multiplyScalar(r).add(e.start)
                }
                intersectsLine(e) {
                    let t = this.distanceToPoint(e.start),
                        i = this.distanceToPoint(e.end);
                    return t < 0 && i > 0 || i < 0 && t > 0
                }
                intersectsBox(e) {
                    return e.intersectsPlane(this)
                }
                intersectsSphere(e) {
                    return e.intersectsPlane(this)
                }
                coplanarPoint(e) {
                    return e.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(e, t) {
                    let i = t || ip.getNormalMatrix(e),
                        n = this.coplanarPoint(ic).applyMatrix4(e),
                        r = this.normal.applyMatrix3(i).normalize();
                    return this.constant = -n.dot(r), this
                }
                translate(e) {
                    return this.constant -= e.dot(this.normal), this
                }
                equals(e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            let ig = new eY,
                iv = new eC;
            class i_ {
                constructor(e = new im, t = new im, i = new im, n = new im, r = new im, a = new im) {
                    this.planes = [e, t, i, n, r, a]
                }
                set(e, t, i, n, r, a) {
                    let s = this.planes;
                    return s[0].copy(e), s[1].copy(t), s[2].copy(i), s[3].copy(n), s[4].copy(r), s[5].copy(a), this
                }
                copy(e) {
                    let t = this.planes;
                    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
                    return this
                }
                setFromProjectionMatrix(e) {
                    let t = this.planes,
                        i = e.elements,
                        n = i[0],
                        r = i[1],
                        a = i[2],
                        s = i[3],
                        o = i[4],
                        l = i[5],
                        h = i[6],
                        u = i[7],
                        c = i[8],
                        d = i[9],
                        p = i[10],
                        f = i[11],
                        m = i[12],
                        g = i[13],
                        v = i[14],
                        _ = i[15];
                    return t[0].setComponents(s - n, u - o, f - c, _ - m).normalize(), t[1].setComponents(s + n, u + o, f + c, _ + m).normalize(), t[2].setComponents(s + r, u + l, f + d, _ + g).normalize(), t[3].setComponents(s - r, u - l, f - d, _ - g).normalize(), t[4].setComponents(s - a, u - h, f - p, _ - v).normalize(), t[5].setComponents(s + a, u + h, f + p, _ + v).normalize(), this
                }
                intersectsObject(e) {
                    let t = e.geometry;
                    return null === t.boundingSphere && t.computeBoundingSphere(), ig.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(ig)
                }
                intersectsSprite(e) {
                    return ig.center.set(0, 0, 0), ig.radius = .7071067811865476, ig.applyMatrix4(e.matrixWorld), this.intersectsSphere(ig)
                }
                intersectsSphere(e) {
                    let t = this.planes,
                        i = e.center,
                        n = -e.radius;
                    for (let r = 0; r < 6; r++) {
                        let a = t[r].distanceToPoint(i);
                        if (a < n) return !1
                    }
                    return !0
                }
                intersectsBox(e) {
                    let t = this.planes;
                    for (let i = 0; i < 6; i++) {
                        let n = t[i];
                        if (iv.x = n.normal.x > 0 ? e.max.x : e.min.x, iv.y = n.normal.y > 0 ? e.max.y : e.min.y, iv.z = n.normal.z > 0 ? e.max.z : e.min.z, 0 > n.distanceToPoint(iv)) return !1
                    }
                    return !0
                }
                containsPoint(e) {
                    let t = this.planes;
                    for (let i = 0; i < 6; i++)
                        if (0 > t[i].distanceToPoint(e)) return !1;
                    return !0
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }

            function ix() {
                let e = null,
                    t = !1,
                    i = null,
                    n = null;

                function r(t, a) {
                    i(t, a), n = e.requestAnimationFrame(r)
                }
                return {
                    start: function() {
                        !0 !== t && null !== i && (n = e.requestAnimationFrame(r), t = !0)
                    },
                    stop: function() {
                        e.cancelAnimationFrame(n), t = !1
                    },
                    setAnimationLoop: function(e) {
                        i = e
                    },
                    setContext: function(t) {
                        e = t
                    }
                }
            }

            function iy(e, t) {
                let i = t.isWebGL2,
                    n = new WeakMap;
                return {
                    get: function(e) {
                        return e.isInterleavedBufferAttribute && (e = e.data), n.get(e)
                    },
                    remove: function(t) {
                        t.isInterleavedBufferAttribute && (t = t.data);
                        let i = n.get(t);
                        i && (e.deleteBuffer(i.buffer), n.delete(t))
                    },
                    update: function(t, r) {
                        if (t.isGLBufferAttribute) {
                            let a = n.get(t);
                            (!a || a.version < t.version) && n.set(t, {
                                buffer: t.buffer,
                                type: t.type,
                                bytesPerElement: t.elementSize,
                                version: t.version
                            });
                            return
                        }
                        t.isInterleavedBufferAttribute && (t = t.data);
                        let s = n.get(t);
                        void 0 === s ? n.set(t, function(t, n) {
                            let r;
                            let a = t.array,
                                s = t.usage,
                                o = e.createBuffer();
                            if (e.bindBuffer(n, o), e.bufferData(n, a, s), t.onUploadCallback(), a instanceof Float32Array) r = 5126;
                            else if (a instanceof Uint16Array) {
                                if (t.isFloat16BufferAttribute) {
                                    if (i) r = 5131;
                                    else throw Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.")
                                } else r = 5123
                            } else if (a instanceof Int16Array) r = 5122;
                            else if (a instanceof Uint32Array) r = 5125;
                            else if (a instanceof Int32Array) r = 5124;
                            else if (a instanceof Int8Array) r = 5120;
                            else if (a instanceof Uint8Array) r = 5121;
                            else if (a instanceof Uint8ClampedArray) r = 5121;
                            else throw Error("THREE.WebGLAttributes: Unsupported buffer data format: " + a);
                            return {
                                buffer: o,
                                type: r,
                                bytesPerElement: a.BYTES_PER_ELEMENT,
                                version: t.version
                            }
                        }(t, r)) : s.version < t.version && (! function(t, n, r) {
                            let a = n.array,
                                s = n.updateRange;
                            e.bindBuffer(r, t), -1 === s.count ? e.bufferSubData(r, 0, a) : (i ? e.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a, s.offset, s.count) : e.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a.subarray(s.offset, s.offset + s.count)), s.count = -1), n.onUploadCallback()
                        }(s.buffer, t, r), s.version = t.version)
                    }
                }
            }
            class iM extends tX {
                constructor(e = 1, t = 1, i = 1, n = 1) {
                    super(), this.type = "PlaneGeometry", this.parameters = {
                        width: e,
                        height: t,
                        widthSegments: i,
                        heightSegments: n
                    };
                    let r = e / 2,
                        a = t / 2,
                        s = Math.floor(i),
                        o = Math.floor(n),
                        l = s + 1,
                        h = o + 1,
                        u = e / s,
                        c = t / o,
                        d = [],
                        p = [],
                        f = [],
                        m = [];
                    for (let g = 0; g < h; g++) {
                        let v = g * c - a;
                        for (let _ = 0; _ < l; _++) {
                            let x = _ * u - r;
                            p.push(x, -v, 0), f.push(0, 0, 1), m.push(_ / s), m.push(1 - g / o)
                        }
                    }
                    for (let y = 0; y < o; y++)
                        for (let M = 0; M < s; M++) {
                            let b = M + l * y,
                                S = M + l * (y + 1),
                                w = M + 1 + l * (y + 1),
                                T = M + 1 + l * y;
                            d.push(b, S, T), d.push(S, w, T)
                        }
                    this.setIndex(d), this.setAttribute("position", new tF(p, 3)), this.setAttribute("normal", new tF(f, 3)), this.setAttribute("uv", new tF(m, 2))
                }
                static fromJSON(e) {
                    return new iM(e.width, e.height, e.widthSegments, e.heightSegments)
                }
            }
            let ib = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif",
                    alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif",
                    iridescence_fragment: "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			 return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float R21 = R12;\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = dFdx( surf_pos.xyz );\n		vec3 vSigmaY = dFdy( surf_pos.xyz );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_v0 0.339\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_v1 0.276\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_v4 0.046\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_v5 0.016\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_v6 0.0038\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",
                    lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                    lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	#ifdef USE_IRIDESCENCE\n		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n	#else\n		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometry.viewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",
                    morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif",
                    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                    normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
                    normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
                    normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif",
                    iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif",
                    output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n	return packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif",
                    shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",
                    shadowmap_vertex: "#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmission_fragment: "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif",
                    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
                    backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
                    backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
                    cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",
                    meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}"
                },
                iS = {
                    common: {
                        diffuse: {
                            value: new e_(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new er
                        },
                        uv2Transform: {
                            value: new er
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new en(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new e_(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotLightMap: {
                            value: []
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotLightMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new e_(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new er
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new e_(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new en(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new er
                        }
                    }
                },
                iw = {
                    basic: {
                        uniforms: it([iS.common, iS.specularmap, iS.envmap, iS.aomap, iS.lightmap, iS.fog]),
                        vertexShader: ib.meshbasic_vert,
                        fragmentShader: ib.meshbasic_frag
                    },
                    lambert: {
                        uniforms: it([iS.common, iS.specularmap, iS.envmap, iS.aomap, iS.lightmap, iS.emissivemap, iS.bumpmap, iS.normalmap, iS.displacementmap, iS.fog, iS.lights, {
                            emissive: {
                                value: new e_(0)
                            }
                        }]),
                        vertexShader: ib.meshlambert_vert,
                        fragmentShader: ib.meshlambert_frag
                    },
                    phong: {
                        uniforms: it([iS.common, iS.specularmap, iS.envmap, iS.aomap, iS.lightmap, iS.emissivemap, iS.bumpmap, iS.normalmap, iS.displacementmap, iS.fog, iS.lights, {
                            emissive: {
                                value: new e_(0)
                            },
                            specular: {
                                value: new e_(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: ib.meshphong_vert,
                        fragmentShader: ib.meshphong_frag
                    },
                    standard: {
                        uniforms: it([iS.common, iS.envmap, iS.aomap, iS.lightmap, iS.emissivemap, iS.bumpmap, iS.normalmap, iS.displacementmap, iS.roughnessmap, iS.metalnessmap, iS.fog, iS.lights, {
                            emissive: {
                                value: new e_(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ib.meshphysical_vert,
                        fragmentShader: ib.meshphysical_frag
                    },
                    toon: {
                        uniforms: it([iS.common, iS.aomap, iS.lightmap, iS.emissivemap, iS.bumpmap, iS.normalmap, iS.displacementmap, iS.gradientmap, iS.fog, iS.lights, {
                            emissive: {
                                value: new e_(0)
                            }
                        }]),
                        vertexShader: ib.meshtoon_vert,
                        fragmentShader: ib.meshtoon_frag
                    },
                    matcap: {
                        uniforms: it([iS.common, iS.bumpmap, iS.normalmap, iS.displacementmap, iS.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: ib.meshmatcap_vert,
                        fragmentShader: ib.meshmatcap_frag
                    },
                    points: {
                        uniforms: it([iS.points, iS.fog]),
                        vertexShader: ib.points_vert,
                        fragmentShader: ib.points_frag
                    },
                    dashed: {
                        uniforms: it([iS.common, iS.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: ib.linedashed_vert,
                        fragmentShader: ib.linedashed_frag
                    },
                    depth: {
                        uniforms: it([iS.common, iS.displacementmap]),
                        vertexShader: ib.depth_vert,
                        fragmentShader: ib.depth_frag
                    },
                    normal: {
                        uniforms: it([iS.common, iS.bumpmap, iS.normalmap, iS.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ib.meshnormal_vert,
                        fragmentShader: ib.meshnormal_frag
                    },
                    sprite: {
                        uniforms: it([iS.sprite, iS.fog]),
                        vertexShader: ib.sprite_vert,
                        fragmentShader: ib.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new er
                            },
                            t2D: {
                                value: null
                            },
                            backgroundIntensity: {
                                value: 1
                            }
                        },
                        vertexShader: ib.background_vert,
                        fragmentShader: ib.background_frag
                    },
                    backgroundCube: {
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            backgroundBlurriness: {
                                value: 0
                            },
                            backgroundIntensity: {
                                value: 1
                            }
                        },
                        vertexShader: ib.backgroundCube_vert,
                        fragmentShader: ib.backgroundCube_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: ib.cube_vert,
                        fragmentShader: ib.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: ib.equirect_vert,
                        fragmentShader: ib.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: it([iS.common, iS.displacementmap, {
                            referencePosition: {
                                value: new eC
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: ib.distanceRGBA_vert,
                        fragmentShader: ib.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: it([iS.lights, iS.fog, {
                            color: {
                                value: new e_(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ib.shadow_vert,
                        fragmentShader: ib.shadow_frag
                    }
                };
            iw.physical = {
                uniforms: it([iw.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatNormalScale: {
                        value: new en(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    iridescence: {
                        value: 0
                    },
                    iridescenceMap: {
                        value: null
                    },
                    iridescenceIOR: {
                        value: 1.3
                    },
                    iridescenceThicknessMinimum: {
                        value: 100
                    },
                    iridescenceThicknessMaximum: {
                        value: 400
                    },
                    iridescenceThicknessMap: {
                        value: null
                    },
                    sheen: {
                        value: 0
                    },
                    sheenColor: {
                        value: new e_(0)
                    },
                    sheenColorMap: {
                        value: null
                    },
                    sheenRoughness: {
                        value: 1
                    },
                    sheenRoughnessMap: {
                        value: null
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    },
                    transmissionSamplerSize: {
                        value: new en
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    thickness: {
                        value: 0
                    },
                    thicknessMap: {
                        value: null
                    },
                    attenuationDistance: {
                        value: 0
                    },
                    attenuationColor: {
                        value: new e_(0)
                    },
                    specularIntensity: {
                        value: 1
                    },
                    specularIntensityMap: {
                        value: null
                    },
                    specularColor: {
                        value: new e_(1, 1, 1)
                    },
                    specularColorMap: {
                        value: null
                    }
                }]),
                vertexShader: ib.meshphysical_vert,
                fragmentShader: ib.meshphysical_frag
            };
            let iT = {
                r: 0,
                b: 0,
                g: 0
            };

            function iE(e, t, i, n, r, a, s) {
                let h, u;
                let c = new e_(0),
                    d = !0 === a ? 0 : 1,
                    p = null,
                    f = 0,
                    m = null;

                function g(t, i) {
                    t.getRGB(iT, ii(e)), n.buffers.color.setClear(iT.r, iT.g, iT.b, i, s)
                }
                return {
                    getClearColor: function() {
                        return c
                    },
                    setClearColor: function(e, t = 1) {
                        c.set(e), g(c, d = t)
                    },
                    getClearAlpha: function() {
                        return d
                    },
                    setClearAlpha: function(e) {
                        g(c, d = e)
                    },
                    render: function(n, a) {
                        let s = !1,
                            v = !0 === a.isScene ? a.background : null;
                        if (v && v.isTexture) {
                            let _ = a.backgroundBlurriness > 0;
                            v = (_ ? i : t).get(v)
                        }
                        let x = e.xr,
                            y = x.getSession && x.getSession();
                        y && "additive" === y.environmentBlendMode && (v = null), null === v ? g(c, d) : v && v.isColor && (g(v, 1), s = !0), (e.autoClear || s) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), v && (v.isCubeTexture || 306 === v.mapping) ? (void 0 === u && ((u = new t7(new t9(1, 1, 1), new ia({
                            name: "BackgroundCubeMaterial",
                            uniforms: ie(iw.backgroundCube.uniforms),
                            vertexShader: iw.backgroundCube.vertexShader,
                            fragmentShader: iw.backgroundCube.fragmentShader,
                            side: l,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function(e, t, i) {
                            this.matrixWorld.copyPosition(i.matrixWorld)
                        }, Object.defineProperty(u.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), r.update(u)), u.material.uniforms.envMap.value = v, u.material.uniforms.flipEnvMap.value = v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = a.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = a.backgroundIntensity, u.material.toneMapped = v.encoding !== z, (p !== v || f !== v.version || m !== e.toneMapping) && (u.material.needsUpdate = !0, p = v, f = v.version, m = e.toneMapping), u.layers.enableAll(), n.unshift(u, u.geometry, u.material, 0, 0, null)) : v && v.isTexture && (void 0 === h && ((h = new t7(new iM(2, 2), new ia({
                            name: "BackgroundMaterial",
                            uniforms: ie(iw.background.uniforms),
                            vertexShader: iw.background.vertexShader,
                            fragmentShader: iw.background.fragmentShader,
                            side: o,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), Object.defineProperty(h.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), r.update(h)), h.material.uniforms.t2D.value = v, h.material.uniforms.backgroundIntensity.value = a.backgroundIntensity, h.material.toneMapped = v.encoding !== z, !0 === v.matrixAutoUpdate && v.updateMatrix(), h.material.uniforms.uvTransform.value.copy(v.matrix), (p !== v || f !== v.version || m !== e.toneMapping) && (h.material.needsUpdate = !0, p = v, f = v.version, m = e.toneMapping), h.layers.enableAll(), n.unshift(h, h.geometry, h.material, 0, 0, null))
                    }
                }
            }

            function iA(e, t, i, n) {
                let r = e.getParameter(34921),
                    a = n.isWebGL2 ? null : t.get("OES_vertex_array_object"),
                    s = n.isWebGL2 || null !== a,
                    o = {},
                    l = p(null),
                    h = l,
                    u = !1;

                function c(t) {
                    return n.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t)
                }

                function d(t) {
                    return n.isWebGL2 ? e.deleteVertexArray(t) : a.deleteVertexArrayOES(t)
                }

                function p(e) {
                    let t = [],
                        i = [],
                        n = [];
                    for (let a = 0; a < r; a++) t[a] = 0, i[a] = 0, n[a] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: t,
                        enabledAttributes: i,
                        attributeDivisors: n,
                        object: e,
                        attributes: {},
                        index: null
                    }
                }

                function f() {
                    let e = h.newAttributes;
                    for (let t = 0, i = e.length; t < i; t++) e[t] = 0
                }

                function m(e) {
                    g(e, 0)
                }

                function g(i, r) {
                    let a = h.newAttributes,
                        s = h.enabledAttributes,
                        o = h.attributeDivisors;
                    if (a[i] = 1, 0 === s[i] && (e.enableVertexAttribArray(i), s[i] = 1), o[i] !== r) {
                        let l = n.isWebGL2 ? e : t.get("ANGLE_instanced_arrays");
                        l[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), o[i] = r
                    }
                }

                function v() {
                    let t = h.newAttributes,
                        i = h.enabledAttributes;
                    for (let n = 0, r = i.length; n < r; n++) i[n] !== t[n] && (e.disableVertexAttribArray(n), i[n] = 0)
                }

                function _(t, i, r, a, s, o) {
                    !0 === n.isWebGL2 && (5124 === r || 5125 === r) ? e.vertexAttribIPointer(t, i, r, s, o) : e.vertexAttribPointer(t, i, r, a, s, o)
                }

                function x() {
                    y(), u = !0, h !== l && c((h = l).object)
                }

                function y() {
                    l.geometry = null, l.program = null, l.wireframe = !1
                }
                return {
                    setup: function(r, l, d, x, y) {
                        let M = !1;
                        if (s) {
                            let b = function(t, i, r) {
                                let s = !0 === r.wireframe,
                                    l = o[t.id];
                                void 0 === l && (l = {}, o[t.id] = l);
                                let h = l[i.id];
                                void 0 === h && (h = {}, l[i.id] = h);
                                let u = h[s];
                                return void 0 === u && (u = p(n.isWebGL2 ? e.createVertexArray() : a.createVertexArrayOES()), h[s] = u), u
                            }(x, d, l);
                            h !== b && c((h = b).object), (M = function(e, t, i, n) {
                                let r = h.attributes,
                                    a = t.attributes,
                                    s = 0,
                                    o = i.getAttributes();
                                for (let l in o) {
                                    let u = o[l];
                                    if (u.location >= 0) {
                                        let c = r[l],
                                            d = a[l];
                                        if (void 0 === d && ("instanceMatrix" === l && e.instanceMatrix && (d = e.instanceMatrix), "instanceColor" === l && e.instanceColor && (d = e.instanceColor)), void 0 === c || c.attribute !== d || d && c.data !== d.data) return !0;
                                        s++
                                    }
                                }
                                return h.attributesNum !== s || h.index !== n
                            }(r, x, d, y)) && function(e, t, i, n) {
                                let r = {},
                                    a = t.attributes,
                                    s = 0,
                                    o = i.getAttributes();
                                for (let l in o) {
                                    let u = o[l];
                                    if (u.location >= 0) {
                                        let c = a[l];
                                        void 0 === c && ("instanceMatrix" === l && e.instanceMatrix && (c = e.instanceMatrix), "instanceColor" === l && e.instanceColor && (c = e.instanceColor));
                                        let d = {};
                                        d.attribute = c, c && c.data && (d.data = c.data), r[l] = d, s++
                                    }
                                }
                                h.attributes = r, h.attributesNum = s, h.index = n
                            }(r, x, d, y)
                        } else {
                            let S = !0 === l.wireframe;
                            (h.geometry !== x.id || h.program !== d.id || h.wireframe !== S) && (h.geometry = x.id, h.program = d.id, h.wireframe = S, M = !0)
                        }
                        null !== y && i.update(y, 34963), (M || u) && (u = !1, function(r, a, s, o) {
                            if (!1 === n.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
                            f();
                            let l = o.attributes,
                                h = s.getAttributes(),
                                u = a.defaultAttributeValues;
                            for (let c in h) {
                                let d = h[c];
                                if (d.location >= 0) {
                                    let p = l[c];
                                    if (void 0 === p && ("instanceMatrix" === c && r.instanceMatrix && (p = r.instanceMatrix), "instanceColor" === c && r.instanceColor && (p = r.instanceColor)), void 0 !== p) {
                                        let x = p.normalized,
                                            y = p.itemSize,
                                            M = i.get(p);
                                        if (void 0 === M) continue;
                                        let b = M.buffer,
                                            S = M.type,
                                            w = M.bytesPerElement;
                                        if (p.isInterleavedBufferAttribute) {
                                            let T = p.data,
                                                E = T.stride,
                                                A = p.offset;
                                            if (T.isInstancedInterleavedBuffer) {
                                                for (let C = 0; C < d.locationSize; C++) g(d.location + C, T.meshPerAttribute);
                                                !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = T.meshPerAttribute * T.count)
                                            } else
                                                for (let L = 0; L < d.locationSize; L++) m(d.location + L);
                                            e.bindBuffer(34962, b);
                                            for (let P = 0; P < d.locationSize; P++) _(d.location + P, y / d.locationSize, S, x, E * w, (A + y / d.locationSize * P) * w)
                                        } else {
                                            if (p.isInstancedBufferAttribute) {
                                                for (let R = 0; R < d.locationSize; R++) g(d.location + R, p.meshPerAttribute);
                                                !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = p.meshPerAttribute * p.count)
                                            } else
                                                for (let I = 0; I < d.locationSize; I++) m(d.location + I);
                                            e.bindBuffer(34962, b);
                                            for (let D = 0; D < d.locationSize; D++) _(d.location + D, y / d.locationSize, S, x, y * w, y / d.locationSize * D * w)
                                        }
                                    } else if (void 0 !== u) {
                                        let N = u[c];
                                        if (void 0 !== N) switch (N.length) {
                                            case 2:
                                                e.vertexAttrib2fv(d.location, N);
                                                break;
                                            case 3:
                                                e.vertexAttrib3fv(d.location, N);
                                                break;
                                            case 4:
                                                e.vertexAttrib4fv(d.location, N);
                                                break;
                                            default:
                                                e.vertexAttrib1fv(d.location, N)
                                        }
                                    }
                                }
                            }
                            v()
                        }(r, l, d, x), null !== y && e.bindBuffer(34963, i.get(y).buffer))
                    },
                    reset: x,
                    resetDefaultState: y,
                    dispose: function() {
                        for (let e in x(), o) {
                            let t = o[e];
                            for (let i in t) {
                                let n = t[i];
                                for (let r in n) d(n[r].object), delete n[r];
                                delete t[i]
                            }
                            delete o[e]
                        }
                    },
                    releaseStatesOfGeometry: function(e) {
                        if (void 0 === o[e.id]) return;
                        let t = o[e.id];
                        for (let i in t) {
                            let n = t[i];
                            for (let r in n) d(n[r].object), delete n[r];
                            delete t[i]
                        }
                        delete o[e.id]
                    },
                    releaseStatesOfProgram: function(e) {
                        for (let t in o) {
                            let i = o[t];
                            if (void 0 === i[e.id]) continue;
                            let n = i[e.id];
                            for (let r in n) d(n[r].object), delete n[r];
                            delete i[e.id]
                        }
                    },
                    initAttributes: f,
                    enableAttribute: m,
                    disableUnusedAttributes: v
                }
            }

            function iC(e, t, i, n) {
                let r;
                let a = n.isWebGL2;
                this.setMode = function(e) {
                    r = e
                }, this.render = function(t, n) {
                    e.drawArrays(r, t, n), i.update(n, r, 1)
                }, this.renderInstances = function(n, s, o) {
                    let l, h;
                    if (0 !== o) {
                        if (a) l = e, h = "drawArraysInstanced";
                        else if (l = t.get("ANGLE_instanced_arrays"), h = "drawArraysInstancedANGLE", null === l) {
                            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            return
                        }
                        l[h](r, n, s, o), i.update(s, r, o)
                    }
                }
            }

            function iL(e, t, i) {
                let n;

                function r(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                let a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext,
                    s = void 0 !== i.precision ? i.precision : "highp",
                    o = r(s);
                o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."), s = o);
                let l = a || t.has("WEBGL_draw_buffers"),
                    h = !0 === i.logarithmicDepthBuffer,
                    u = e.getParameter(34930),
                    c = e.getParameter(35660),
                    d = e.getParameter(3379),
                    p = e.getParameter(34076),
                    f = e.getParameter(34921),
                    m = e.getParameter(36347),
                    g = e.getParameter(36348),
                    v = e.getParameter(36349),
                    _ = c > 0,
                    x = a || t.has("OES_texture_float"),
                    y = a ? e.getParameter(36183) : 0;
                return {
                    isWebGL2: a,
                    drawBuffers: l,
                    getMaxAnisotropy: function() {
                        if (void 0 !== n) return n;
                        if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                            let i = t.get("EXT_texture_filter_anisotropic");
                            n = e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else n = 0;
                        return n
                    },
                    getMaxPrecision: r,
                    precision: s,
                    logarithmicDepthBuffer: h,
                    maxTextures: u,
                    maxVertexTextures: c,
                    maxTextureSize: d,
                    maxCubemapSize: p,
                    maxAttributes: f,
                    maxVertexUniforms: m,
                    maxVaryings: g,
                    maxFragmentUniforms: v,
                    vertexTextures: _,
                    floatFragmentTextures: x,
                    floatVertexTextures: _ && x,
                    maxSamples: y
                }
            }

            function iP(e) {
                let t = this,
                    i = null,
                    n = 0,
                    r = !1,
                    a = !1,
                    s = new im,
                    o = new er,
                    l = {
                        value: null,
                        needsUpdate: !1
                    };

                function h() {
                    l.value !== i && (l.value = i, l.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0
                }

                function u(e, i, n, r) {
                    let a = null !== e ? e.length : 0,
                        h = null;
                    if (0 !== a) {
                        if (h = l.value, !0 !== r || null === h) {
                            let u = n + 4 * a,
                                c = i.matrixWorldInverse;
                            o.getNormalMatrix(c), (null === h || h.length < u) && (h = new Float32Array(u));
                            for (let d = 0, p = n; d !== a; ++d, p += 4) s.copy(e[d]).applyMatrix4(c, o), s.normal.toArray(h, p), h[p + 3] = s.constant
                        }
                        l.value = h, l.needsUpdate = !0
                    }
                    return t.numPlanes = a, t.numIntersection = 0, h
                }
                this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t, a) {
                    let s = 0 !== e.length || t || 0 !== n || r;
                    return r = t, i = u(e, a, 0), n = e.length, s
                }, this.beginShadows = function() {
                    a = !0, u(null)
                }, this.endShadows = function() {
                    a = !1, h()
                }, this.setState = function(t, s, o) {
                    let c = t.clippingPlanes,
                        d = t.clipIntersection,
                        p = t.clipShadows,
                        f = e.get(t);
                    if (r && null !== c && 0 !== c.length && (!a || p)) {
                        let m = a ? 0 : n,
                            g = 4 * m,
                            v = f.clippingState || null;
                        l.value = v, v = u(c, s, g, o);
                        for (let _ = 0; _ !== g; ++_) v[_] = i[_];
                        f.clippingState = v, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += m
                    } else a ? u(null) : h()
                }
            }

            function iR(e) {
                let t = new WeakMap;

                function i(e, t) {
                    return 303 === t ? e.mapping = 301 : 304 === t && (e.mapping = 302), e
                }

                function n(e) {
                    let i = e.target;
                    i.removeEventListener("dispose", n);
                    let r = t.get(i);
                    void 0 !== r && (t.delete(i), r.dispose())
                }
                return {
                    get: function(r) {
                        if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                            let a = r.mapping;
                            if (303 === a || 304 === a) {
                                if (t.has(r)) {
                                    let s = t.get(r).texture;
                                    return i(s, r.mapping)
                                } {
                                    let o = r.image;
                                    if (!o || !(o.height > 0)) return null; {
                                        let l = new iu(o.height / 2);
                                        return l.fromEquirectangularTexture(e, r), t.set(r, l), r.addEventListener("dispose", n), i(l.texture, r.mapping)
                                    }
                                }
                            }
                        }
                        return r
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }
            class iI extends is {
                constructor(e = -1, t = 1, i = 1, n = -1, r = .1, a = 2e3) {
                    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = r, this.far = a, this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
                }
                setViewOffset(e, t, i, n, r, a) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    let e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        i = (this.right + this.left) / 2,
                        n = (this.top + this.bottom) / 2,
                        r = i - e,
                        a = i + e,
                        s = n + t,
                        o = n - t;
                    if (null !== this.view && this.view.enabled) {
                        let l = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        r += l * this.view.offsetX, a = r + l * this.view.width, s -= h * this.view.offsetY, o = s - h * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
                }
            }
            let iD = [.125, .215, .35, .446, .526, .582],
                iN = new iI,
                iO = new e_,
                iz = null,
                iU = (1 + Math.sqrt(5)) / 2,
                iB = 1 / iU,
                iF = [new eC(1, 1, 1), new eC(-1, 1, 1), new eC(1, 1, -1), new eC(-1, 1, -1), new eC(0, iU, iB), new eC(0, iU, -iB), new eC(iB, 0, iU), new eC(-iB, 0, iU), new eC(iU, iB, 0), new eC(-iU, iB, 0)];
            class ik {
                constructor(e) {
                    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
                }
                fromScene(e, t = 0, i = .1, n = 100) {
                    iz = this._renderer.getRenderTarget(), this._setSize(256);
                    let r = this._allocateTargets();
                    return r.depthBuffer = !0, this._sceneToCubeUV(e, i, n, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r
                }
                fromEquirectangular(e, t = null) {
                    return this._fromTexture(e, t)
                }
                fromCubemap(e, t = null) {
                    return this._fromTexture(e, t)
                }
                compileCubemapShader() {
                    null === this._cubemapMaterial && (this._cubemapMaterial = iH(), this._compileMaterial(this._cubemapMaterial))
                }
                compileEquirectangularShader() {
                    null === this._equirectMaterial && (this._equirectMaterial = iW(), this._compileMaterial(this._equirectMaterial))
                }
                dispose() {
                    this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
                }
                _setSize(e) {
                    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
                }
                _dispose() {
                    null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                    for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
                }
                _cleanup(e) {
                    this._renderer.setRenderTarget(iz), e.scissorTest = !1, iG(e, 0, 0, e.width, e.height)
                }
                _fromTexture(e, t) {
                    301 === e.mapping || 302 === e.mapping ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), iz = this._renderer.getRenderTarget();
                    let i = t || this._allocateTargets();
                    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
                }
                _allocateTargets() {
                    let e = 3 * Math.max(this._cubeSize, 112),
                        t = 4 * this._cubeSize,
                        i = {
                            magFilter: E,
                            minFilter: E,
                            generateMipmaps: !1,
                            type: 1016,
                            format: P,
                            encoding: O,
                            depthBuffer: !1
                        },
                        n = iV(e, t, i);
                    if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e) {
                        null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = iV(e, t, i);
                        let {
                            _lodMax: r
                        } = this;
                        ({
                            sizeLods: this._sizeLods,
                            lodPlanes: this._lodPlanes,
                            sigmas: this._sigmas
                        } = function(e) {
                            let t = [],
                                i = [],
                                n = [],
                                r = e,
                                a = e - 4 + 1 + iD.length;
                            for (let s = 0; s < a; s++) {
                                let o = Math.pow(2, r);
                                i.push(o);
                                let l = 1 / o;
                                s > e - 4 ? l = iD[s - e + 4 - 1] : 0 === s && (l = 0), n.push(l);
                                let h = 1 / (o - 2),
                                    u = -h,
                                    c = 1 + h,
                                    d = [u, u, c, u, c, c, u, u, c, c, u, c],
                                    p = new Float32Array(108),
                                    f = new Float32Array(72),
                                    m = new Float32Array(36);
                                for (let g = 0; g < 6; g++) {
                                    let v = g % 3 * 2 / 3 - 1,
                                        _ = g > 2 ? 0 : -1,
                                        x = [v, _, 0, v + 2 / 3, _, 0, v + 2 / 3, _ + 1, 0, v, _, 0, v + 2 / 3, _ + 1, 0, v, _ + 1, 0];
                                    p.set(x, 18 * g), f.set(d, 12 * g);
                                    let y = [g, g, g, g, g, g];
                                    m.set(y, 6 * g)
                                }
                                let M = new tX;
                                M.setAttribute("position", new tz(p, 3)), M.setAttribute("uv", new tz(f, 2)), M.setAttribute("faceIndex", new tz(m, 1)), t.push(M), r > 4 && r--
                            }
                            return {
                                lodPlanes: t,
                                sizeLods: i,
                                sigmas: n
                            }
                        }(r)), this._blurMaterial = function(e, t, i) {
                            let n = new Float32Array(20),
                                r = new eC(0, 1, 0),
                                a = new ia({
                                    name: "SphericalGaussianBlur",
                                    defines: {
                                        n: 20,
                                        CUBEUV_TEXEL_WIDTH: 1 / t,
                                        CUBEUV_TEXEL_HEIGHT: 1 / i,
                                        CUBEUV_MAX_MIP: `${e}.0`
                                    },
                                    uniforms: {
                                        envMap: {
                                            value: null
                                        },
                                        samples: {
                                            value: 1
                                        },
                                        weights: {
                                            value: n
                                        },
                                        latitudinal: {
                                            value: !1
                                        },
                                        dTheta: {
                                            value: 0
                                        },
                                        mipInt: {
                                            value: 0
                                        },
                                        poleAxis: {
                                            value: r
                                        }
                                    },
                                    vertexShader: ij(),
                                    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
                                    blending: 0,
                                    depthTest: !1,
                                    depthWrite: !1
                                });
                            return a
                        }(r, e, t)
                    }
                    return n
                }
                _compileMaterial(e) {
                    let t = new t7(this._lodPlanes[0], e);
                    this._renderer.compile(t, iN)
                }
                _sceneToCubeUV(e, t, i, n) {
                    let r = new io(90, 1, t, i),
                        a = [1, -1, 1, 1, 1, 1],
                        s = [1, 1, 1, -1, -1, -1],
                        o = this._renderer,
                        h = o.autoClear,
                        u = o.toneMapping;
                    o.getClearColor(iO), o.toneMapping = m, o.autoClear = !1;
                    let c = new tD({
                            name: "PMREM.Background",
                            side: l,
                            depthWrite: !1,
                            depthTest: !1
                        }),
                        d = new t7(new t9, c),
                        p = !1,
                        f = e.background;
                    f ? f.isColor && (c.color.copy(f), e.background = null, p = !0) : (c.color.copy(iO), p = !0);
                    for (let g = 0; g < 6; g++) {
                        let v = g % 3;
                        0 === v ? (r.up.set(0, a[g], 0), r.lookAt(s[g], 0, 0)) : 1 === v ? (r.up.set(0, 0, a[g]), r.lookAt(0, s[g], 0)) : (r.up.set(0, a[g], 0), r.lookAt(0, 0, s[g]));
                        let _ = this._cubeSize;
                        iG(n, v * _, g > 2 ? _ : 0, _, _), o.setRenderTarget(n), p && o.render(d, r), o.render(e, r)
                    }
                    d.geometry.dispose(), d.material.dispose(), o.toneMapping = u, o.autoClear = h, e.background = f
                }
                _textureToCubeUV(e, t) {
                    let i = this._renderer,
                        n = 301 === e.mapping || 302 === e.mapping;
                    n ? (null === this._cubemapMaterial && (this._cubemapMaterial = iH()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = iW());
                    let r = n ? this._cubemapMaterial : this._equirectMaterial,
                        a = new t7(this._lodPlanes[0], r),
                        s = r.uniforms;
                    s.envMap.value = e;
                    let o = this._cubeSize;
                    iG(t, 0, 0, 3 * o, 2 * o), i.setRenderTarget(t), i.render(a, iN)
                }
                _applyPMREM(e) {
                    let t = this._renderer,
                        i = t.autoClear;
                    t.autoClear = !1;
                    for (let n = 1; n < this._lodPlanes.length; n++) {
                        let r = Math.sqrt(this._sigmas[n] * this._sigmas[n] - this._sigmas[n - 1] * this._sigmas[n - 1]),
                            a = iF[(n - 1) % iF.length];
                        this._blur(e, n - 1, n, r, a)
                    }
                    t.autoClear = i
                }
                _blur(e, t, i, n, r) {
                    let a = this._pingPongRenderTarget;
                    this._halfBlur(e, a, t, i, n, "latitudinal", r), this._halfBlur(a, e, i, i, n, "longitudinal", r)
                }
                _halfBlur(e, t, i, n, r, a, s) {
                    let o = this._renderer,
                        l = this._blurMaterial;
                    "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
                    let h = new t7(this._lodPlanes[n], l),
                        u = l.uniforms,
                        c = this._sizeLods[i] - 1,
                        d = isFinite(r) ? Math.PI / (2 * c) : 2 * Math.PI / 39,
                        p = r / d,
                        f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                    f > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                    let m = [],
                        g = 0;
                    for (let v = 0; v < 20; ++v) {
                        let _ = v / p,
                            x = Math.exp(-_ * _ / 2);
                        m.push(x), 0 === v ? g += x : v < f && (g += 2 * x)
                    }
                    for (let y = 0; y < m.length; y++) m[y] = m[y] / g;
                    u.envMap.value = e.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === a, s && (u.poleAxis.value = s);
                    let {
                        _lodMax: M
                    } = this;
                    u.dTheta.value = d, u.mipInt.value = M - i;
                    let b = this._sizeLods[n],
                        S = 4 * (this._cubeSize - b);
                    iG(t, 3 * b * (n > M - 4 ? n - M + 4 : 0), S, 3 * b, 2 * b), o.setRenderTarget(t), o.render(h, iN)
                }
            }

            function iV(e, t, i) {
                let n = new eT(e, t, i);
                return n.texture.mapping = 306, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n
            }

            function iG(e, t, i, n, r) {
                e.viewport.set(t, i, n, r), e.scissor.set(t, i, n, r)
            }

            function iW() {
                return new ia({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        }
                    },
                    vertexShader: ij(),
                    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function iH() {
                return new ia({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        }
                    },
                    vertexShader: ij(),
                    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function ij() {
                return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
            }

            function iq(e) {
                let t = new WeakMap,
                    i = null;

                function n(e) {
                    let i = e.target;
                    i.removeEventListener("dispose", n);
                    let r = t.get(i);
                    void 0 !== r && (t.delete(i), r.dispose())
                }
                return {
                    get: function(r) {
                        if (r && r.isTexture) {
                            let a = r.mapping,
                                s = 303 === a || 304 === a,
                                o = 301 === a || 302 === a;
                            if (s || o) {
                                if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                                    r.needsPMREMUpdate = !1;
                                    let l = t.get(r);
                                    return null === i && (i = new ik(e)), l = s ? i.fromEquirectangular(r, l) : i.fromCubemap(r, l), t.set(r, l), l.texture
                                }
                                if (t.has(r)) return t.get(r).texture; {
                                    let h = r.image;
                                    if (!(s && h && h.height > 0 || o && h && function(e) {
                                            let t = 0;
                                            for (let i = 0; i < 6; i++) void 0 !== e[i] && t++;
                                            return 6 === t
                                        }(h))) return null; {
                                        null === i && (i = new ik(e));
                                        let u = s ? i.fromEquirectangular(r) : i.fromCubemap(r);
                                        return t.set(r, u), r.addEventListener("dispose", n), u.texture
                                    }
                                }
                            }
                        }
                        return r
                    },
                    dispose: function() {
                        t = new WeakMap, null !== i && (i.dispose(), i = null)
                    }
                }
            }

            function iX(e) {
                let t = {};

                function i(i) {
                    let n;
                    if (void 0 !== t[i]) return t[i];
                    switch (i) {
                        case "WEBGL_depth_texture":
                            n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            n = e.getExtension(i)
                    }
                    return t[i] = n, n
                }
                return {
                    has: function(e) {
                        return null !== i(e)
                    },
                    init: function(e) {
                        e.isWebGL2 ? i("EXT_color_buffer_float") : (i("WEBGL_depth_texture"), i("OES_texture_float"), i("OES_texture_half_float"), i("OES_texture_half_float_linear"), i("OES_standard_derivatives"), i("OES_element_index_uint"), i("OES_vertex_array_object"), i("ANGLE_instanced_arrays")), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float"), i("WEBGL_multisampled_render_to_texture")
                    },
                    get: function(e) {
                        let t = i(e);
                        return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t
                    }
                }
            }

            function iJ(e, t, i, n) {
                let r = {},
                    a = new WeakMap;

                function s(e) {
                    let o = e.target;
                    for (let l in null !== o.index && t.remove(o.index), o.attributes) t.remove(o.attributes[l]);
                    o.removeEventListener("dispose", s), delete r[o.id];
                    let h = a.get(o);
                    h && (t.remove(h), a.delete(o)), n.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, i.memory.geometries--
                }

                function o(e) {
                    let i = [],
                        n = e.index,
                        r = e.attributes.position,
                        s = 0;
                    if (null !== n) {
                        let o = n.array;
                        s = n.version;
                        for (let l = 0, h = o.length; l < h; l += 3) {
                            let u = o[l + 0],
                                c = o[l + 1],
                                d = o[l + 2];
                            i.push(u, c, c, d, d, u)
                        }
                    } else {
                        let p = r.array;
                        s = r.version;
                        for (let f = 0, m = p.length / 3 - 1; f < m; f += 3) {
                            let g = f + 0,
                                v = f + 1,
                                _ = f + 2;
                            i.push(g, v, v, _, _, g)
                        }
                    }
                    let x = new(es(i) ? tB : tU)(i, 1);
                    x.version = s;
                    let y = a.get(e);
                    y && t.remove(y), a.set(e, x)
                }
                return {
                    get: function(e, t) {
                        return !0 === r[t.id] || (t.addEventListener("dispose", s), r[t.id] = !0, i.memory.geometries++), t
                    },
                    update: function(e) {
                        let i = e.attributes;
                        for (let n in i) t.update(i[n], 34962);
                        let r = e.morphAttributes;
                        for (let a in r) {
                            let s = r[a];
                            for (let o = 0, l = s.length; o < l; o++) t.update(s[o], 34962)
                        }
                    },
                    getWireframeAttribute: function(e) {
                        let t = a.get(e);
                        if (t) {
                            let i = e.index;
                            null !== i && t.version < i.version && o(e)
                        } else o(e);
                        return a.get(e)
                    }
                }
            }

            function iY(e, t, i, n) {
                let r, a, s;
                let o = n.isWebGL2;
                this.setMode = function(e) {
                    r = e
                }, this.setIndex = function(e) {
                    a = e.type, s = e.bytesPerElement
                }, this.render = function(t, n) {
                    e.drawElements(r, n, a, t * s), i.update(n, r, 1)
                }, this.renderInstances = function(n, l, h) {
                    let u, c;
                    if (0 !== h) {
                        if (o) u = e, c = "drawElementsInstanced";
                        else if (u = t.get("ANGLE_instanced_arrays"), c = "drawElementsInstancedANGLE", null === u) {
                            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            return
                        }
                        u[c](r, l, a, n * s, h), i.update(l, r, h)
                    }
                }
            }

            function iZ(e) {
                let t = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: t,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
                    },
                    update: function(e, i, n) {
                        switch (t.calls++, i) {
                            case 4:
                                t.triangles += n * (e / 3);
                                break;
                            case 1:
                                t.lines += n * (e / 2);
                                break;
                            case 3:
                                t.lines += n * (e - 1);
                                break;
                            case 2:
                                t.lines += n * e;
                                break;
                            case 0:
                                t.points += n * e;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                        }
                    }
                }
            }

            function iK(e, t) {
                return e[0] - t[0]
            }

            function iQ(e, t) {
                return Math.abs(t[1]) - Math.abs(e[1])
            }

            function i$(e, t, i) {
                let n = {},
                    r = new Float32Array(8),
                    a = new WeakMap,
                    s = new ew,
                    o = [];
                for (let l = 0; l < 8; l++) o[l] = [l, 0];
                return {
                    update: function(l, h, u, c) {
                        let d = l.morphTargetInfluences;
                        if (!0 === t.isWebGL2) {
                            let p = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color,
                                f = void 0 !== p ? p.length : 0,
                                m = a.get(h);
                            if (void 0 === m || m.count !== f) {
                                void 0 !== m && m.texture.dispose();
                                let g = void 0 !== h.morphAttributes.position,
                                    v = void 0 !== h.morphAttributes.normal,
                                    _ = void 0 !== h.morphAttributes.color,
                                    x = h.morphAttributes.position || [],
                                    y = h.morphAttributes.normal || [],
                                    M = h.morphAttributes.color || [],
                                    b = 0;
                                !0 === g && (b = 1), !0 === v && (b = 2), !0 === _ && (b = 3);
                                let S = h.attributes.position.count * b,
                                    w = 1;
                                S > t.maxTextureSize && (w = Math.ceil(S / t.maxTextureSize), S = t.maxTextureSize);
                                let T = new Float32Array(S * w * 4 * f),
                                    E = new eE(T, S, w, f);
                                E.type = L, E.needsUpdate = !0;
                                let A = 4 * b;
                                for (let C = 0; C < f; C++) {
                                    let P = x[C],
                                        R = y[C],
                                        I = M[C],
                                        D = S * w * 4 * C;
                                    for (let N = 0; N < P.count; N++) {
                                        let O = N * A;
                                        !0 === g && (s.fromBufferAttribute(P, N), T[D + O + 0] = s.x, T[D + O + 1] = s.y, T[D + O + 2] = s.z, T[D + O + 3] = 0), !0 === v && (s.fromBufferAttribute(R, N), T[D + O + 4] = s.x, T[D + O + 5] = s.y, T[D + O + 6] = s.z, T[D + O + 7] = 0), !0 === _ && (s.fromBufferAttribute(I, N), T[D + O + 8] = s.x, T[D + O + 9] = s.y, T[D + O + 10] = s.z, T[D + O + 11] = 4 === I.itemSize ? s.w : 1)
                                    }
                                }
                                m = {
                                    count: f,
                                    texture: E,
                                    size: new en(S, w)
                                }, a.set(h, m), h.addEventListener("dispose", function e() {
                                    E.dispose(), a.delete(h), h.removeEventListener("dispose", e)
                                })
                            }
                            let z = 0;
                            for (let U = 0; U < d.length; U++) z += d[U];
                            let B = h.morphTargetsRelative ? 1 : 1 - z;
                            c.getUniforms().setValue(e, "morphTargetBaseInfluence", B), c.getUniforms().setValue(e, "morphTargetInfluences", d), c.getUniforms().setValue(e, "morphTargetsTexture", m.texture, i), c.getUniforms().setValue(e, "morphTargetsTextureSize", m.size)
                        } else {
                            let F = void 0 === d ? 0 : d.length,
                                k = n[h.id];
                            if (void 0 === k || k.length !== F) {
                                k = [];
                                for (let V = 0; V < F; V++) k[V] = [V, 0];
                                n[h.id] = k
                            }
                            for (let G = 0; G < F; G++) {
                                let W = k[G];
                                W[0] = G, W[1] = d[G]
                            }
                            k.sort(iQ);
                            for (let H = 0; H < 8; H++) H < F && k[H][1] ? (o[H][0] = k[H][0], o[H][1] = k[H][1]) : (o[H][0] = Number.MAX_SAFE_INTEGER, o[H][1] = 0);
                            o.sort(iK);
                            let j = h.morphAttributes.position,
                                q = h.morphAttributes.normal,
                                X = 0;
                            for (let J = 0; J < 8; J++) {
                                let Y = o[J],
                                    Z = Y[0],
                                    K = Y[1];
                                Z !== Number.MAX_SAFE_INTEGER && K ? (j && h.getAttribute("morphTarget" + J) !== j[Z] && h.setAttribute("morphTarget" + J, j[Z]), q && h.getAttribute("morphNormal" + J) !== q[Z] && h.setAttribute("morphNormal" + J, q[Z]), r[J] = K, X += K) : (j && !0 === h.hasAttribute("morphTarget" + J) && h.deleteAttribute("morphTarget" + J), q && !0 === h.hasAttribute("morphNormal" + J) && h.deleteAttribute("morphNormal" + J), r[J] = 0)
                            }
                            let Q = h.morphTargetsRelative ? 1 : 1 - X;
                            c.getUniforms().setValue(e, "morphTargetBaseInfluence", Q), c.getUniforms().setValue(e, "morphTargetInfluences", r)
                        }
                    }
                }
            }

            function i0(e, t, i, n) {
                let r = new WeakMap;

                function a(e) {
                    let t = e.target;
                    t.removeEventListener("dispose", a), i.remove(t.instanceMatrix), null !== t.instanceColor && i.remove(t.instanceColor)
                }
                return {
                    update: function(e) {
                        let s = n.render.frame,
                            o = e.geometry,
                            l = t.get(e, o);
                        return r.get(l) !== s && (t.update(l), r.set(l, s)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", a) && e.addEventListener("dispose", a), i.update(e.instanceMatrix, 34962), null !== e.instanceColor && i.update(e.instanceColor, 34962)), l
                    },
                    dispose: function() {
                        r = new WeakMap
                    }
                }
            }
            let i1 = new eS,
                i3 = new eE,
                i2 = new class extends eS {
                    constructor(e = null, t = 1, i = 1, n = 1) {
                        super(null), this.isData3DTexture = !0, this.image = {
                            data: e,
                            width: t,
                            height: i,
                            depth: n
                        }, this.magFilter = S, this.minFilter = S, this.wrapR = M, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                    }
                },
                i4 = new ih,
                i5 = [],
                i6 = [],
                i7 = new Float32Array(16),
                i8 = new Float32Array(9),
                i9 = new Float32Array(4);

            function ne(e, t, i) {
                let n = e[0];
                if (n <= 0 || n > 0) return e;
                let r = t * i,
                    a = i5[r];
                if (void 0 === a && (a = new Float32Array(r), i5[r] = a), 0 !== t) {
                    n.toArray(a, 0);
                    for (let s = 1, o = 0; s !== t; ++s) o += i, e[s].toArray(a, o)
                }
                return a
            }

            function nt(e, t) {
                if (e.length !== t.length) return !1;
                for (let i = 0, n = e.length; i < n; i++)
                    if (e[i] !== t[i]) return !1;
                return !0
            }

            function ni(e, t) {
                for (let i = 0, n = t.length; i < n; i++) e[i] = t[i]
            }

            function nn(e, t) {
                let i = i6[t];
                void 0 === i && (i = new Int32Array(t), i6[t] = i);
                for (let n = 0; n !== t; ++n) i[n] = e.allocateTextureUnit();
                return i
            }

            function nr(e, t) {
                let i = this.cache;
                i[0] !== t && (e.uniform1f(this.addr, t), i[0] = t)
            }

            function na(e, t) {
                let i = this.cache;
                if (void 0 !== t.x)(i[0] !== t.x || i[1] !== t.y) && (e.uniform2f(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y);
                else {
                    if (nt(i, t)) return;
                    e.uniform2fv(this.addr, t), ni(i, t)
                }
            }

            function ns(e, t) {
                let i = this.cache;
                if (void 0 !== t.x)(i[0] !== t.x || i[1] !== t.y || i[2] !== t.z) && (e.uniform3f(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z);
                else if (void 0 !== t.r)(i[0] !== t.r || i[1] !== t.g || i[2] !== t.b) && (e.uniform3f(this.addr, t.r, t.g, t.b), i[0] = t.r, i[1] = t.g, i[2] = t.b);
                else {
                    if (nt(i, t)) return;
                    e.uniform3fv(this.addr, t), ni(i, t)
                }
            }

            function no(e, t) {
                let i = this.cache;
                if (void 0 !== t.x)(i[0] !== t.x || i[1] !== t.y || i[2] !== t.z || i[3] !== t.w) && (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w);
                else {
                    if (nt(i, t)) return;
                    e.uniform4fv(this.addr, t), ni(i, t)
                }
            }

            function nl(e, t) {
                let i = this.cache,
                    n = t.elements;
                if (void 0 === n) {
                    if (nt(i, t)) return;
                    e.uniformMatrix2fv(this.addr, !1, t), ni(i, t)
                } else {
                    if (nt(i, n)) return;
                    i9.set(n), e.uniformMatrix2fv(this.addr, !1, i9), ni(i, n)
                }
            }

            function nh(e, t) {
                let i = this.cache,
                    n = t.elements;
                if (void 0 === n) {
                    if (nt(i, t)) return;
                    e.uniformMatrix3fv(this.addr, !1, t), ni(i, t)
                } else {
                    if (nt(i, n)) return;
                    i8.set(n), e.uniformMatrix3fv(this.addr, !1, i8), ni(i, n)
                }
            }

            function nu(e, t) {
                let i = this.cache,
                    n = t.elements;
                if (void 0 === n) {
                    if (nt(i, t)) return;
                    e.uniformMatrix4fv(this.addr, !1, t), ni(i, t)
                } else {
                    if (nt(i, n)) return;
                    i7.set(n), e.uniformMatrix4fv(this.addr, !1, i7), ni(i, n)
                }
            }

            function nc(e, t) {
                let i = this.cache;
                i[0] !== t && (e.uniform1i(this.addr, t), i[0] = t)
            }

            function nd(e, t) {
                let i = this.cache;
                if (void 0 !== t.x)(i[0] !== t.x || i[1] !== t.y) && (e.uniform2i(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y);
                else {
                    if (nt(i, t)) return;
                    e.uniform2iv(this.addr, t), ni(i, t)
                }
            }

            function np(e, t) {
                let i = this.cache;
                if (void 0 !== t.x)(i[0] !== t.x || i[1] !== t.y || i[2] !== t.z) && (e.uniform3i(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z);
                else {
                    if (nt(i, t)) return;
                    e.uniform3iv(this.addr, t), ni(i, t)
                }
            }

            function nf(e, t) {
                let i = this.cache;
                if (void 0 !== t.x)(i[0] !== t.x || i[1] !== t.y || i[2] !== t.z || i[3] !== t.w) && (e.uniform4i(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w);
                else {
                    if (nt(i, t)) return;
                    e.uniform4iv(this.addr, t), ni(i, t)
                }
            }

            function nm(e, t) {
                let i = this.cache;
                i[0] !== t && (e.uniform1ui(this.addr, t), i[0] = t)
            }

            function ng(e, t) {
                let i = this.cache;
                if (void 0 !== t.x)(i[0] !== t.x || i[1] !== t.y) && (e.uniform2ui(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y);
                else {
                    if (nt(i, t)) return;
                    e.uniform2uiv(this.addr, t), ni(i, t)
                }
            }

            function nv(e, t) {
                let i = this.cache;
                if (void 0 !== t.x)(i[0] !== t.x || i[1] !== t.y || i[2] !== t.z) && (e.uniform3ui(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z);
                else {
                    if (nt(i, t)) return;
                    e.uniform3uiv(this.addr, t), ni(i, t)
                }
            }

            function n_(e, t) {
                let i = this.cache;
                if (void 0 !== t.x)(i[0] !== t.x || i[1] !== t.y || i[2] !== t.z || i[3] !== t.w) && (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w);
                else {
                    if (nt(i, t)) return;
                    e.uniform4uiv(this.addr, t), ni(i, t)
                }
            }

            function nx(e, t, i) {
                let n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture2D(t || i1, r)
            }

            function ny(e, t, i) {
                let n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(t || i2, r)
            }

            function nM(e, t, i) {
                let n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTextureCube(t || i4, r)
            }

            function nb(e, t, i) {
                let n = this.cache,
                    r = i.allocateTextureUnit();
                n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(t || i3, r)
            }

            function nS(e, t) {
                e.uniform1fv(this.addr, t)
            }

            function nw(e, t) {
                let i = ne(t, this.size, 2);
                e.uniform2fv(this.addr, i)
            }

            function nT(e, t) {
                let i = ne(t, this.size, 3);
                e.uniform3fv(this.addr, i)
            }

            function nE(e, t) {
                let i = ne(t, this.size, 4);
                e.uniform4fv(this.addr, i)
            }

            function nA(e, t) {
                let i = ne(t, this.size, 4);
                e.uniformMatrix2fv(this.addr, !1, i)
            }

            function nC(e, t) {
                let i = ne(t, this.size, 9);
                e.uniformMatrix3fv(this.addr, !1, i)
            }

            function nL(e, t) {
                let i = ne(t, this.size, 16);
                e.uniformMatrix4fv(this.addr, !1, i)
            }

            function nP(e, t) {
                e.uniform1iv(this.addr, t)
            }

            function nR(e, t) {
                e.uniform2iv(this.addr, t)
            }

            function nI(e, t) {
                e.uniform3iv(this.addr, t)
            }

            function nD(e, t) {
                e.uniform4iv(this.addr, t)
            }

            function nN(e, t) {
                e.uniform1uiv(this.addr, t)
            }

            function nO(e, t) {
                e.uniform2uiv(this.addr, t)
            }

            function nz(e, t) {
                e.uniform3uiv(this.addr, t)
            }

            function nU(e, t) {
                e.uniform4uiv(this.addr, t)
            }

            function nB(e, t, i) {
                let n = this.cache,
                    r = t.length,
                    a = nn(i, r);
                nt(n, a) || (e.uniform1iv(this.addr, a), ni(n, a));
                for (let s = 0; s !== r; ++s) i.setTexture2D(t[s] || i1, a[s])
            }

            function nF(e, t, i) {
                let n = this.cache,
                    r = t.length,
                    a = nn(i, r);
                nt(n, a) || (e.uniform1iv(this.addr, a), ni(n, a));
                for (let s = 0; s !== r; ++s) i.setTexture3D(t[s] || i2, a[s])
            }

            function nk(e, t, i) {
                let n = this.cache,
                    r = t.length,
                    a = nn(i, r);
                nt(n, a) || (e.uniform1iv(this.addr, a), ni(n, a));
                for (let s = 0; s !== r; ++s) i.setTextureCube(t[s] || i4, a[s])
            }

            function nV(e, t, i) {
                let n = this.cache,
                    r = t.length,
                    a = nn(i, r);
                nt(n, a) || (e.uniform1iv(this.addr, a), ni(n, a));
                for (let s = 0; s !== r; ++s) i.setTexture2DArray(t[s] || i3, a[s])
            }
            class nG {
                constructor(e, t, i) {
                    this.id = e, this.addr = i, this.cache = [], this.setValue = function(e) {
                        switch (e) {
                            case 5126:
                                return nr;
                            case 35664:
                                return na;
                            case 35665:
                                return ns;
                            case 35666:
                                return no;
                            case 35674:
                                return nl;
                            case 35675:
                                return nh;
                            case 35676:
                                return nu;
                            case 5124:
                            case 35670:
                                return nc;
                            case 35667:
                            case 35671:
                                return nd;
                            case 35668:
                            case 35672:
                                return np;
                            case 35669:
                            case 35673:
                                return nf;
                            case 5125:
                                return nm;
                            case 36294:
                                return ng;
                            case 36295:
                                return nv;
                            case 36296:
                                return n_;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return nx;
                            case 35679:
                            case 36299:
                            case 36307:
                                return ny;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return nM;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return nb
                        }
                    }(t.type)
                }
            }
            class nW {
                constructor(e, t, i) {
                    this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = function(e) {
                        switch (e) {
                            case 5126:
                                return nS;
                            case 35664:
                                return nw;
                            case 35665:
                                return nT;
                            case 35666:
                                return nE;
                            case 35674:
                                return nA;
                            case 35675:
                                return nC;
                            case 35676:
                                return nL;
                            case 5124:
                            case 35670:
                                return nP;
                            case 35667:
                            case 35671:
                                return nR;
                            case 35668:
                            case 35672:
                                return nI;
                            case 35669:
                            case 35673:
                                return nD;
                            case 5125:
                                return nN;
                            case 36294:
                                return nO;
                            case 36295:
                                return nz;
                            case 36296:
                                return nU;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return nB;
                            case 35679:
                            case 36299:
                            case 36307:
                                return nF;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return nk;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return nV
                        }
                    }(t.type)
                }
            }
            class nH {
                constructor(e) {
                    this.id = e, this.seq = [], this.map = {}
                }
                setValue(e, t, i) {
                    let n = this.seq;
                    for (let r = 0, a = n.length; r !== a; ++r) {
                        let s = n[r];
                        s.setValue(e, t[s.id], i)
                    }
                }
            }
            let nj = /(\w+)(\])?(\[|\.)?/g;

            function nq(e, t) {
                e.seq.push(t), e.map[t.id] = t
            }
            class nX {
                constructor(e, t) {
                    this.seq = [], this.map = {};
                    let i = e.getProgramParameter(t, 35718);
                    for (let n = 0; n < i; ++n) {
                        let r = e.getActiveUniform(t, n),
                            a = e.getUniformLocation(t, r.name);
                        ! function(e, t, i) {
                            let n = e.name,
                                r = n.length;
                            for (nj.lastIndex = 0;;) {
                                let a = nj.exec(n),
                                    s = nj.lastIndex,
                                    o = a[1],
                                    l = "]" === a[2],
                                    h = a[3];
                                if (l && (o |= 0), void 0 === h || "[" === h && s + 2 === r) {
                                    nq(i, void 0 === h ? new nG(o, e, t) : new nW(o, e, t));
                                    break
                                } {
                                    let u = i.map,
                                        c = u[o];
                                    void 0 === c && nq(i, c = new nH(o)), i = c
                                }
                            }
                        }(r, a, this)
                    }
                }
                setValue(e, t, i, n) {
                    let r = this.map[t];
                    void 0 !== r && r.setValue(e, i, n)
                }
                setOptional(e, t, i) {
                    let n = t[i];
                    void 0 !== n && this.setValue(e, i, n)
                }
                static upload(e, t, i, n) {
                    for (let r = 0, a = t.length; r !== a; ++r) {
                        let s = t[r],
                            o = i[s.id];
                        !1 !== o.needsUpdate && s.setValue(e, o.value, n)
                    }
                }
                static seqWithValue(e, t) {
                    let i = [];
                    for (let n = 0, r = e.length; n !== r; ++n) {
                        let a = e[n];
                        a.id in t && i.push(a)
                    }
                    return i
                }
            }

            function nJ(e, t, i) {
                let n = e.createShader(t);
                return e.shaderSource(n, i), e.compileShader(n), n
            }
            let nY = 0;

            function nZ(e, t, i) {
                let n = e.getShaderParameter(t, 35713),
                    r = e.getShaderInfoLog(t).trim();
                if (n && "" === r) return "";
                let a = /ERROR: 0:(\d+)/.exec(r);
                if (!a) return r; {
                    let s = parseInt(a[1]);
                    return i.toUpperCase() + "\n\n" + r + "\n\n" + function(e, t) {
                        let i = e.split("\n"),
                            n = [],
                            r = Math.max(t - 6, 0),
                            a = Math.min(t + 6, i.length);
                        for (let s = r; s < a; s++) {
                            let o = s + 1;
                            n.push(`${o===t?">":" "} ${o}: ${i[s]}`)
                        }
                        return n.join("\n")
                    }(e.getShaderSource(t), s)
                }
            }

            function nK(e) {
                return "" !== e
            }

            function nQ(e, t) {
                let i = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, i).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
            }

            function n$(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }
            let n0 = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function n1(e) {
                return e.replace(n0, n3)
            }

            function n3(e, t) {
                let i = ib[t];
                if (void 0 === i) throw Error("Can not resolve #include <" + t + ">");
                return n1(i)
            }
            let n2 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function n4(e) {
                return e.replace(n2, n5)
            }

            function n5(e, t, i, n) {
                let r = "";
                for (let a = parseInt(t); a < parseInt(i); a++) r += n.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
                return r
            }

            function n6(e) {
                let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
                return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
            }

            function n7(e, t, i, n) {
                let r, a, o, l, h, u;
                let c = e.getContext(),
                    d = i.defines,
                    p = i.vertexShader,
                    f = i.fragmentShader,
                    y = (h = "SHADOWMAP_TYPE_BASIC", 1 === i.shadowMapType ? h = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === s ? h = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === i.shadowMapType && (h = "SHADOWMAP_TYPE_VSM"), h),
                    M = function(e) {
                        let t = "ENVMAP_TYPE_CUBE";
                        if (e.envMap) switch (e.envMapMode) {
                            case 301:
                            case 302:
                                t = "ENVMAP_TYPE_CUBE";
                                break;
                            case 306:
                                t = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return t
                    }(i),
                    b = (u = "ENVMAP_MODE_REFLECTION", i.envMap && 302 === i.envMapMode && (u = "ENVMAP_MODE_REFRACTION"), u),
                    S = function(e) {
                        let t = "ENVMAP_BLENDING_NONE";
                        if (e.envMap) switch (e.combine) {
                            case 0:
                                t = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case 1:
                                t = "ENVMAP_BLENDING_MIX";
                                break;
                            case 2:
                                t = "ENVMAP_BLENDING_ADD"
                        }
                        return t
                    }(i),
                    w = function(e) {
                        let t = e.envMapCubeUVHeight;
                        if (null === t) return null;
                        let i = Math.log2(t) - 2;
                        return {
                            texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 112)),
                            texelHeight: 1 / t,
                            maxMip: i
                        }
                    }(i),
                    T = i.isWebGL2 ? "" : function(e) {
                        let t = [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
                        return t.filter(nK).join("\n")
                    }(i),
                    E = function(e) {
                        let t = [];
                        for (let i in e) {
                            let n = e[i];
                            !1 !== n && t.push("#define " + i + " " + n)
                        }
                        return t.join("\n")
                    }(d),
                    A = c.createProgram(),
                    C = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
                i.isRawShaderMaterial ? ((r = [E].filter(nK).join("\n")).length > 0 && (r += "\n"), (a = [T, E].filter(nK).join("\n")).length > 0 && (a += "\n")) : (r = [n6(i), "#define SHADER_NAME " + i.shaderName, E, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + b : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.morphColors && i.isWebGL2 ? "#define USE_MORPHCOLORS" : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + y : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(nK).join("\n"), a = [T, n6(i), "#define SHADER_NAME " + i.shaderName, E, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + M : "", i.envMap ? "#define " + b : "", i.envMap ? "#define " + S : "", w ? "#define CUBEUV_TEXEL_WIDTH " + w.texelWidth : "", w ? "#define CUBEUV_TEXEL_HEIGHT " + w.texelHeight : "", w ? "#define CUBEUV_MAX_MIP " + w.maxMip + ".0" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoat ? "#define USE_CLEARCOAT" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescence ? "#define USE_IRIDESCENCE" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaTest ? "#define USE_ALPHATEST" : "", i.sheen ? "#define USE_SHEEN" : "", i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + y : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i.toneMapping !== m ? "#define TONE_MAPPING" : "", i.toneMapping !== m ? ib.tonemapping_pars_fragment : "", i.toneMapping !== m ? function(e, t) {
                    let i;
                    switch (t) {
                        case g:
                            i = "Linear";
                            break;
                        case v:
                            i = "Reinhard";
                            break;
                        case _:
                            i = "OptimizedCineon";
                            break;
                        case x:
                            i = "ACESFilmic";
                            break;
                        case 5:
                            i = "Custom";
                            break;
                        default:
                            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), i = "Linear"
                    }
                    return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
                }("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.opaque ? "#define OPAQUE" : "", ib.encodings_pars_fragment, function(e, t) {
                    let i = function(e) {
                        switch (e) {
                            case O:
                                return ["Linear", "( value )"];
                            case z:
                                return ["sRGB", "( value )"];
                            default:
                                return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"]
                        }
                    }(t);
                    return "vec4 " + e + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
                }("linearToOutputTexel", i.outputEncoding), i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(nK).join("\n")), p = n$(p = nQ(p = n1(p), i), i), f = n$(f = nQ(f = n1(f), i), i), p = n4(p), f = n4(f), i.isWebGL2 && !0 !== i.isRawShaderMaterial && (C = "#version 300 es\n", r = "precision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\n" + r, a = ["#define varying in", i.glslVersion === V ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i.glslVersion === V ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + a);
                let L = C + r + p,
                    P = C + a + f,
                    R = nJ(c, 35633, L),
                    I = nJ(c, 35632, P);
                if (c.attachShader(A, R), c.attachShader(A, I), void 0 !== i.index0AttributeName ? c.bindAttribLocation(A, 0, i.index0AttributeName) : !0 === i.morphTargets && c.bindAttribLocation(A, 0, "position"), c.linkProgram(A), e.debug.checkShaderErrors) {
                    let D = c.getProgramInfoLog(A).trim(),
                        N = c.getShaderInfoLog(R).trim(),
                        U = c.getShaderInfoLog(I).trim(),
                        B = !0,
                        F = !0;
                    if (!1 === c.getProgramParameter(A, 35714)) {
                        B = !1;
                        let k = nZ(c, R, "vertex"),
                            G = nZ(c, I, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + c.getError() + " - VALIDATE_STATUS " + c.getProgramParameter(A, 35715) + "\n\nProgram Info Log: " + D + "\n" + k + "\n" + G)
                    } else "" !== D ? console.warn("THREE.WebGLProgram: Program Info Log:", D) : ("" === N || "" === U) && (F = !1);
                    F && (this.diagnostics = {
                        runnable: B,
                        programLog: D,
                        vertexShader: {
                            log: N,
                            prefix: r
                        },
                        fragmentShader: {
                            log: U,
                            prefix: a
                        }
                    })
                }
                return c.deleteShader(R), c.deleteShader(I), this.getUniforms = function() {
                    return void 0 === o && (o = new nX(c, A)), o
                }, this.getAttributes = function() {
                    return void 0 === l && (l = function(e, t) {
                        let i = {},
                            n = e.getProgramParameter(t, 35721);
                        for (let r = 0; r < n; r++) {
                            let a = e.getActiveAttrib(t, r),
                                s = a.name,
                                o = 1;
                            35674 === a.type && (o = 2), 35675 === a.type && (o = 3), 35676 === a.type && (o = 4), i[s] = {
                                type: a.type,
                                location: e.getAttribLocation(t, s),
                                locationSize: o
                            }
                        }
                        return i
                    }(c, A)), l
                }, this.destroy = function() {
                    n.releaseStatesOfProgram(this), c.deleteProgram(A), this.program = void 0
                }, this.name = i.shaderName, this.id = nY++, this.cacheKey = t, this.usedTimes = 1, this.program = A, this.vertexShader = R, this.fragmentShader = I, this
            }
            let n8 = 0;
            class n9 {
                constructor() {
                    this.shaderCache = new Map, this.materialCache = new Map
                }
                update(e) {
                    let t = e.vertexShader,
                        i = e.fragmentShader,
                        n = this._getShaderStage(t),
                        r = this._getShaderStage(i),
                        a = this._getShaderCacheForMaterial(e);
                    return !1 === a.has(n) && (a.add(n), n.usedTimes++), !1 === a.has(r) && (a.add(r), r.usedTimes++), this
                }
                remove(e) {
                    let t = this.materialCache.get(e);
                    for (let i of t) i.usedTimes--, 0 === i.usedTimes && this.shaderCache.delete(i.code);
                    return this.materialCache.delete(e), this
                }
                getVertexShaderID(e) {
                    return this._getShaderStage(e.vertexShader).id
                }
                getFragmentShaderID(e) {
                    return this._getShaderStage(e.fragmentShader).id
                }
                dispose() {
                    this.shaderCache.clear(), this.materialCache.clear()
                }
                _getShaderCacheForMaterial(e) {
                    let t = this.materialCache,
                        i = t.get(e);
                    return void 0 === i && (i = new Set, t.set(e, i)), i
                }
                _getShaderStage(e) {
                    let t = this.shaderCache,
                        i = t.get(e);
                    return void 0 === i && (i = new re(e), t.set(e, i)), i
                }
            }
            class re {
                constructor(e) {
                    this.id = n8++, this.code = e, this.usedTimes = 0
                }
            }

            function rt(e, t, i, n, r, a, s) {
                let o = new ta,
                    u = new n9,
                    c = [],
                    d = r.isWebGL2,
                    p = r.logarithmicDepthBuffer,
                    f = r.vertexTextures,
                    g = r.precision,
                    v = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    };
                return {
                    getParameters: function(a, o, c, _, x) {
                        let y, M, b, S;
                        let w = _.fog,
                            T = x.geometry,
                            E = a.isMeshStandardMaterial ? _.environment : null,
                            A = (a.isMeshStandardMaterial ? i : t).get(a.envMap || E),
                            C = A && 306 === A.mapping ? A.image.height : null,
                            L = v[a.type];
                        null !== a.precision && (g = r.getMaxPrecision(a.precision)) !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", g, "instead.");
                        let P = T.morphAttributes.position || T.morphAttributes.normal || T.morphAttributes.color,
                            R = void 0 !== P ? P.length : 0,
                            I = 0;
                        if (void 0 !== T.morphAttributes.position && (I = 1), void 0 !== T.morphAttributes.normal && (I = 2), void 0 !== T.morphAttributes.color && (I = 3), L) {
                            let D = iw[L];
                            y = D.vertexShader, M = D.fragmentShader
                        } else y = a.vertexShader, M = a.fragmentShader, u.update(a), b = u.getVertexShaderID(a), S = u.getFragmentShaderID(a);
                        let N = e.getRenderTarget(),
                            U = a.alphaTest > 0,
                            F = a.clearcoat > 0,
                            k = a.iridescence > 0,
                            V = {
                                isWebGL2: d,
                                shaderID: L,
                                shaderName: a.type,
                                vertexShader: y,
                                fragmentShader: M,
                                defines: a.defines,
                                customVertexShaderID: b,
                                customFragmentShaderID: S,
                                isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                                glslVersion: a.glslVersion,
                                precision: g,
                                instancing: !0 === x.isInstancedMesh,
                                instancingColor: !0 === x.isInstancedMesh && null !== x.instanceColor,
                                supportsVertexTextures: f,
                                outputEncoding: null === N ? e.outputEncoding : !0 === N.isXRRenderTarget ? N.texture.encoding : O,
                                map: !!a.map,
                                matcap: !!a.matcap,
                                envMap: !!A,
                                envMapMode: A && A.mapping,
                                envMapCubeUVHeight: C,
                                lightMap: !!a.lightMap,
                                aoMap: !!a.aoMap,
                                emissiveMap: !!a.emissiveMap,
                                bumpMap: !!a.bumpMap,
                                normalMap: !!a.normalMap,
                                objectSpaceNormalMap: 1 === a.normalMapType,
                                tangentSpaceNormalMap: a.normalMapType === B,
                                decodeVideoTexture: !!a.map && !0 === a.map.isVideoTexture && a.map.encoding === z,
                                clearcoat: F,
                                clearcoatMap: F && !!a.clearcoatMap,
                                clearcoatRoughnessMap: F && !!a.clearcoatRoughnessMap,
                                clearcoatNormalMap: F && !!a.clearcoatNormalMap,
                                iridescence: k,
                                iridescenceMap: k && !!a.iridescenceMap,
                                iridescenceThicknessMap: k && !!a.iridescenceThicknessMap,
                                displacementMap: !!a.displacementMap,
                                roughnessMap: !!a.roughnessMap,
                                metalnessMap: !!a.metalnessMap,
                                specularMap: !!a.specularMap,
                                specularIntensityMap: !!a.specularIntensityMap,
                                specularColorMap: !!a.specularColorMap,
                                opaque: !1 === a.transparent && 1 === a.blending,
                                alphaMap: !!a.alphaMap,
                                alphaTest: U,
                                gradientMap: !!a.gradientMap,
                                sheen: a.sheen > 0,
                                sheenColorMap: !!a.sheenColorMap,
                                sheenRoughnessMap: !!a.sheenRoughnessMap,
                                transmission: a.transmission > 0,
                                transmissionMap: !!a.transmissionMap,
                                thicknessMap: !!a.thicknessMap,
                                combine: a.combine,
                                vertexTangents: !!a.normalMap && !!T.attributes.tangent,
                                vertexColors: a.vertexColors,
                                vertexAlphas: !0 === a.vertexColors && !!T.attributes.color && 4 === T.attributes.color.itemSize,
                                vertexUvs: !!a.map || !!a.bumpMap || !!a.normalMap || !!a.specularMap || !!a.alphaMap || !!a.emissiveMap || !!a.roughnessMap || !!a.metalnessMap || !!a.clearcoatMap || !!a.clearcoatRoughnessMap || !!a.clearcoatNormalMap || !!a.iridescenceMap || !!a.iridescenceThicknessMap || !!a.displacementMap || !!a.transmissionMap || !!a.thicknessMap || !!a.specularIntensityMap || !!a.specularColorMap || !!a.sheenColorMap || !!a.sheenRoughnessMap,
                                uvsVertexOnly: !(a.map || a.bumpMap || a.normalMap || a.specularMap || a.alphaMap || a.emissiveMap || a.roughnessMap || a.metalnessMap || a.clearcoatNormalMap || a.iridescenceMap || a.iridescenceThicknessMap || a.transmission > 0 || a.transmissionMap || a.thicknessMap || a.specularIntensityMap || a.specularColorMap || a.sheen > 0 || a.sheenColorMap || a.sheenRoughnessMap) && !!a.displacementMap,
                                fog: !!w,
                                useFog: !0 === a.fog,
                                fogExp2: w && w.isFogExp2,
                                flatShading: !!a.flatShading,
                                sizeAttenuation: a.sizeAttenuation,
                                logarithmicDepthBuffer: p,
                                skinning: !0 === x.isSkinnedMesh,
                                morphTargets: void 0 !== T.morphAttributes.position,
                                morphNormals: void 0 !== T.morphAttributes.normal,
                                morphColors: void 0 !== T.morphAttributes.color,
                                morphTargetsCount: R,
                                morphTextureStride: I,
                                numDirLights: o.directional.length,
                                numPointLights: o.point.length,
                                numSpotLights: o.spot.length,
                                numSpotLightMaps: o.spotLightMap.length,
                                numRectAreaLights: o.rectArea.length,
                                numHemiLights: o.hemi.length,
                                numDirLightShadows: o.directionalShadowMap.length,
                                numPointLightShadows: o.pointShadowMap.length,
                                numSpotLightShadows: o.spotShadowMap.length,
                                numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
                                numClippingPlanes: s.numPlanes,
                                numClipIntersection: s.numIntersection,
                                dithering: a.dithering,
                                shadowMapEnabled: e.shadowMap.enabled && c.length > 0,
                                shadowMapType: e.shadowMap.type,
                                toneMapping: a.toneMapped ? e.toneMapping : m,
                                physicallyCorrectLights: e.physicallyCorrectLights,
                                premultipliedAlpha: a.premultipliedAlpha,
                                doubleSided: a.side === h,
                                flipSided: a.side === l,
                                useDepthPacking: !!a.depthPacking,
                                depthPacking: a.depthPacking || 0,
                                index0AttributeName: a.index0AttributeName,
                                extensionDerivatives: a.extensions && a.extensions.derivatives,
                                extensionFragDepth: a.extensions && a.extensions.fragDepth,
                                extensionDrawBuffers: a.extensions && a.extensions.drawBuffers,
                                extensionShaderTextureLOD: a.extensions && a.extensions.shaderTextureLOD,
                                rendererExtensionFragDepth: d || n.has("EXT_frag_depth"),
                                rendererExtensionDrawBuffers: d || n.has("WEBGL_draw_buffers"),
                                rendererExtensionShaderTextureLod: d || n.has("EXT_shader_texture_lod"),
                                customProgramCacheKey: a.customProgramCacheKey()
                            };
                        return V
                    },
                    getProgramCacheKey: function(t) {
                        let i = [];
                        if (t.shaderID ? i.push(t.shaderID) : (i.push(t.customVertexShaderID), i.push(t.customFragmentShaderID)), void 0 !== t.defines)
                            for (let n in t.defines) i.push(n), i.push(t.defines[n]);
                        return !1 === t.isRawShaderMaterial && (i.push(t.precision), i.push(t.outputEncoding), i.push(t.envMapMode), i.push(t.envMapCubeUVHeight), i.push(t.combine), i.push(t.vertexUvs), i.push(t.fogExp2), i.push(t.sizeAttenuation), i.push(t.morphTargetsCount), i.push(t.morphAttributeCount), i.push(t.numDirLights), i.push(t.numPointLights), i.push(t.numSpotLights), i.push(t.numSpotLightMaps), i.push(t.numHemiLights), i.push(t.numRectAreaLights), i.push(t.numDirLightShadows), i.push(t.numPointLightShadows), i.push(t.numSpotLightShadows), i.push(t.numSpotLightShadowsWithMaps), i.push(t.shadowMapType), i.push(t.toneMapping), i.push(t.numClippingPlanes), i.push(t.numClipIntersection), i.push(t.depthPacking), o.disableAll(), t.isWebGL2 && o.enable(0), t.supportsVertexTextures && o.enable(1), t.instancing && o.enable(2), t.instancingColor && o.enable(3), t.map && o.enable(4), t.matcap && o.enable(5), t.envMap && o.enable(6), t.lightMap && o.enable(7), t.aoMap && o.enable(8), t.emissiveMap && o.enable(9), t.bumpMap && o.enable(10), t.normalMap && o.enable(11), t.objectSpaceNormalMap && o.enable(12), t.tangentSpaceNormalMap && o.enable(13), t.clearcoat && o.enable(14), t.clearcoatMap && o.enable(15), t.clearcoatRoughnessMap && o.enable(16), t.clearcoatNormalMap && o.enable(17), t.iridescence && o.enable(18), t.iridescenceMap && o.enable(19), t.iridescenceThicknessMap && o.enable(20), t.displacementMap && o.enable(21), t.specularMap && o.enable(22), t.roughnessMap && o.enable(23), t.metalnessMap && o.enable(24), t.gradientMap && o.enable(25), t.alphaMap && o.enable(26), t.alphaTest && o.enable(27), t.vertexColors && o.enable(28), t.vertexAlphas && o.enable(29), t.vertexUvs && o.enable(30), t.vertexTangents && o.enable(31), t.uvsVertexOnly && o.enable(32), i.push(o.mask), o.disableAll(), t.fog && o.enable(0), t.useFog && o.enable(1), t.flatShading && o.enable(2), t.logarithmicDepthBuffer && o.enable(3), t.skinning && o.enable(4), t.morphTargets && o.enable(5), t.morphNormals && o.enable(6), t.morphColors && o.enable(7), t.premultipliedAlpha && o.enable(8), t.shadowMapEnabled && o.enable(9), t.physicallyCorrectLights && o.enable(10), t.doubleSided && o.enable(11), t.flipSided && o.enable(12), t.useDepthPacking && o.enable(13), t.dithering && o.enable(14), t.specularIntensityMap && o.enable(15), t.specularColorMap && o.enable(16), t.transmission && o.enable(17), t.transmissionMap && o.enable(18), t.thicknessMap && o.enable(19), t.sheen && o.enable(20), t.sheenColorMap && o.enable(21), t.sheenRoughnessMap && o.enable(22), t.decodeVideoTexture && o.enable(23), t.opaque && o.enable(24), i.push(o.mask), i.push(e.outputEncoding)), i.push(t.customProgramCacheKey), i.join()
                    },
                    getUniforms: function(e) {
                        let t;
                        let i = v[e.type];
                        if (i) {
                            let n = iw[i];
                            t = ir.clone(n.uniforms)
                        } else t = e.uniforms;
                        return t
                    },
                    acquireProgram: function(t, i) {
                        let n;
                        for (let r = 0, s = c.length; r < s; r++) {
                            let o = c[r];
                            if (o.cacheKey === i) {
                                n = o, ++n.usedTimes;
                                break
                            }
                        }
                        return void 0 === n && (n = new n7(e, i, t, a), c.push(n)), n
                    },
                    releaseProgram: function(e) {
                        if (0 == --e.usedTimes) {
                            let t = c.indexOf(e);
                            c[t] = c[c.length - 1], c.pop(), e.destroy()
                        }
                    },
                    releaseShaderCache: function(e) {
                        u.remove(e)
                    },
                    programs: c,
                    dispose: function() {
                        u.dispose()
                    }
                }
            }

            function ri() {
                let e = new WeakMap;
                return {
                    get: function(t) {
                        let i = e.get(t);
                        return void 0 === i && (i = {}, e.set(t, i)), i
                    },
                    remove: function(t) {
                        e.delete(t)
                    },
                    update: function(t, i, n) {
                        e.get(t)[i] = n
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function rn(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }

            function rr(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }

            function ra() {
                let e = [],
                    t = 0,
                    i = [],
                    n = [],
                    r = [];

                function a(i, n, r, a, s, o) {
                    let l = e[t];
                    return void 0 === l ? (l = {
                        id: i.id,
                        object: i,
                        geometry: n,
                        material: r,
                        groupOrder: a,
                        renderOrder: i.renderOrder,
                        z: s,
                        group: o
                    }, e[t] = l) : (l.id = i.id, l.object = i, l.geometry = n, l.material = r, l.groupOrder = a, l.renderOrder = i.renderOrder, l.z = s, l.group = o), t++, l
                }
                return {
                    opaque: i,
                    transmissive: n,
                    transparent: r,
                    init: function() {
                        t = 0, i.length = 0, n.length = 0, r.length = 0
                    },
                    push: function(e, t, s, o, l, h) {
                        let u = a(e, t, s, o, l, h);
                        s.transmission > 0 ? n.push(u) : !0 === s.transparent ? r.push(u) : i.push(u)
                    },
                    unshift: function(e, t, s, o, l, h) {
                        let u = a(e, t, s, o, l, h);
                        s.transmission > 0 ? n.unshift(u) : !0 === s.transparent ? r.unshift(u) : i.unshift(u)
                    },
                    finish: function() {
                        for (let i = t, n = e.length; i < n; i++) {
                            let r = e[i];
                            if (null === r.id) break;
                            r.id = null, r.object = null, r.geometry = null, r.material = null, r.group = null
                        }
                    },
                    sort: function(e, t) {
                        i.length > 1 && i.sort(e || rn), n.length > 1 && n.sort(t || rr), r.length > 1 && r.sort(t || rr)
                    }
                }
            }

            function rs() {
                let e = new WeakMap;
                return {
                    get: function(t, i) {
                        let n;
                        let r = e.get(t);
                        return void 0 === r ? (n = new ra, e.set(t, [n])) : i >= r.length ? (n = new ra, r.push(n)) : n = r[i], n
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function ro() {
                let e = {};
                return {
                    get: function(t) {
                        let i;
                        if (void 0 !== e[t.id]) return e[t.id];
                        switch (t.type) {
                            case "DirectionalLight":
                                i = {
                                    direction: new eC,
                                    color: new e_
                                };
                                break;
                            case "SpotLight":
                                i = {
                                    position: new eC,
                                    direction: new eC,
                                    color: new e_,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                i = {
                                    position: new eC,
                                    color: new e_,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                i = {
                                    direction: new eC,
                                    skyColor: new e_,
                                    groundColor: new e_
                                };
                                break;
                            case "RectAreaLight":
                                i = {
                                    color: new e_,
                                    position: new eC,
                                    halfWidth: new eC,
                                    halfHeight: new eC
                                }
                        }
                        return e[t.id] = i, i
                    }
                }
            }
            let rl = 0;

            function rh(e, t) {
                return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
            }

            function ru(e, t) {
                let i = new ro,
                    n = function() {
                        let e = {};
                        return {
                            get: function(t) {
                                let i;
                                if (void 0 !== e[t.id]) return e[t.id];
                                switch (t.type) {
                                    case "DirectionalLight":
                                    case "SpotLight":
                                        i = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new en
                                        };
                                        break;
                                    case "PointLight":
                                        i = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new en,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        }
                                }
                                return e[t.id] = i, i
                            }
                        }
                    }(),
                    r = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1,
                            numSpotMaps: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotLightMap: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotLightMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        numSpotLightShadowsWithMaps: 0
                    };
                for (let a = 0; a < 9; a++) r.probe.push(new eC);
                let s = new eC,
                    o = new e4,
                    l = new e4;
                return {
                    setup: function(a, s) {
                        let o = 0,
                            l = 0,
                            h = 0;
                        for (let u = 0; u < 9; u++) r.probe[u].set(0, 0, 0);
                        let c = 0,
                            d = 0,
                            p = 0,
                            f = 0,
                            m = 0,
                            g = 0,
                            v = 0,
                            _ = 0,
                            x = 0,
                            y = 0;
                        a.sort(rh);
                        let M = !0 !== s ? Math.PI : 1;
                        for (let b = 0, S = a.length; b < S; b++) {
                            let w = a[b],
                                T = w.color,
                                E = w.intensity,
                                A = w.distance,
                                C = w.shadow && w.shadow.map ? w.shadow.map.texture : null;
                            if (w.isAmbientLight) o += T.r * E * M, l += T.g * E * M, h += T.b * E * M;
                            else if (w.isLightProbe)
                                for (let L = 0; L < 9; L++) r.probe[L].addScaledVector(w.sh.coefficients[L], E);
                            else if (w.isDirectionalLight) {
                                let P = i.get(w);
                                if (P.color.copy(w.color).multiplyScalar(w.intensity * M), w.castShadow) {
                                    let R = w.shadow,
                                        I = n.get(w);
                                    I.shadowBias = R.bias, I.shadowNormalBias = R.normalBias, I.shadowRadius = R.radius, I.shadowMapSize = R.mapSize, r.directionalShadow[c] = I, r.directionalShadowMap[c] = C, r.directionalShadowMatrix[c] = w.shadow.matrix, g++
                                }
                                r.directional[c] = P, c++
                            } else if (w.isSpotLight) {
                                let D = i.get(w);
                                D.position.setFromMatrixPosition(w.matrixWorld), D.color.copy(T).multiplyScalar(E * M), D.distance = A, D.coneCos = Math.cos(w.angle), D.penumbraCos = Math.cos(w.angle * (1 - w.penumbra)), D.decay = w.decay, r.spot[p] = D;
                                let N = w.shadow;
                                if (w.map && (r.spotLightMap[x] = w.map, x++, N.updateMatrices(w), w.castShadow && y++), r.spotLightMatrix[p] = N.matrix, w.castShadow) {
                                    let O = n.get(w);
                                    O.shadowBias = N.bias, O.shadowNormalBias = N.normalBias, O.shadowRadius = N.radius, O.shadowMapSize = N.mapSize, r.spotShadow[p] = O, r.spotShadowMap[p] = C, _++
                                }
                                p++
                            } else if (w.isRectAreaLight) {
                                let z = i.get(w);
                                z.color.copy(T).multiplyScalar(E), z.halfWidth.set(.5 * w.width, 0, 0), z.halfHeight.set(0, .5 * w.height, 0), r.rectArea[f] = z, f++
                            } else if (w.isPointLight) {
                                let U = i.get(w);
                                if (U.color.copy(w.color).multiplyScalar(w.intensity * M), U.distance = w.distance, U.decay = w.decay, w.castShadow) {
                                    let B = w.shadow,
                                        F = n.get(w);
                                    F.shadowBias = B.bias, F.shadowNormalBias = B.normalBias, F.shadowRadius = B.radius, F.shadowMapSize = B.mapSize, F.shadowCameraNear = B.camera.near, F.shadowCameraFar = B.camera.far, r.pointShadow[d] = F, r.pointShadowMap[d] = C, r.pointShadowMatrix[d] = w.shadow.matrix, v++
                                }
                                r.point[d] = U, d++
                            } else if (w.isHemisphereLight) {
                                let k = i.get(w);
                                k.skyColor.copy(w.color).multiplyScalar(E * M), k.groundColor.copy(w.groundColor).multiplyScalar(E * M), r.hemi[m] = k, m++
                            }
                        }
                        f > 0 && (t.isWebGL2 ? (r.rectAreaLTC1 = iS.LTC_FLOAT_1, r.rectAreaLTC2 = iS.LTC_FLOAT_2) : !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = iS.LTC_FLOAT_1, r.rectAreaLTC2 = iS.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = iS.LTC_HALF_1, r.rectAreaLTC2 = iS.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = h;
                        let V = r.hash;
                        (V.directionalLength !== c || V.pointLength !== d || V.spotLength !== p || V.rectAreaLength !== f || V.hemiLength !== m || V.numDirectionalShadows !== g || V.numPointShadows !== v || V.numSpotShadows !== _ || V.numSpotMaps !== x) && (r.directional.length = c, r.spot.length = p, r.rectArea.length = f, r.point.length = d, r.hemi.length = m, r.directionalShadow.length = g, r.directionalShadowMap.length = g, r.pointShadow.length = v, r.pointShadowMap.length = v, r.spotShadow.length = _, r.spotShadowMap.length = _, r.directionalShadowMatrix.length = g, r.pointShadowMatrix.length = v, r.spotLightMatrix.length = _ + x - y, r.spotLightMap.length = x, r.numSpotLightShadowsWithMaps = y, V.directionalLength = c, V.pointLength = d, V.spotLength = p, V.rectAreaLength = f, V.hemiLength = m, V.numDirectionalShadows = g, V.numPointShadows = v, V.numSpotShadows = _, V.numSpotMaps = x, r.version = rl++)
                    },
                    setupView: function(e, t) {
                        let i = 0,
                            n = 0,
                            a = 0,
                            h = 0,
                            u = 0,
                            c = t.matrixWorldInverse;
                        for (let d = 0, p = e.length; d < p; d++) {
                            let f = e[d];
                            if (f.isDirectionalLight) {
                                let m = r.directional[i];
                                m.direction.setFromMatrixPosition(f.matrixWorld), s.setFromMatrixPosition(f.target.matrixWorld), m.direction.sub(s), m.direction.transformDirection(c), i++
                            } else if (f.isSpotLight) {
                                let g = r.spot[a];
                                g.position.setFromMatrixPosition(f.matrixWorld), g.position.applyMatrix4(c), g.direction.setFromMatrixPosition(f.matrixWorld), s.setFromMatrixPosition(f.target.matrixWorld), g.direction.sub(s), g.direction.transformDirection(c), a++
                            } else if (f.isRectAreaLight) {
                                let v = r.rectArea[h];
                                v.position.setFromMatrixPosition(f.matrixWorld), v.position.applyMatrix4(c), l.identity(), o.copy(f.matrixWorld), o.premultiply(c), l.extractRotation(o), v.halfWidth.set(.5 * f.width, 0, 0), v.halfHeight.set(0, .5 * f.height, 0), v.halfWidth.applyMatrix4(l), v.halfHeight.applyMatrix4(l), h++
                            } else if (f.isPointLight) {
                                let _ = r.point[n];
                                _.position.setFromMatrixPosition(f.matrixWorld), _.position.applyMatrix4(c), n++
                            } else if (f.isHemisphereLight) {
                                let x = r.hemi[u];
                                x.direction.setFromMatrixPosition(f.matrixWorld), x.direction.transformDirection(c), u++
                            }
                        }
                    },
                    state: r
                }
            }

            function rc(e, t) {
                let i = new ru(e, t),
                    n = [],
                    r = [];
                return {
                    init: function() {
                        n.length = 0, r.length = 0
                    },
                    state: {
                        lightsArray: n,
                        shadowsArray: r,
                        lights: i
                    },
                    setupLights: function(e) {
                        i.setup(n, e)
                    },
                    setupLightsView: function(e) {
                        i.setupView(n, e)
                    },
                    pushLight: function(e) {
                        n.push(e)
                    },
                    pushShadow: function(e) {
                        r.push(e)
                    }
                }
            }

            function rd(e, t) {
                let i = new WeakMap;
                return {
                    get: function(n, r = 0) {
                        let a;
                        let s = i.get(n);
                        return void 0 === s ? (a = new rc(e, t), i.set(n, [a])) : r >= s.length ? (a = new rc(e, t), s.push(a)) : a = s[r], a
                    },
                    dispose: function() {
                        i = new WeakMap
                    }
                }
            }
            class rp extends tI {
                constructor(e) {
                    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
                }
            }
            class rf extends tI {
                constructor(e) {
                    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new eC, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
                }
            }

            function rm(e, t, i) {
                let n = new i_,
                    r = new en,
                    a = new en,
                    s = new ew,
                    u = new rp({
                        depthPacking: U
                    }),
                    c = new rf,
                    d = {},
                    p = i.maxTextureSize,
                    f = {
                        0: l,
                        1: o,
                        2: h
                    },
                    m = new ia({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new en
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}",
                        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                    }),
                    g = m.clone();
                g.defines.HORIZONTAL_PASS = 1;
                let v = new tX;
                v.setAttribute("position", new tz(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                let _ = new t7(v, m),
                    x = this;

                function y(t, i, n, r, a, s) {
                    let o = null,
                        l = !0 === n.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                    if (void 0 !== l) o = l;
                    else if (o = !0 === n.isPointLight ? c : u, e.localClippingEnabled && !0 === i.clipShadows && Array.isArray(i.clippingPlanes) && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0 || i.map && i.alphaTest > 0) {
                        let h = o.uuid,
                            p = i.uuid,
                            m = d[h];
                        void 0 === m && (m = {}, d[h] = m);
                        let g = m[p];
                        void 0 === g && (g = o.clone(), m[p] = g), o = g
                    }
                    return o.visible = i.visible, o.wireframe = i.wireframe, 3 === s ? o.side = null !== i.shadowSide ? i.shadowSide : i.side : o.side = null !== i.shadowSide ? i.shadowSide : f[i.side], o.alphaMap = i.alphaMap, o.alphaTest = i.alphaTest, o.map = i.map, o.clipShadows = i.clipShadows, o.clippingPlanes = i.clippingPlanes, o.clipIntersection = i.clipIntersection, o.displacementMap = i.displacementMap, o.displacementScale = i.displacementScale, o.displacementBias = i.displacementBias, o.wireframeLinewidth = i.wireframeLinewidth, o.linewidth = i.linewidth, !0 === n.isPointLight && !0 === o.isMeshDistanceMaterial && (o.referencePosition.setFromMatrixPosition(n.matrixWorld), o.nearDistance = r, o.farDistance = a), o
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(i, o, l) {
                    if (!1 === x.enabled || !1 === x.autoUpdate && !1 === x.needsUpdate || 0 === i.length) return;
                    let h = e.getRenderTarget(),
                        u = e.getActiveCubeFace(),
                        c = e.getActiveMipmapLevel(),
                        d = e.state;
                    d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                    for (let f = 0, v = i.length; f < v; f++) {
                        let M = i[f],
                            b = M.shadow;
                        if (void 0 === b) {
                            console.warn("THREE.WebGLShadowMap:", M, "has no shadow.");
                            continue
                        }
                        if (!1 === b.autoUpdate && !1 === b.needsUpdate) continue;
                        r.copy(b.mapSize);
                        let w = b.getFrameExtents();
                        if (r.multiply(w), a.copy(b.mapSize), (r.x > p || r.y > p) && (r.x > p && (a.x = Math.floor(p / w.x), r.x = a.x * w.x, b.mapSize.x = a.x), r.y > p && (a.y = Math.floor(p / w.y), r.y = a.y * w.y, b.mapSize.y = a.y)), null === b.map) {
                            let T = 3 !== this.type ? {
                                minFilter: S,
                                magFilter: S
                            } : {};
                            b.map = new eT(r.x, r.y, T), b.map.texture.name = M.name + ".shadowMap", b.camera.updateProjectionMatrix()
                        }
                        e.setRenderTarget(b.map), e.clear();
                        let E = b.getViewportCount();
                        for (let A = 0; A < E; A++) {
                            let C = b.getViewport(A);
                            s.set(a.x * C.x, a.y * C.y, a.x * C.z, a.y * C.w), d.viewport(s), b.updateMatrices(M, A), n = b.getFrustum(),
                                function i(r, a, s, o, l) {
                                    if (!1 === r.visible) return;
                                    let h = r.layers.test(a.layers);
                                    if (h && (r.isMesh || r.isLine || r.isPoints) && (r.castShadow || r.receiveShadow && 3 === l) && (!r.frustumCulled || n.intersectsObject(r))) {
                                        r.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, r.matrixWorld);
                                        let u = t.update(r),
                                            c = r.material;
                                        if (Array.isArray(c)) {
                                            let d = u.groups;
                                            for (let p = 0, f = d.length; p < f; p++) {
                                                let m = d[p],
                                                    g = c[m.materialIndex];
                                                if (g && g.visible) {
                                                    let v = y(r, g, o, s.near, s.far, l);
                                                    e.renderBufferDirect(s, null, u, v, r, m)
                                                }
                                            }
                                        } else if (c.visible) {
                                            let _ = y(r, c, o, s.near, s.far, l);
                                            e.renderBufferDirect(s, null, u, _, r, null)
                                        }
                                    }
                                    let x = r.children;
                                    for (let M = 0, b = x.length; M < b; M++) i(x[M], a, s, o, l)
                                }(o, l, b.camera, M, this.type)
                        }!0 !== b.isPointLightShadow && 3 === this.type && function(i, n) {
                            let a = t.update(_);
                            m.defines.VSM_SAMPLES !== i.blurSamples && (m.defines.VSM_SAMPLES = i.blurSamples, g.defines.VSM_SAMPLES = i.blurSamples, m.needsUpdate = !0, g.needsUpdate = !0), null === i.mapPass && (i.mapPass = new eT(r.x, r.y)), m.uniforms.shadow_pass.value = i.map.texture, m.uniforms.resolution.value = i.mapSize, m.uniforms.radius.value = i.radius, e.setRenderTarget(i.mapPass), e.clear(), e.renderBufferDirect(n, null, a, m, _, null), g.uniforms.shadow_pass.value = i.mapPass.texture, g.uniforms.resolution.value = i.mapSize, g.uniforms.radius.value = i.radius, e.setRenderTarget(i.map), e.clear(), e.renderBufferDirect(n, null, a, g, _, null)
                        }(b, l), b.needsUpdate = !1
                    }
                    x.needsUpdate = !1, e.setRenderTarget(h, u, c)
                }
            }

            function rg(e, t, i) {
                let n = i.isWebGL2,
                    r = new function() {
                        let t = !1,
                            i = new ew,
                            n = null,
                            r = new ew(0, 0, 0, 0);
                        return {
                            setMask: function(i) {
                                n === i || t || (e.colorMask(i, i, i, i), n = i)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t, n, a, s, o) {
                                !0 === o && (t *= s, n *= s, a *= s), i.set(t, n, a, s), !1 === r.equals(i) && (e.clearColor(t, n, a, s), r.copy(i))
                            },
                            reset: function() {
                                t = !1, n = null, r.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    a = new function() {
                        let t = !1,
                            i = null,
                            n = null,
                            r = null;
                        return {
                            setTest: function(e) {
                                e ? q(2929) : X(2929)
                            },
                            setMask: function(n) {
                                i === n || t || (e.depthMask(n), i = n)
                            },
                            setFunc: function(t) {
                                if (n !== t) {
                                    switch (t) {
                                        case 0:
                                            e.depthFunc(512);
                                            break;
                                        case 1:
                                            e.depthFunc(519);
                                            break;
                                        case 2:
                                            e.depthFunc(513);
                                            break;
                                        case 3:
                                        default:
                                            e.depthFunc(515);
                                            break;
                                        case 4:
                                            e.depthFunc(514);
                                            break;
                                        case 5:
                                            e.depthFunc(518);
                                            break;
                                        case 6:
                                            e.depthFunc(516);
                                            break;
                                        case 7:
                                            e.depthFunc(517)
                                    }
                                    n = t
                                }
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                r !== t && (e.clearDepth(t), r = t)
                            },
                            reset: function() {
                                t = !1, i = null, n = null, r = null
                            }
                        }
                    },
                    s = new function() {
                        let t = !1,
                            i = null,
                            n = null,
                            r = null,
                            a = null,
                            s = null,
                            o = null,
                            l = null,
                            h = null;
                        return {
                            setTest: function(e) {
                                t || (e ? q(2960) : X(2960))
                            },
                            setMask: function(n) {
                                i === n || t || (e.stencilMask(n), i = n)
                            },
                            setFunc: function(t, i, s) {
                                (n !== t || r !== i || a !== s) && (e.stencilFunc(t, i, s), n = t, r = i, a = s)
                            },
                            setOp: function(t, i, n) {
                                (s !== t || o !== i || l !== n) && (e.stencilOp(t, i, n), s = t, o = i, l = n)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                h !== t && (e.clearStencil(t), h = t)
                            },
                            reset: function() {
                                t = !1, i = null, n = null, r = null, a = null, s = null, o = null, l = null, h = null
                            }
                        }
                    },
                    o = new WeakMap,
                    m = new WeakMap,
                    g = {},
                    v = {},
                    _ = new WeakMap,
                    x = [],
                    y = null,
                    M = !1,
                    b = null,
                    S = null,
                    w = null,
                    T = null,
                    E = null,
                    A = null,
                    C = null,
                    L = !1,
                    P = null,
                    R = null,
                    I = null,
                    D = null,
                    N = null,
                    O = e.getParameter(35661),
                    z = !1,
                    U = e.getParameter(7938); - 1 !== U.indexOf("WebGL") ? z = parseFloat(/^WebGL (\d)/.exec(U)[1]) >= 1 : -1 !== U.indexOf("OpenGL ES") && (z = parseFloat(/^OpenGL ES (\d)/.exec(U)[1]) >= 2);
                let B = null,
                    F = {},
                    k = e.getParameter(3088),
                    V = e.getParameter(2978),
                    G = new ew().fromArray(k),
                    W = new ew().fromArray(V);

                function H(t, i, n) {
                    let r = new Uint8Array(4),
                        a = e.createTexture();
                    e.bindTexture(t, a), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
                    for (let s = 0; s < n; s++) e.texImage2D(i + s, 0, 6408, 1, 1, 0, 6408, 5121, r);
                    return a
                }
                let j = {};

                function q(t) {
                    !0 !== g[t] && (e.enable(t), g[t] = !0)
                }

                function X(t) {
                    !1 !== g[t] && (e.disable(t), g[t] = !1)
                }
                j[3553] = H(3553, 3553, 1), j[34067] = H(34067, 34069, 6), r.setClear(0, 0, 0, 1), a.setClear(1), s.setClear(0), q(2929), a.setFunc(3), Q(!1), $(1), q(2884), K(0);
                let J = {
                    [d]: 32774,
                    101: 32778,
                    102: 32779
                };
                if (n) J[103] = 32775, J[104] = 32776;
                else {
                    let Y = t.get("EXT_blend_minmax");
                    null !== Y && (J[103] = Y.MIN_EXT, J[104] = Y.MAX_EXT)
                }
                let Z = {
                    200: 0,
                    [p]: 1,
                    202: 768,
                    204: 770,
                    210: 776,
                    208: 774,
                    206: 772,
                    203: 769,
                    [f]: 771,
                    209: 775,
                    207: 773
                };

                function K(t, i, n, r, a, s, o, l) {
                    if (0 === t) {
                        !0 === M && (X(3042), M = !1);
                        return
                    }
                    if (!1 === M && (q(3042), M = !0), t !== c) {
                        if (t !== b || l !== L) {
                            if ((S !== d || E !== d) && (e.blendEquation(32774), S = d, E = d), l) switch (t) {
                                case 1:
                                    e.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case u:
                                    e.blendFunc(1, 1);
                                    break;
                                case 3:
                                    e.blendFuncSeparate(0, 769, 0, 1);
                                    break;
                                case 4:
                                    e.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                            } else switch (t) {
                                case 1:
                                    e.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case u:
                                    e.blendFunc(770, 1);
                                    break;
                                case 3:
                                    e.blendFuncSeparate(0, 769, 0, 1);
                                    break;
                                case 4:
                                    e.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                            w = null, T = null, A = null, C = null, b = t, L = l
                        }
                        return
                    }
                    a = a || i, s = s || n, o = o || r, (i !== S || a !== E) && (e.blendEquationSeparate(J[i], J[a]), S = i, E = a), (n !== w || r !== T || s !== A || o !== C) && (e.blendFuncSeparate(Z[n], Z[r], Z[s], Z[o]), w = n, T = r, A = s, C = o), b = t, L = !1
                }

                function Q(t) {
                    P !== t && (t ? e.frontFace(2304) : e.frontFace(2305), P = t)
                }

                function $(t) {
                    0 !== t ? (q(2884), t !== R && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : X(2884), R = t
                }

                function ee(t, i, n) {
                    t ? (q(32823), (D !== i || N !== n) && (e.polygonOffset(i, n), D = i, N = n)) : X(32823)
                }
                return {
                    buffers: {
                        color: r,
                        depth: a,
                        stencil: s
                    },
                    enable: q,
                    disable: X,
                    bindFramebuffer: function(t, i) {
                        return v[t] !== i && (e.bindFramebuffer(t, i), v[t] = i, n && (36009 === t && (v[36160] = i), 36160 === t && (v[36009] = i)), !0)
                    },
                    drawBuffers: function(n, r) {
                        let a = x,
                            s = !1;
                        if (n) {
                            if (void 0 === (a = _.get(r)) && (a = [], _.set(r, a)), n.isWebGLMultipleRenderTargets) {
                                let o = n.texture;
                                if (a.length !== o.length || 36064 !== a[0]) {
                                    for (let l = 0, h = o.length; l < h; l++) a[l] = 36064 + l;
                                    a.length = o.length, s = !0
                                }
                            } else 36064 !== a[0] && (a[0] = 36064, s = !0)
                        } else 1029 !== a[0] && (a[0] = 1029, s = !0);
                        s && (i.isWebGL2 ? e.drawBuffers(a) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(a))
                    },
                    useProgram: function(t) {
                        return y !== t && (e.useProgram(t), y = t, !0)
                    },
                    setBlending: K,
                    setMaterial: function(e, t) {
                        e.side === h ? X(2884) : q(2884);
                        let i = e.side === l;
                        t && (i = !i), Q(i), 1 === e.blending && !1 === e.transparent ? K(0) : K(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), r.setMask(e.colorWrite);
                        let n = e.stencilWrite;
                        s.setTest(n), n && (s.setMask(e.stencilWriteMask), s.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), s.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), ee(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? q(32926) : X(32926)
                    },
                    setFlipSided: Q,
                    setCullFace: $,
                    setLineWidth: function(t) {
                        t !== I && (z && e.lineWidth(t), I = t)
                    },
                    setPolygonOffset: ee,
                    setScissorTest: function(e) {
                        e ? q(3089) : X(3089)
                    },
                    activeTexture: function(t) {
                        void 0 === t && (t = 33984 + O - 1), B !== t && (e.activeTexture(t), B = t)
                    },
                    bindTexture: function(t, i, n) {
                        void 0 === n && (n = null === B ? 33984 + O - 1 : B);
                        let r = F[n];
                        void 0 === r && (r = {
                            type: void 0,
                            texture: void 0
                        }, F[n] = r), (r.type !== t || r.texture !== i) && (B !== n && (e.activeTexture(n), B = n), e.bindTexture(t, i || j[t]), r.type = t, r.texture = i)
                    },
                    unbindTexture: function() {
                        let t = F[B];
                        void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            e.compressedTexImage2D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    compressedTexImage3D: function() {
                        try {
                            e.compressedTexImage3D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texImage2D: function() {
                        try {
                            e.texImage2D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texImage3D: function() {
                        try {
                            e.texImage3D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    updateUBOMapping: function(t, i) {
                        let n = m.get(i);
                        void 0 === n && (n = new WeakMap, m.set(i, n));
                        let r = n.get(t);
                        void 0 === r && (r = e.getUniformBlockIndex(i, t.name), n.set(t, r))
                    },
                    uniformBlockBinding: function(t, i) {
                        let n = m.get(i),
                            r = n.get(t);
                        o.get(i) !== r && (e.uniformBlockBinding(i, r, t.__bindingPointIndex), o.set(i, r))
                    },
                    texStorage2D: function() {
                        try {
                            e.texStorage2D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texStorage3D: function() {
                        try {
                            e.texStorage3D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texSubImage2D: function() {
                        try {
                            e.texSubImage2D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texSubImage3D: function() {
                        try {
                            e.texSubImage3D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    compressedTexSubImage2D: function() {
                        try {
                            e.compressedTexSubImage2D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    compressedTexSubImage3D: function() {
                        try {
                            e.compressedTexSubImage3D.apply(e, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    scissor: function(t) {
                        !1 === G.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), G.copy(t))
                    },
                    viewport: function(t) {
                        !1 === W.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), W.copy(t))
                    },
                    reset: function() {
                        e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === n && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), g = {}, B = null, F = {}, v = {}, _ = new WeakMap, x = [], y = null, M = !1, b = null, S = null, w = null, T = null, E = null, A = null, C = null, L = !1, P = null, R = null, I = null, D = null, N = null, G.set(0, 0, e.canvas.width, e.canvas.height), W.set(0, 0, e.canvas.width, e.canvas.height), r.reset(), a.reset(), s.reset()
                    }
                }
            }

            function rv(e, t, i, n, r, a, s) {
                let o;
                let l = r.isWebGL2,
                    h = r.maxTextures,
                    u = r.maxCubemapSize,
                    c = r.maxTextureSize,
                    d = r.maxSamples,
                    p = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
                    f = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
                    m = new WeakMap,
                    g = new WeakMap,
                    v = !1;
                try {
                    v = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (_) {}

                function x(e, t) {
                    return v ? new OffscreenCanvas(e, t) : eo("canvas")
                }

                function R(e, t, i, n) {
                    let r = 1;
                    if ((e.width > n || e.height > n) && (r = n / Math.max(e.width, e.height)), r < 1 || !0 === t) {
                        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                            let a = t ? $ : Math.floor,
                                s = a(r * e.width),
                                l = a(r * e.height);
                            void 0 === o && (o = x(s, l));
                            let h = i ? x(s, l) : o;
                            h.width = s, h.height = l;
                            let u = h.getContext("2d");
                            return u.drawImage(e, 0, 0, s, l), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + l + ")."), h
                        }
                        "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ").")
                    }
                    return e
                }

                function I(e) {
                    return K(e.width) && K(e.height)
                }

                function D(e, t) {
                    return e.generateMipmaps && t && e.minFilter !== S && e.minFilter !== E
                }

                function N(t) {
                    e.generateMipmap(t)
                }

                function U(i, n, r, a, s = !1) {
                    if (!1 === l) return n;
                    if (null !== i) {
                        if (void 0 !== e[i]) return e[i];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'")
                    }
                    let o = n;
                    return 6403 === n && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 33319 === n && (5126 === r && (o = 33328), 5131 === r && (o = 33327), 5121 === r && (o = 33323)), 6408 === n && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = a === z && !1 === s ? 35907 : 32856), 32819 === r && (o = 32854), 32820 === r && (o = 32855)), (33325 === o || 33326 === o || 33327 === o || 33328 === o || 34842 === o || 34836 === o) && t.get("EXT_color_buffer_float"), o
                }

                function B(e, t, i) {
                    return !0 === D(e, i) || e.isFramebufferTexture && e.minFilter !== S && e.minFilter !== E ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
                }

                function F(e) {
                    return e === S || e === w || e === T ? 9728 : 9729
                }

                function k(e) {
                    let t = e.target;
                    t.removeEventListener("dispose", k),
                        function(e) {
                            let t = n.get(e);
                            if (void 0 === t.__webglInit) return;
                            let i = e.source,
                                r = g.get(i);
                            if (r) {
                                let a = r[t.__cacheKey];
                                a.usedTimes--, 0 === a.usedTimes && G(e), 0 === Object.keys(r).length && g.delete(i)
                            }
                            n.remove(e)
                        }(t), t.isVideoTexture && m.delete(t)
                }

                function V(t) {
                    let i = t.target;
                    i.removeEventListener("dispose", V),
                        function(t) {
                            let i = t.texture,
                                r = n.get(t),
                                a = n.get(i);
                            if (void 0 !== a.__webglTexture && (e.deleteTexture(a.__webglTexture), s.memory.textures--), t.depthTexture && t.depthTexture.dispose(), t.isWebGLCubeRenderTarget)
                                for (let o = 0; o < 6; o++) e.deleteFramebuffer(r.__webglFramebuffer[o]), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[o]);
                            else {
                                if (e.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && e.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer)
                                    for (let l = 0; l < r.__webglColorRenderbuffer.length; l++) r.__webglColorRenderbuffer[l] && e.deleteRenderbuffer(r.__webglColorRenderbuffer[l]);
                                r.__webglDepthRenderbuffer && e.deleteRenderbuffer(r.__webglDepthRenderbuffer)
                            }
                            if (t.isWebGLMultipleRenderTargets)
                                for (let h = 0, u = i.length; h < u; h++) {
                                    let c = n.get(i[h]);
                                    c.__webglTexture && (e.deleteTexture(c.__webglTexture), s.memory.textures--), n.remove(i[h])
                                }
                            n.remove(i), n.remove(t)
                        }(i)
                }

                function G(t) {
                    let i = n.get(t);
                    e.deleteTexture(i.__webglTexture);
                    let r = t.source,
                        a = g.get(r);
                    delete a[i.__cacheKey], s.memory.textures--
                }
                let W = 0;

                function H(e, t) {
                    let r = n.get(e);
                    if (e.isVideoTexture && function(e) {
                            let t = s.render.frame;
                            m.get(e) !== t && (m.set(e, t), e.update())
                        }(e), !1 === e.isRenderTargetTexture && e.version > 0 && r.__version !== e.version) {
                        let a = e.image;
                        if (null === a) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                        else if (!1 === a.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                        else {
                            Y(r, e, t);
                            return
                        }
                    }
                    i.bindTexture(3553, r.__webglTexture, 33984 + t)
                }
                let j = {
                        [y]: 10497,
                        [M]: 33071,
                        [b]: 33648
                    },
                    q = {
                        [S]: 9728,
                        [w]: 9984,
                        [T]: 9986,
                        [E]: 9729,
                        [A]: 9985,
                        [C]: 9987
                    };

                function X(i, a, s) {
                    if (s ? (e.texParameteri(i, 10242, j[a.wrapS]), e.texParameteri(i, 10243, j[a.wrapT]), (32879 === i || 35866 === i) && e.texParameteri(i, 32882, j[a.wrapR]), e.texParameteri(i, 10240, q[a.magFilter]), e.texParameteri(i, 10241, q[a.minFilter])) : (e.texParameteri(i, 10242, 33071), e.texParameteri(i, 10243, 33071), (32879 === i || 35866 === i) && e.texParameteri(i, 32882, 33071), (a.wrapS !== M || a.wrapT !== M) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(i, 10240, F(a.magFilter)), e.texParameteri(i, 10241, F(a.minFilter)), a.minFilter !== S && a.minFilter !== E && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) {
                        let o = t.get("EXT_texture_filter_anisotropic");
                        a.magFilter !== S && (a.minFilter === T || a.minFilter === C) && (a.type !== L || !1 !== t.has("OES_texture_float_linear")) && (!1 !== l || 1016 !== a.type || !1 !== t.has("OES_texture_half_float_linear")) && (a.anisotropy > 1 || n.get(a).__currentAnisotropy) && (e.texParameterf(i, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), n.get(a).__currentAnisotropy = a.anisotropy)
                    }
                }

                function J(t, i) {
                    let n = !1;
                    void 0 === t.__webglInit && (t.__webglInit = !0, i.addEventListener("dispose", k));
                    let r = i.source,
                        a = g.get(r);
                    void 0 === a && (a = {}, g.set(r, a));
                    let o = function(e) {
                        let t = [];
                        return t.push(e.wrapS), t.push(e.wrapT), t.push(e.wrapR || 0), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.encoding), t.join()
                    }(i);
                    if (o !== t.__cacheKey) {
                        void 0 === a[o] && (a[o] = {
                            texture: e.createTexture(),
                            usedTimes: 0
                        }, s.memory.textures++, n = !0), a[o].usedTimes++;
                        let l = a[t.__cacheKey];
                        void 0 !== l && (a[t.__cacheKey].usedTimes--, 0 === l.usedTimes && G(i)), t.__cacheKey = o, t.__webglTexture = a[o].texture
                    }
                    return n
                }

                function Y(t, r, s) {
                    let o = 3553;
                    (r.isDataArrayTexture || r.isCompressedArrayTexture) && (o = 35866), r.isData3DTexture && (o = 32879);
                    let h = J(t, r),
                        u = r.source;
                    i.bindTexture(o, t.__webglTexture, 33984 + s);
                    let d = n.get(u);
                    if (u.version !== d.__version || !0 === h) {
                        let p;
                        i.activeTexture(33984 + s), e.pixelStorei(37440, r.flipY), e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment), e.pixelStorei(37443, 0);
                        let f = !l && (r.wrapS !== M || r.wrapT !== M || r.minFilter !== S && r.minFilter !== E) && !1 === I(r.image),
                            m = R(r.image, f, !1, c);
                        m = en(r, m);
                        let g = I(m) || l,
                            v = a.convert(r.format, r.encoding),
                            _ = a.convert(r.type),
                            x = U(r.internalFormat, v, _, r.encoding, r.isVideoTexture);
                        X(o, r, g);
                        let y = r.mipmaps,
                            b = l && !0 !== r.isVideoTexture,
                            w = void 0 === d.__version || !0 === h,
                            T = B(r, m, g);
                        if (r.isDepthTexture) x = 6402, l ? x = r.type === L ? 36012 : 1014 === r.type ? 33190 : 1020 === r.type ? 35056 : 33189 : r.type === L && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === r.format && 6402 === x && 1012 !== r.type && 1014 !== r.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = 1014, _ = a.convert(r.type)), 1027 === r.format && 6402 === x && (x = 34041, 1020 !== r.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = 1020, _ = a.convert(r.type))), w && (b ? i.texStorage2D(3553, 1, x, m.width, m.height) : i.texImage2D(3553, 0, x, m.width, m.height, 0, v, _, null));
                        else if (r.isDataTexture) {
                            if (y.length > 0 && g) {
                                b && w && i.texStorage2D(3553, T, x, y[0].width, y[0].height);
                                for (let A = 0, C = y.length; A < C; A++) p = y[A], b ? i.texSubImage2D(3553, A, 0, 0, p.width, p.height, v, _, p.data) : i.texImage2D(3553, A, x, p.width, p.height, 0, v, _, p.data);
                                r.generateMipmaps = !1
                            } else b ? (w && i.texStorage2D(3553, T, x, m.width, m.height), i.texSubImage2D(3553, 0, 0, 0, m.width, m.height, v, _, m.data)) : i.texImage2D(3553, 0, x, m.width, m.height, 0, v, _, m.data)
                        } else if (r.isCompressedTexture) {
                            if (r.isCompressedArrayTexture) {
                                b && w && i.texStorage3D(35866, T, x, y[0].width, y[0].height, m.depth);
                                for (let O = 0, z = y.length; O < z; O++) p = y[O], r.format !== P ? null !== v ? b ? i.compressedTexSubImage3D(35866, O, 0, 0, 0, p.width, p.height, m.depth, v, p.data, 0, 0) : i.compressedTexImage3D(35866, O, x, p.width, p.height, m.depth, 0, p.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : b ? i.texSubImage3D(35866, O, 0, 0, 0, p.width, p.height, m.depth, v, _, p.data) : i.texImage3D(35866, O, x, p.width, p.height, m.depth, 0, v, _, p.data)
                            } else {
                                b && w && i.texStorage2D(3553, T, x, y[0].width, y[0].height);
                                for (let F = 0, k = y.length; F < k; F++) p = y[F], r.format !== P ? null !== v ? b ? i.compressedTexSubImage2D(3553, F, 0, 0, p.width, p.height, v, p.data) : i.compressedTexImage2D(3553, F, x, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : b ? i.texSubImage2D(3553, F, 0, 0, p.width, p.height, v, _, p.data) : i.texImage2D(3553, F, x, p.width, p.height, 0, v, _, p.data)
                            }
                        } else if (r.isDataArrayTexture) b ? (w && i.texStorage3D(35866, T, x, m.width, m.height, m.depth), i.texSubImage3D(35866, 0, 0, 0, 0, m.width, m.height, m.depth, v, _, m.data)) : i.texImage3D(35866, 0, x, m.width, m.height, m.depth, 0, v, _, m.data);
                        else if (r.isData3DTexture) b ? (w && i.texStorage3D(32879, T, x, m.width, m.height, m.depth), i.texSubImage3D(32879, 0, 0, 0, 0, m.width, m.height, m.depth, v, _, m.data)) : i.texImage3D(32879, 0, x, m.width, m.height, m.depth, 0, v, _, m.data);
                        else if (r.isFramebufferTexture) {
                            if (w) {
                                if (b) i.texStorage2D(3553, T, x, m.width, m.height);
                                else {
                                    let V = m.width,
                                        G = m.height;
                                    for (let W = 0; W < T; W++) i.texImage2D(3553, W, x, V, G, 0, v, _, null), V >>= 1, G >>= 1
                                }
                            }
                        } else if (y.length > 0 && g) {
                            b && w && i.texStorage2D(3553, T, x, y[0].width, y[0].height);
                            for (let H = 0, j = y.length; H < j; H++) p = y[H], b ? i.texSubImage2D(3553, H, 0, 0, v, _, p) : i.texImage2D(3553, H, x, v, _, p);
                            r.generateMipmaps = !1
                        } else b ? (w && i.texStorage2D(3553, T, x, m.width, m.height), i.texSubImage2D(3553, 0, 0, 0, v, _, m)) : i.texImage2D(3553, 0, x, v, _, m);
                        D(r, g) && N(o), d.__version = u.version, r.onUpdate && r.onUpdate(r)
                    }
                    t.__version = r.version
                }

                function Z(t, r, s, o, l) {
                    let h = a.convert(s.format, s.encoding),
                        u = a.convert(s.type),
                        c = U(s.internalFormat, h, u, s.encoding),
                        d = n.get(r);
                    d.__hasExternalTextures || (32879 === l || 35866 === l ? i.texImage3D(l, 0, c, r.width, r.height, r.depth, 0, h, u, null) : i.texImage2D(l, 0, c, r.width, r.height, 0, h, u, null)), i.bindFramebuffer(36160, t), ei(r) ? p.framebufferTexture2DMultisampleEXT(36160, o, l, n.get(s).__webglTexture, 0, et(r)) : (3553 === l || l >= 34069 && l <= 34074) && e.framebufferTexture2D(36160, o, l, n.get(s).__webglTexture, 0), i.bindFramebuffer(36160, null)
                }

                function Q(t, i, n) {
                    if (e.bindRenderbuffer(36161, t), i.depthBuffer && !i.stencilBuffer) {
                        let r = 33189;
                        if (n || ei(i)) {
                            let s = i.depthTexture;
                            s && s.isDepthTexture && (s.type === L ? r = 36012 : 1014 === s.type && (r = 33190));
                            let o = et(i);
                            ei(i) ? p.renderbufferStorageMultisampleEXT(36161, o, r, i.width, i.height) : e.renderbufferStorageMultisample(36161, o, r, i.width, i.height)
                        } else e.renderbufferStorage(36161, r, i.width, i.height);
                        e.framebufferRenderbuffer(36160, 36096, 36161, t)
                    } else if (i.depthBuffer && i.stencilBuffer) {
                        let l = et(i);
                        n && !1 === ei(i) ? e.renderbufferStorageMultisample(36161, l, 35056, i.width, i.height) : ei(i) ? p.renderbufferStorageMultisampleEXT(36161, l, 35056, i.width, i.height) : e.renderbufferStorage(36161, 34041, i.width, i.height), e.framebufferRenderbuffer(36160, 33306, 36161, t)
                    } else {
                        let h = !0 === i.isWebGLMultipleRenderTargets ? i.texture : [i.texture];
                        for (let u = 0; u < h.length; u++) {
                            let c = h[u],
                                d = a.convert(c.format, c.encoding),
                                f = a.convert(c.type),
                                m = U(c.internalFormat, d, f, c.encoding),
                                g = et(i);
                            n && !1 === ei(i) ? e.renderbufferStorageMultisample(36161, g, m, i.width, i.height) : ei(i) ? p.renderbufferStorageMultisampleEXT(36161, g, m, i.width, i.height) : e.renderbufferStorage(36161, m, i.width, i.height)
                        }
                    }
                    e.bindRenderbuffer(36161, null)
                }

                function ee(t) {
                    let r = n.get(t),
                        a = !0 === t.isWebGLCubeRenderTarget;
                    if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
                        if (a) throw Error("target.depthTexture not supported in Cube render targets");
                        ! function(t, r) {
                            let a = r && r.isWebGLCubeRenderTarget;
                            if (a) throw Error("Depth Texture with cube render targets is not supported");
                            if (i.bindFramebuffer(36160, t), !(r.depthTexture && r.depthTexture.isDepthTexture)) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), H(r.depthTexture, 0);
                            let s = n.get(r.depthTexture).__webglTexture,
                                o = et(r);
                            if (1026 === r.depthTexture.format) ei(r) ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, o) : e.framebufferTexture2D(36160, 36096, 3553, s, 0);
                            else if (1027 === r.depthTexture.format) ei(r) ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, o) : e.framebufferTexture2D(36160, 33306, 3553, s, 0);
                            else throw Error("Unknown depthTexture format")
                        }(r.__webglFramebuffer, t)
                    } else if (a) {
                        r.__webglDepthbuffer = [];
                        for (let s = 0; s < 6; s++) i.bindFramebuffer(36160, r.__webglFramebuffer[s]), r.__webglDepthbuffer[s] = e.createRenderbuffer(), Q(r.__webglDepthbuffer[s], t, !1)
                    } else i.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = e.createRenderbuffer(), Q(r.__webglDepthbuffer, t, !1);
                    i.bindFramebuffer(36160, null)
                }

                function et(e) {
                    return Math.min(d, e.samples)
                }

                function ei(e) {
                    let i = n.get(e);
                    return l && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== i.__useRenderToTexture
                }

                function en(e, i) {
                    let n = e.encoding,
                        r = e.format,
                        a = e.type;
                    return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || 1035 === e.format || n !== O && (n === z ? !1 === l ? !0 === t.has("EXT_sRGB") && r === P ? (e.format = 1035, e.minFilter = E, e.generateMipmaps = !1) : i = ex.sRGBToLinear(i) : (r !== P || 1009 !== a) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", n)), i
                }
                this.allocateTextureUnit = function() {
                    let e = W;
                    return e >= h && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + h), W += 1, e
                }, this.resetTextureUnits = function() {
                    W = 0
                }, this.setTexture2D = H, this.setTexture2DArray = function(e, t) {
                    let r = n.get(e);
                    if (e.version > 0 && r.__version !== e.version) {
                        Y(r, e, t);
                        return
                    }
                    i.bindTexture(35866, r.__webglTexture, 33984 + t)
                }, this.setTexture3D = function(e, t) {
                    let r = n.get(e);
                    if (e.version > 0 && r.__version !== e.version) {
                        Y(r, e, t);
                        return
                    }
                    i.bindTexture(32879, r.__webglTexture, 33984 + t)
                }, this.setTextureCube = function(t, r) {
                    let s = n.get(t);
                    if (t.version > 0 && s.__version !== t.version) {
                        (function(t, r, s) {
                            if (6 !== r.image.length) return;
                            let o = J(t, r),
                                h = r.source;
                            i.bindTexture(34067, t.__webglTexture, 33984 + s);
                            let c = n.get(h);
                            if (h.version !== c.__version || !0 === o) {
                                let d;
                                i.activeTexture(33984 + s), e.pixelStorei(37440, r.flipY), e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment), e.pixelStorei(37443, 0);
                                let p = r.isCompressedTexture || r.image[0].isCompressedTexture,
                                    f = r.image[0] && r.image[0].isDataTexture,
                                    m = [];
                                for (let g = 0; g < 6; g++) p || f ? m[g] = f ? r.image[g].image : r.image[g] : m[g] = R(r.image[g], !1, !0, u), m[g] = en(r, m[g]);
                                let v = m[0],
                                    _ = I(v) || l,
                                    x = a.convert(r.format, r.encoding),
                                    y = a.convert(r.type),
                                    M = U(r.internalFormat, x, y, r.encoding),
                                    b = l && !0 !== r.isVideoTexture,
                                    S = void 0 === c.__version || !0 === o,
                                    w = B(r, v, _);
                                if (X(34067, r, _), p) {
                                    b && S && i.texStorage2D(34067, w, M, v.width, v.height);
                                    for (let T = 0; T < 6; T++) {
                                        d = m[T].mipmaps;
                                        for (let E = 0; E < d.length; E++) {
                                            let A = d[E];
                                            r.format !== P ? null !== x ? b ? i.compressedTexSubImage2D(34069 + T, E, 0, 0, A.width, A.height, x, A.data) : i.compressedTexImage2D(34069 + T, E, M, A.width, A.height, 0, A.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : b ? i.texSubImage2D(34069 + T, E, 0, 0, A.width, A.height, x, y, A.data) : i.texImage2D(34069 + T, E, M, A.width, A.height, 0, x, y, A.data)
                                        }
                                    }
                                } else {
                                    d = r.mipmaps, b && S && (d.length > 0 && w++, i.texStorage2D(34067, w, M, m[0].width, m[0].height));
                                    for (let C = 0; C < 6; C++)
                                        if (f) {
                                            b ? i.texSubImage2D(34069 + C, 0, 0, 0, m[C].width, m[C].height, x, y, m[C].data) : i.texImage2D(34069 + C, 0, M, m[C].width, m[C].height, 0, x, y, m[C].data);
                                            for (let L = 0; L < d.length; L++) {
                                                let O = d[L],
                                                    z = O.image[C].image;
                                                b ? i.texSubImage2D(34069 + C, L + 1, 0, 0, z.width, z.height, x, y, z.data) : i.texImage2D(34069 + C, L + 1, M, z.width, z.height, 0, x, y, z.data)
                                            }
                                        } else {
                                            b ? i.texSubImage2D(34069 + C, 0, 0, 0, x, y, m[C]) : i.texImage2D(34069 + C, 0, M, x, y, m[C]);
                                            for (let F = 0; F < d.length; F++) {
                                                let k = d[F];
                                                b ? i.texSubImage2D(34069 + C, F + 1, 0, 0, x, y, k.image[C]) : i.texImage2D(34069 + C, F + 1, M, x, y, k.image[C])
                                            }
                                        }
                                }
                                D(r, _) && N(34067), c.__version = h.version, r.onUpdate && r.onUpdate(r)
                            }
                            t.__version = r.version
                        })(s, t, r);
                        return
                    }
                    i.bindTexture(34067, s.__webglTexture, 33984 + r)
                }, this.rebindTextures = function(e, t, i) {
                    let r = n.get(e);
                    void 0 !== t && Z(r.__webglFramebuffer, e, e.texture, 36064, 3553), void 0 !== i && ee(e)
                }, this.setupRenderTarget = function(t) {
                    let o = t.texture,
                        h = n.get(t),
                        u = n.get(o);
                    t.addEventListener("dispose", V), !0 !== t.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = e.createTexture()), u.__version = o.version, s.memory.textures++);
                    let c = !0 === t.isWebGLCubeRenderTarget,
                        d = !0 === t.isWebGLMultipleRenderTargets,
                        p = I(t) || l;
                    if (c) {
                        h.__webglFramebuffer = [];
                        for (let f = 0; f < 6; f++) h.__webglFramebuffer[f] = e.createFramebuffer()
                    } else {
                        if (h.__webglFramebuffer = e.createFramebuffer(), d) {
                            if (r.drawBuffers) {
                                let m = t.texture;
                                for (let g = 0, v = m.length; g < v; g++) {
                                    let _ = n.get(m[g]);
                                    void 0 === _.__webglTexture && (_.__webglTexture = e.createTexture(), s.memory.textures++)
                                }
                            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.")
                        }
                        if (l && t.samples > 0 && !1 === ei(t)) {
                            let x = d ? o : [o];
                            h.__webglMultisampledFramebuffer = e.createFramebuffer(), h.__webglColorRenderbuffer = [], i.bindFramebuffer(36160, h.__webglMultisampledFramebuffer);
                            for (let y = 0; y < x.length; y++) {
                                let M = x[y];
                                h.__webglColorRenderbuffer[y] = e.createRenderbuffer(), e.bindRenderbuffer(36161, h.__webglColorRenderbuffer[y]);
                                let b = a.convert(M.format, M.encoding),
                                    S = a.convert(M.type),
                                    w = U(M.internalFormat, b, S, M.encoding, !0 === t.isXRRenderTarget),
                                    T = et(t);
                                e.renderbufferStorageMultisample(36161, T, w, t.width, t.height), e.framebufferRenderbuffer(36160, 36064 + y, 36161, h.__webglColorRenderbuffer[y])
                            }
                            e.bindRenderbuffer(36161, null), t.depthBuffer && (h.__webglDepthRenderbuffer = e.createRenderbuffer(), Q(h.__webglDepthRenderbuffer, t, !0)), i.bindFramebuffer(36160, null)
                        }
                    }
                    if (c) {
                        i.bindTexture(34067, u.__webglTexture), X(34067, o, p);
                        for (let E = 0; E < 6; E++) Z(h.__webglFramebuffer[E], t, o, 36064, 34069 + E);
                        D(o, p) && N(34067), i.unbindTexture()
                    } else if (d) {
                        let A = t.texture;
                        for (let C = 0, L = A.length; C < L; C++) {
                            let P = A[C],
                                R = n.get(P);
                            i.bindTexture(3553, R.__webglTexture), X(3553, P, p), Z(h.__webglFramebuffer, t, P, 36064 + C, 3553), D(P, p) && N(3553)
                        }
                        i.unbindTexture()
                    } else {
                        let O = 3553;
                        (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (l ? O = t.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), i.bindTexture(O, u.__webglTexture), X(O, o, p), Z(h.__webglFramebuffer, t, o, 36064, O), D(o, p) && N(O), i.unbindTexture()
                    }
                    t.depthBuffer && ee(t)
                }, this.updateRenderTargetMipmap = function(e) {
                    let t = I(e) || l,
                        r = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
                    for (let a = 0, s = r.length; a < s; a++) {
                        let o = r[a];
                        if (D(o, t)) {
                            let h = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                                u = n.get(o).__webglTexture;
                            i.bindTexture(h, u), N(h), i.unbindTexture()
                        }
                    }
                }, this.updateMultisampleRenderTarget = function(t) {
                    if (l && t.samples > 0 && !1 === ei(t)) {
                        let r = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture],
                            a = t.width,
                            s = t.height,
                            o = 16384,
                            h = [],
                            u = t.stencilBuffer ? 33306 : 36096,
                            c = n.get(t),
                            d = !0 === t.isWebGLMultipleRenderTargets;
                        if (d)
                            for (let p = 0; p < r.length; p++) i.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064 + p, 36161, null), i.bindFramebuffer(36160, c.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + p, 3553, null, 0);
                        i.bindFramebuffer(36008, c.__webglMultisampledFramebuffer), i.bindFramebuffer(36009, c.__webglFramebuffer);
                        for (let m = 0; m < r.length; m++) {
                            h.push(36064 + m), t.depthBuffer && h.push(u);
                            let g = void 0 !== c.__ignoreDepthValues && c.__ignoreDepthValues;
                            if (!1 === g && (t.depthBuffer && (o |= 256), t.stencilBuffer && (o |= 1024)), d && e.framebufferRenderbuffer(36008, 36064, 36161, c.__webglColorRenderbuffer[m]), !0 === g && (e.invalidateFramebuffer(36008, [u]), e.invalidateFramebuffer(36009, [u])), d) {
                                let v = n.get(r[m]).__webglTexture;
                                e.framebufferTexture2D(36009, 36064, 3553, v, 0)
                            }
                            e.blitFramebuffer(0, 0, a, s, 0, 0, a, s, o, 9728), f && e.invalidateFramebuffer(36008, h)
                        }
                        if (i.bindFramebuffer(36008, null), i.bindFramebuffer(36009, null), d)
                            for (let _ = 0; _ < r.length; _++) {
                                i.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064 + _, 36161, c.__webglColorRenderbuffer[_]);
                                let x = n.get(r[_]).__webglTexture;
                                i.bindFramebuffer(36160, c.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + _, 3553, x, 0)
                            }
                        i.bindFramebuffer(36009, c.__webglMultisampledFramebuffer)
                    }
                }, this.setupDepthRenderbuffer = ee, this.setupFrameBufferTexture = Z, this.useMultisampledRTT = ei
            }

            function r_(e, t, i) {
                let n = i.isWebGL2;
                return {
                    convert: function(i, r = null) {
                        let a;
                        if (1009 === i) return 5121;
                        if (1017 === i) return 32819;
                        if (1018 === i) return 32820;
                        if (1010 === i) return 5120;
                        if (1011 === i) return 5122;
                        if (1012 === i) return 5123;
                        if (1013 === i) return 5124;
                        if (1014 === i) return 5125;
                        if (i === L) return 5126;
                        if (1016 === i) return n ? 5131 : null !== (a = t.get("OES_texture_half_float")) ? a.HALF_FLOAT_OES : null;
                        if (1021 === i) return 6406;
                        if (i === P) return 6408;
                        if (1024 === i) return 6409;
                        if (1025 === i) return 6410;
                        if (1026 === i) return 6402;
                        if (1027 === i) return 34041;
                        if (1022 === i) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
                        if (1035 === i) return null !== (a = t.get("EXT_sRGB")) ? a.SRGB_ALPHA_EXT : null;
                        if (1028 === i) return 6403;
                        if (1029 === i) return 36244;
                        if (1030 === i) return 33319;
                        if (1031 === i) return 33320;
                        if (1033 === i) return 36249;
                        if (33776 === i || 33777 === i || 33778 === i || 33779 === i) {
                            if (r === z) {
                                if (null === (a = t.get("WEBGL_compressed_texture_s3tc_srgb"))) return null;
                                if (33776 === i) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                if (33777 === i) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                if (33778 === i) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                if (33779 === i) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                            } else {
                                if (null === (a = t.get("WEBGL_compressed_texture_s3tc"))) return null;
                                if (33776 === i) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (33777 === i) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (33778 === i) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (33779 === i) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            }
                        }
                        if (35840 === i || 35841 === i || 35842 === i || 35843 === i) {
                            if (null === (a = t.get("WEBGL_compressed_texture_pvrtc"))) return null;
                            if (35840 === i) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (35841 === i) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (35842 === i) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (35843 === i) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (36196 === i) return null !== (a = t.get("WEBGL_compressed_texture_etc1")) ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if (37492 === i || 37496 === i) {
                            if (null === (a = t.get("WEBGL_compressed_texture_etc"))) return null;
                            if (37492 === i) return r === z ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                            if (37496 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        if (37808 === i || 37809 === i || 37810 === i || 37811 === i || 37812 === i || 37813 === i || 37814 === i || 37815 === i || 37816 === i || 37817 === i || 37818 === i || 37819 === i || 37820 === i || 37821 === i) {
                            if (null === (a = t.get("WEBGL_compressed_texture_astc"))) return null;
                            if (37808 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                            if (37809 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                            if (37810 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                            if (37811 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                            if (37812 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                            if (37813 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                            if (37814 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                            if (37815 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                            if (37816 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                            if (37817 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                            if (37818 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                            if (37819 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                            if (37820 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                            if (37821 === i) return r === z ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
                        }
                        if (36492 === i) {
                            if (null === (a = t.get("EXT_texture_compression_bptc"))) return null;
                            if (36492 === i) return r === z ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
                        }
                        return 1020 === i ? n ? 34042 : null !== (a = t.get("WEBGL_depth_texture")) ? a.UNSIGNED_INT_24_8_WEBGL : null : void 0 !== e[i] ? e[i] : null
                    }
                }
            }
            class rx extends io {
                constructor(e = []) {
                    super(), this.isArrayCamera = !0, this.cameras = e
                }
            }
            class ry extends tx {
                constructor() {
                    super(), this.isGroup = !0, this.type = "Group"
                }
            }
            let rM = {
                type: "move"
            };
            class rb {
                constructor() {
                    this._targetRay = null, this._grip = null, this._hand = null
                }
                getHandSpace() {
                    return null === this._hand && (this._hand = new ry, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                        pinching: !1
                    }), this._hand
                }
                getTargetRaySpace() {
                    return null === this._targetRay && (this._targetRay = new ry, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new eC, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new eC), this._targetRay
                }
                getGripSpace() {
                    return null === this._grip && (this._grip = new ry, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new eC, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new eC), this._grip
                }
                dispatchEvent(e) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
                }
                connect(e) {
                    if (e && e.hand) {
                        let t = this._hand;
                        if (t)
                            for (let i of e.hand.values()) this._getHandJoint(t, i)
                    }
                    return this.dispatchEvent({
                        type: "connected",
                        data: e
                    }), this
                }
                disconnect(e) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: e
                    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                }
                update(e, t, i) {
                    let n = null,
                        r = null,
                        a = null,
                        s = this._targetRay,
                        o = this._grip,
                        l = this._hand;
                    if (e && "visible-blurred" !== t.session.visibilityState) {
                        if (l && e.hand) {
                            for (let h of (a = !0, e.hand.values())) {
                                let u = t.getJointPose(h, i),
                                    c = this._getHandJoint(l, h);
                                null !== u && (c.matrix.fromArray(u.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.jointRadius = u.radius), c.visible = null !== u
                            }
                            let d = l.joints["index-finger-tip"],
                                p = l.joints["thumb-tip"],
                                f = d.position.distanceTo(p.position);
                            l.inputState.pinching && f > .025 ? (l.inputState.pinching = !1, this.dispatchEvent({
                                type: "pinchend",
                                handedness: e.handedness,
                                target: this
                            })) : !l.inputState.pinching && f <= .015 && (l.inputState.pinching = !0, this.dispatchEvent({
                                type: "pinchstart",
                                handedness: e.handedness,
                                target: this
                            }))
                        } else null !== o && e.gripSpace && null !== (r = t.getPose(e.gripSpace, i)) && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1);
                        null !== s && (null === (n = t.getPose(e.targetRaySpace, i)) && null !== r && (n = r), null !== n && (s.matrix.fromArray(n.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), n.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(n.linearVelocity)) : s.hasLinearVelocity = !1, n.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(n.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(rM)))
                    }
                    return null !== s && (s.visible = null !== n), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== a), this
                }
                _getHandJoint(e, t) {
                    if (void 0 === e.joints[t.jointName]) {
                        let i = new ry;
                        i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i)
                    }
                    return e.joints[t.jointName]
                }
            }
            class rS extends eS {
                constructor(e, t, i, n, r, a, s, o, l, h) {
                    if (1026 !== (h = void 0 !== h ? h : 1026) && 1027 !== h) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    void 0 === i && 1026 === h && (i = 1014), void 0 === i && 1027 === h && (i = 1020), super(null, n, r, a, s, o, h, i, l), this.isDepthTexture = !0, this.image = {
                        width: e,
                        height: t
                    }, this.magFilter = void 0 !== s ? s : S, this.minFilter = void 0 !== o ? o : S, this.flipY = !1, this.generateMipmaps = !1
                }
            }
            class rw extends G {
                constructor(e, t) {
                    super();
                    let i = this,
                        n = null,
                        r = 1,
                        a = null,
                        s = "local-floor",
                        o = null,
                        l = null,
                        h = null,
                        u = null,
                        c = null,
                        d = null,
                        p = t.getContextAttributes(),
                        f = null,
                        m = null,
                        g = [],
                        v = [],
                        _ = new Set,
                        x = new Map,
                        y = new io;
                    y.layers.enable(1), y.viewport = new ew;
                    let M = new io;
                    M.layers.enable(2), M.viewport = new ew;
                    let b = [y, M],
                        S = new rx;
                    S.layers.enable(1), S.layers.enable(2);
                    let w = null,
                        T = null;

                    function E(e) {
                        let t = v.indexOf(e.inputSource);
                        if (-1 === t) return;
                        let i = g[t];
                        void 0 !== i && i.dispatchEvent({
                            type: e.type,
                            data: e.inputSource
                        })
                    }

                    function A() {
                        n.removeEventListener("select", E), n.removeEventListener("selectstart", E), n.removeEventListener("selectend", E), n.removeEventListener("squeeze", E), n.removeEventListener("squeezestart", E), n.removeEventListener("squeezeend", E), n.removeEventListener("end", A), n.removeEventListener("inputsourceschange", C);
                        for (let t = 0; t < g.length; t++) {
                            let r = v[t];
                            null !== r && (v[t] = null, g[t].disconnect(r))
                        }
                        w = null, T = null, e.setRenderTarget(f), c = null, u = null, h = null, n = null, m = null, N.stop(), i.isPresenting = !1, i.dispatchEvent({
                            type: "sessionend"
                        })
                    }

                    function C(e) {
                        for (let t = 0; t < e.removed.length; t++) {
                            let i = e.removed[t],
                                n = v.indexOf(i);
                            n >= 0 && (v[n] = null, g[n].disconnect(i))
                        }
                        for (let r = 0; r < e.added.length; r++) {
                            let a = e.added[r],
                                s = v.indexOf(a);
                            if (-1 === s) {
                                for (let o = 0; o < g.length; o++) {
                                    if (o >= v.length) {
                                        v.push(a), s = o;
                                        break
                                    }
                                    if (null === v[o]) {
                                        v[o] = a, s = o;
                                        break
                                    }
                                }
                                if (-1 === s) break
                            }
                            let l = g[s];
                            l && l.connect(a)
                        }
                    }
                    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
                        let t = g[e];
                        return void 0 === t && (t = new rb, g[e] = t), t.getTargetRaySpace()
                    }, this.getControllerGrip = function(e) {
                        let t = g[e];
                        return void 0 === t && (t = new rb, g[e] = t), t.getGripSpace()
                    }, this.getHand = function(e) {
                        let t = g[e];
                        return void 0 === t && (t = new rb, g[e] = t), t.getHandSpace()
                    }, this.setFramebufferScaleFactor = function(e) {
                        r = e, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                    }, this.setReferenceSpaceType = function(e) {
                        s = e, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                    }, this.getReferenceSpace = function() {
                        return o || a
                    }, this.setReferenceSpace = function(e) {
                        o = e
                    }, this.getBaseLayer = function() {
                        return null !== u ? u : c
                    }, this.getBinding = function() {
                        return h
                    }, this.getFrame = function() {
                        return d
                    }, this.getSession = function() {
                        return n
                    }, this.setSession = async function(l) {
                        if (null !== (n = l)) {
                            if (f = e.getRenderTarget(), n.addEventListener("select", E), n.addEventListener("selectstart", E), n.addEventListener("selectend", E), n.addEventListener("squeeze", E), n.addEventListener("squeezestart", E), n.addEventListener("squeezeend", E), n.addEventListener("end", A), n.addEventListener("inputsourceschange", C), !0 !== p.xrCompatible && await t.makeXRCompatible(), void 0 === n.renderState.layers || !1 === e.capabilities.isWebGL2) {
                                let d = {
                                    antialias: void 0 !== n.renderState.layers || p.antialias,
                                    alpha: p.alpha,
                                    depth: p.depth,
                                    stencil: p.stencil,
                                    framebufferScaleFactor: r
                                };
                                c = new XRWebGLLayer(n, t, d), n.updateRenderState({
                                    baseLayer: c
                                }), m = new eT(c.framebufferWidth, c.framebufferHeight, {
                                    format: P,
                                    type: 1009,
                                    encoding: e.outputEncoding,
                                    stencilBuffer: p.stencil
                                })
                            } else {
                                let g = null,
                                    v = null,
                                    _ = null;
                                p.depth && (_ = p.stencil ? 35056 : 33190, g = p.stencil ? 1027 : 1026, v = p.stencil ? 1020 : 1014);
                                let x = {
                                    colorFormat: 32856,
                                    depthFormat: _,
                                    scaleFactor: r
                                };
                                u = (h = new XRWebGLBinding(n, t)).createProjectionLayer(x), n.updateRenderState({
                                    layers: [u]
                                }), m = new eT(u.textureWidth, u.textureHeight, {
                                    format: P,
                                    type: 1009,
                                    depthTexture: new rS(u.textureWidth, u.textureHeight, v, void 0, void 0, void 0, void 0, void 0, void 0, g),
                                    stencilBuffer: p.stencil,
                                    encoding: e.outputEncoding,
                                    samples: p.antialias ? 4 : 0
                                });
                                let y = e.properties.get(m);
                                y.__ignoreDepthValues = u.ignoreDepthValues
                            }
                            m.isXRRenderTarget = !0, this.setFoveation(1), o = null, a = await n.requestReferenceSpace(s), N.setContext(n), N.start(), i.isPresenting = !0, i.dispatchEvent({
                                type: "sessionstart"
                            })
                        }
                    };
                    let L = new eC,
                        R = new eC;

                    function I(e, t) {
                        null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
                    }
                    this.updateCamera = function(e) {
                        if (null === n) return;
                        S.near = M.near = y.near = e.near, S.far = M.far = y.far = e.far, (w !== S.near || T !== S.far) && (n.updateRenderState({
                            depthNear: S.near,
                            depthFar: S.far
                        }), w = S.near, T = S.far);
                        let t = e.parent,
                            i = S.cameras;
                        I(S, t);
                        for (let r = 0; r < i.length; r++) I(i[r], t);
                        S.matrixWorld.decompose(S.position, S.quaternion, S.scale), e.matrix.copy(S.matrix), e.matrix.decompose(e.position, e.quaternion, e.scale);
                        let a = e.children;
                        for (let s = 0, o = a.length; s < o; s++) a[s].updateMatrixWorld(!0);
                        2 === i.length ? function(e, t, i) {
                            L.setFromMatrixPosition(t.matrixWorld), R.setFromMatrixPosition(i.matrixWorld);
                            let n = L.distanceTo(R),
                                r = t.projectionMatrix.elements,
                                a = i.projectionMatrix.elements,
                                s = r[14] / (r[10] - 1),
                                o = r[14] / (r[10] + 1),
                                l = (r[9] + 1) / r[5],
                                h = (r[9] - 1) / r[5],
                                u = (r[8] - 1) / r[0],
                                c = (a[8] + 1) / a[0],
                                d = n / (-u + c),
                                p = -(d * u);
                            t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(p), e.translateZ(d), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
                            let f = s + d,
                                m = o + d;
                            e.projectionMatrix.makePerspective(s * u - p, s * c + (n - p), l * o / m * f, h * o / m * f, f, m)
                        }(S, y, M) : S.projectionMatrix.copy(y.projectionMatrix)
                    }, this.getCamera = function() {
                        return S
                    }, this.getFoveation = function() {
                        return null !== u ? u.fixedFoveation : null !== c ? c.fixedFoveation : void 0
                    }, this.setFoveation = function(e) {
                        null !== u && (u.fixedFoveation = e), null !== c && void 0 !== c.fixedFoveation && (c.fixedFoveation = e)
                    }, this.getPlanes = function() {
                        return _
                    };
                    let D = null,
                        N = new ix;
                    N.setAnimationLoop(function(t, n) {
                        if (l = n.getViewerPose(o || a), d = n, null !== l) {
                            let r = l.views;
                            null !== c && (e.setRenderTargetFramebuffer(m, c.framebuffer), e.setRenderTarget(m));
                            let s = !1;
                            r.length !== S.cameras.length && (S.cameras.length = 0, s = !0);
                            for (let p = 0; p < r.length; p++) {
                                let f = r[p],
                                    y = null;
                                if (null !== c) y = c.getViewport(f);
                                else {
                                    let M = h.getViewSubImage(u, f);
                                    y = M.viewport, 0 === p && (e.setRenderTargetTextures(m, M.colorTexture, u.ignoreDepthValues ? void 0 : M.depthStencilTexture), e.setRenderTarget(m))
                                }
                                let w = b[p];
                                void 0 === w && ((w = new io).layers.enable(p), w.viewport = new ew, b[p] = w), w.matrix.fromArray(f.transform.matrix), w.projectionMatrix.fromArray(f.projectionMatrix), w.viewport.set(y.x, y.y, y.width, y.height), 0 === p && S.matrix.copy(w.matrix), !0 === s && S.cameras.push(w)
                            }
                        }
                        for (let T = 0; T < g.length; T++) {
                            let E = v[T],
                                A = g[T];
                            null !== E && void 0 !== A && A.update(E, n, o || a)
                        }
                        if (D && D(t, n), n.detectedPlanes) {
                            i.dispatchEvent({
                                type: "planesdetected",
                                data: n.detectedPlanes
                            });
                            let C = null;
                            for (let L of _) n.detectedPlanes.has(L) || (null === C && (C = []), C.push(L));
                            if (null !== C)
                                for (let P of C) _.delete(P), x.delete(P), i.dispatchEvent({
                                    type: "planeremoved",
                                    data: P
                                });
                            for (let R of n.detectedPlanes)
                                if (_.has(R)) {
                                    let I = x.get(R);
                                    R.lastChangedTime > I && (x.set(R, R.lastChangedTime), i.dispatchEvent({
                                        type: "planechanged",
                                        data: R
                                    }))
                                } else _.add(R), x.set(R, n.lastChangedTime), i.dispatchEvent({
                                    type: "planeadded",
                                    data: R
                                })
                        }
                        d = null
                    }), this.setAnimationLoop = function(e) {
                        D = e
                    }, this.dispose = function() {}
                }
            }

            function rT(e, t) {
                function i(i, n) {
                    let r, a;
                    i.opacity.value = n.opacity, n.color && i.diffuse.value.copy(n.color), n.emissive && i.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (i.map.value = n.map), n.alphaMap && (i.alphaMap.value = n.alphaMap), n.bumpMap && (i.bumpMap.value = n.bumpMap, i.bumpScale.value = n.bumpScale, n.side === l && (i.bumpScale.value *= -1)), n.displacementMap && (i.displacementMap.value = n.displacementMap, i.displacementScale.value = n.displacementScale, i.displacementBias.value = n.displacementBias), n.emissiveMap && (i.emissiveMap.value = n.emissiveMap), n.normalMap && (i.normalMap.value = n.normalMap, i.normalScale.value.copy(n.normalScale), n.side === l && i.normalScale.value.negate()), n.specularMap && (i.specularMap.value = n.specularMap), n.alphaTest > 0 && (i.alphaTest.value = n.alphaTest);
                    let s = t.get(n).envMap;
                    if (s && (i.envMap.value = s, i.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1, i.reflectivity.value = n.reflectivity, i.ior.value = n.ior, i.refractionRatio.value = n.refractionRatio), n.lightMap) {
                        i.lightMap.value = n.lightMap;
                        let o = !0 !== e.physicallyCorrectLights ? Math.PI : 1;
                        i.lightMapIntensity.value = n.lightMapIntensity * o
                    }
                    n.aoMap && (i.aoMap.value = n.aoMap, i.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.iridescenceMap ? r = n.iridescenceMap : n.iridescenceThicknessMap ? r = n.iridescenceThicknessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularColorMap ? r = n.specularColorMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap ? r = n.thicknessMap : n.sheenColorMap ? r = n.sheenColorMap : n.sheenRoughnessMap && (r = n.sheenRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), i.uvTransform.value.copy(r.matrix)), n.aoMap ? a = n.aoMap : n.lightMap && (a = n.lightMap), void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), i.uv2Transform.value.copy(a.matrix))
                }
                return {
                    refreshFogUniforms: function(t, i) {
                        i.color.getRGB(t.fogColor.value, ii(e)), i.isFog ? (t.fogNear.value = i.near, t.fogFar.value = i.far) : i.isFogExp2 && (t.fogDensity.value = i.density)
                    },
                    refreshMaterialUniforms: function(e, n, r, a, s) {
                        var o, h, u, c, d, p, f, m, g;
                        let v, _;
                        n.isMeshBasicMaterial ? i(e, n) : n.isMeshLambertMaterial ? i(e, n) : n.isMeshToonMaterial ? (i(e, n), o = e, n.gradientMap && (o.gradientMap.value = n.gradientMap)) : n.isMeshPhongMaterial ? (i(e, n), (h = e).specular.value.copy(n.specular), h.shininess.value = Math.max(n.shininess, 1e-4)) : n.isMeshStandardMaterial ? (i(e, n), function(e, i) {
                            e.roughness.value = i.roughness, e.metalness.value = i.metalness, i.roughnessMap && (e.roughnessMap.value = i.roughnessMap), i.metalnessMap && (e.metalnessMap.value = i.metalnessMap);
                            let n = t.get(i).envMap;
                            n && (e.envMapIntensity.value = i.envMapIntensity)
                        }(e, n), n.isMeshPhysicalMaterial && ((u = e).ior.value = n.ior, n.sheen > 0 && (u.sheenColor.value.copy(n.sheenColor).multiplyScalar(n.sheen), u.sheenRoughness.value = n.sheenRoughness, n.sheenColorMap && (u.sheenColorMap.value = n.sheenColorMap), n.sheenRoughnessMap && (u.sheenRoughnessMap.value = n.sheenRoughnessMap)), n.clearcoat > 0 && (u.clearcoat.value = n.clearcoat, u.clearcoatRoughness.value = n.clearcoatRoughness, n.clearcoatMap && (u.clearcoatMap.value = n.clearcoatMap), n.clearcoatRoughnessMap && (u.clearcoatRoughnessMap.value = n.clearcoatRoughnessMap), n.clearcoatNormalMap && (u.clearcoatNormalScale.value.copy(n.clearcoatNormalScale), u.clearcoatNormalMap.value = n.clearcoatNormalMap, n.side === l && u.clearcoatNormalScale.value.negate())), n.iridescence > 0 && (u.iridescence.value = n.iridescence, u.iridescenceIOR.value = n.iridescenceIOR, u.iridescenceThicknessMinimum.value = n.iridescenceThicknessRange[0], u.iridescenceThicknessMaximum.value = n.iridescenceThicknessRange[1], n.iridescenceMap && (u.iridescenceMap.value = n.iridescenceMap), n.iridescenceThicknessMap && (u.iridescenceThicknessMap.value = n.iridescenceThicknessMap)), n.transmission > 0 && (u.transmission.value = n.transmission, u.transmissionSamplerMap.value = s.texture, u.transmissionSamplerSize.value.set(s.width, s.height), n.transmissionMap && (u.transmissionMap.value = n.transmissionMap), u.thickness.value = n.thickness, n.thicknessMap && (u.thicknessMap.value = n.thicknessMap), u.attenuationDistance.value = n.attenuationDistance, u.attenuationColor.value.copy(n.attenuationColor)), u.specularIntensity.value = n.specularIntensity, u.specularColor.value.copy(n.specularColor), n.specularIntensityMap && (u.specularIntensityMap.value = n.specularIntensityMap), n.specularColorMap && (u.specularColorMap.value = n.specularColorMap))) : n.isMeshMatcapMaterial ? (i(e, n), c = e, n.matcap && (c.matcap.value = n.matcap)) : n.isMeshDepthMaterial ? i(e, n) : n.isMeshDistanceMaterial ? (i(e, n), (d = e).referencePosition.value.copy(n.referencePosition), d.nearDistance.value = n.nearDistance, d.farDistance.value = n.farDistance) : n.isMeshNormalMaterial ? i(e, n) : n.isLineBasicMaterial ? ((p = e).diffuse.value.copy(n.color), p.opacity.value = n.opacity, n.isLineDashedMaterial && ((f = e).dashSize.value = n.dashSize, f.totalSize.value = n.dashSize + n.gapSize, f.scale.value = n.scale)) : n.isPointsMaterial ? ((m = e).diffuse.value.copy(n.color), m.opacity.value = n.opacity, m.size.value = n.size * r, m.scale.value = .5 * a, n.map && (m.map.value = n.map), n.alphaMap && (m.alphaMap.value = n.alphaMap), n.alphaTest > 0 && (m.alphaTest.value = n.alphaTest), n.map ? v = n.map : n.alphaMap && (v = n.alphaMap), void 0 !== v && (!0 === v.matrixAutoUpdate && v.updateMatrix(), m.uvTransform.value.copy(v.matrix))) : n.isSpriteMaterial ? ((g = e).diffuse.value.copy(n.color), g.opacity.value = n.opacity, g.rotation.value = n.rotation, n.map && (g.map.value = n.map), n.alphaMap && (g.alphaMap.value = n.alphaMap), n.alphaTest > 0 && (g.alphaTest.value = n.alphaTest), n.map ? _ = n.map : n.alphaMap && (_ = n.alphaMap), void 0 !== _ && (!0 === _.matrixAutoUpdate && _.updateMatrix(), g.uvTransform.value.copy(_.matrix))) : n.isShadowMaterial ? (e.color.value.copy(n.color), e.opacity.value = n.opacity) : n.isShaderMaterial && (n.uniformsNeedUpdate = !1)
                    }
                }
            }

            function rE(e, t, i, n) {
                let r = {},
                    a = {},
                    s = [],
                    o = i.isWebGL2 ? e.getParameter(35375) : 0;

                function l(e) {
                    let t = {
                        boundary: 0,
                        storage: 0
                    };
                    return "number" == typeof e ? (t.boundary = 4, t.storage = 4) : e.isVector2 ? (t.boundary = 8, t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16, t.storage = 12) : e.isVector4 ? (t.boundary = 16, t.storage = 16) : e.isMatrix3 ? (t.boundary = 48, t.storage = 48) : e.isMatrix4 ? (t.boundary = 64, t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e), t
                }

                function h(t) {
                    let i = t.target;
                    i.removeEventListener("dispose", h);
                    let n = s.indexOf(i.__bindingPointIndex);
                    s.splice(n, 1), e.deleteBuffer(r[i.id]), delete r[i.id], delete a[i.id]
                }
                return {
                    bind: function(e, t) {
                        let i = t.program;
                        n.uniformBlockBinding(e, i)
                    },
                    update: function(i, u) {
                        let c = r[i.id];
                        void 0 === c && (function(e) {
                            let t = e.uniforms,
                                i = 0,
                                n = 0;
                            for (let r = 0, a = t.length; r < a; r++) {
                                let s = t[r],
                                    o = {
                                        boundary: 0,
                                        storage: 0
                                    },
                                    h = Array.isArray(s.value) ? s.value : [s.value];
                                for (let u = 0, c = h.length; u < c; u++) {
                                    let d = h[u],
                                        p = l(d);
                                    o.boundary += p.boundary, o.storage += p.storage
                                }
                                if (s.__data = new Float32Array(o.storage / Float32Array.BYTES_PER_ELEMENT), s.__offset = i, r > 0) {
                                    n = i % 16;
                                    let f = 16 - n;
                                    0 !== n && f - o.boundary < 0 && (i += 16 - n, s.__offset = i)
                                }
                                i += o.storage
                            }(n = i % 16) > 0 && (i += 16 - n), e.__size = i, e.__cache = {}
                        }(i), c = function(t) {
                            let i = function() {
                                for (let e = 0; e < o; e++)
                                    if (-1 === s.indexOf(e)) return s.push(e), e;
                                return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                            }();
                            t.__bindingPointIndex = i;
                            let n = e.createBuffer(),
                                r = t.__size,
                                a = t.usage;
                            return e.bindBuffer(35345, n), e.bufferData(35345, r, a), e.bindBuffer(35345, null), e.bindBufferBase(35345, i, n), n
                        }(i), r[i.id] = c, i.addEventListener("dispose", h));
                        let d = u.program;
                        n.updateUBOMapping(i, d);
                        let p = t.render.frame;
                        a[i.id] !== p && (function(t) {
                            let i = r[t.id],
                                n = t.uniforms,
                                a = t.__cache;
                            e.bindBuffer(35345, i);
                            for (let s = 0, o = n.length; s < o; s++) {
                                let h = n[s];
                                if (!0 === function(e, t, i) {
                                        let n = e.value;
                                        if (void 0 === i[t]) {
                                            if ("number" == typeof n) i[t] = n;
                                            else {
                                                let r = Array.isArray(n) ? n : [n],
                                                    a = [];
                                                for (let s = 0; s < r.length; s++) a.push(r[s].clone());
                                                i[t] = a
                                            }
                                            return !0
                                        }
                                        if ("number" == typeof n) {
                                            if (i[t] !== n) return i[t] = n, !0
                                        } else {
                                            let o = Array.isArray(i[t]) ? i[t] : [i[t]],
                                                l = Array.isArray(n) ? n : [n];
                                            for (let h = 0; h < o.length; h++) {
                                                let u = o[h];
                                                if (!1 === u.equals(l[h])) return u.copy(l[h]), !0
                                            }
                                        }
                                        return !1
                                    }(h, s, a)) {
                                    let u = h.__offset,
                                        c = Array.isArray(h.value) ? h.value : [h.value],
                                        d = 0;
                                    for (let p = 0; p < c.length; p++) {
                                        let f = c[p],
                                            m = l(f);
                                        "number" == typeof f ? (h.__data[0] = f, e.bufferSubData(35345, u + d, h.__data)) : f.isMatrix3 ? (h.__data[0] = f.elements[0], h.__data[1] = f.elements[1], h.__data[2] = f.elements[2], h.__data[3] = f.elements[0], h.__data[4] = f.elements[3], h.__data[5] = f.elements[4], h.__data[6] = f.elements[5], h.__data[7] = f.elements[0], h.__data[8] = f.elements[6], h.__data[9] = f.elements[7], h.__data[10] = f.elements[8], h.__data[11] = f.elements[0]) : (f.toArray(h.__data, d), d += m.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    e.bufferSubData(35345, u, h.__data)
                                }
                            }
                            e.bindBuffer(35345, null)
                        }(i), a[i.id] = p)
                    },
                    dispose: function() {
                        for (let t in r) e.deleteBuffer(r[t]);
                        s = [], r = {}, a = {}
                    }
                }
            }

            function rA(e = {}) {
                let t, i, n, r, a, s, h, u, c, d, p, f, g, v, _, x, y, M, b, S, w, T, E, A, R;
                this.isWebGLRenderer = !0;
                let I = void 0 !== e.canvas ? e.canvas : function() {
                        let e = eo("canvas");
                        return e.style.display = "block", e
                    }(),
                    D = void 0 !== e.context ? e.context : null,
                    N = void 0 === e.depth || e.depth,
                    z = void 0 === e.stencil || e.stencil,
                    U = void 0 !== e.antialias && e.antialias,
                    B = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    F = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    k = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    V = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
                t = null !== D ? D.getContextAttributes().alpha : void 0 !== e.alpha && e.alpha;
                let G = null,
                    W = null,
                    H = [],
                    j = [];
                this.domElement = I, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = O, this.physicallyCorrectLights = !1, this.toneMapping = m, this.toneMappingExposure = 1;
                let q = this,
                    X = !1,
                    J = 0,
                    Y = 0,
                    Z = null,
                    K = -1,
                    Q = null,
                    ee = new ew,
                    et = new ew,
                    ei = null,
                    er = I.width,
                    ea = I.height,
                    es = 1,
                    el = null,
                    eh = null,
                    eu = new ew(0, 0, er, ea),
                    ec = new ew(0, 0, er, ea),
                    ed = !1,
                    ep = new i_,
                    ef = !1,
                    em = !1,
                    eg = null,
                    ev = new e4,
                    e_ = new en,
                    ex = new eC,
                    ey = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function eM() {
                    return null === Z ? es : 1
                }
                let eb = D;

                function eS(e, t) {
                    for (let i = 0; i < e.length; i++) {
                        let n = e[i],
                            r = I.getContext(n, t);
                        if (null !== r) return r
                    }
                    return null
                }
                try {
                    if ("setAttribute" in I && I.setAttribute("data-engine", "three.js r148"), I.addEventListener("webglcontextlost", eR, !1), I.addEventListener("webglcontextrestored", eI, !1), I.addEventListener("webglcontextcreationerror", eD, !1), null === eb) {
                        let eE = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === q.isWebGL1Renderer && eE.shift(), eb = eS(eE, {
                                alpha: !0,
                                depth: N,
                                stencil: z,
                                antialias: U,
                                premultipliedAlpha: B,
                                preserveDrawingBuffer: F,
                                powerPreference: k,
                                failIfMajorPerformanceCaveat: V
                            }), null === eb) {
                            if (eS(eE)) throw Error("Error creating WebGL context with your selected attributes.");
                            throw Error("Error creating WebGL context.")
                        }
                    }
                    void 0 === eb.getShaderPrecisionFormat && (eb.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (eA) {
                    throw console.error("THREE.WebGLRenderer: " + eA.message), eA
                }

                function eL() {
                    i = new iX(eb), n = new iL(eb, i, e), i.init(n), E = new r_(eb, i, n), r = new rg(eb, i, n), a = new iZ, s = new ri, h = new rv(eb, i, r, s, n, E, a), u = new iR(q), c = new iq(q), d = new iy(eb, n), A = new iA(eb, i, d, n), p = new iJ(eb, d, a, A), f = new i0(eb, p, d, a), S = new i$(eb, n, h), y = new iP(s), g = new rt(q, u, c, i, n, A, y), v = new rT(q, s), _ = new rs, x = new rd(i, n), b = new iE(q, u, c, r, f, t, B), M = new rm(q, f, n), R = new rE(eb, a, n, r), w = new iC(eb, i, a, n), T = new iY(eb, i, a, n), a.programs = g.programs, q.capabilities = n, q.extensions = i, q.properties = s, q.renderLists = _, q.shadowMap = M, q.state = r, q.info = a
                }
                eL();
                let eP = new rw(q, eb);

                function eR(e) {
                    e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), X = !0
                }

                function eI() {
                    console.log("THREE.WebGLRenderer: Context Restored."), X = !1;
                    let e = a.autoReset,
                        t = M.enabled,
                        i = M.autoUpdate,
                        n = M.needsUpdate,
                        r = M.type;
                    eL(), a.autoReset = e, M.enabled = t, M.autoUpdate = i, M.needsUpdate = n, M.type = r
                }

                function eD(e) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
                }

                function eN(e) {
                    let t = e.target;
                    t.removeEventListener("dispose", eN),
                        function(e) {
                            let t = s.get(e).programs;
                            void 0 !== t && (t.forEach(function(e) {
                                g.releaseProgram(e)
                            }), e.isShaderMaterial && g.releaseShaderCache(e))
                        }(t), s.remove(t)
                }
                this.xr = eP, this.getContext = function() {
                    return eb
                }, this.getContextAttributes = function() {
                    return eb.getContextAttributes()
                }, this.forceContextLoss = function() {
                    let e = i.get("WEBGL_lose_context");
                    e && e.loseContext()
                }, this.forceContextRestore = function() {
                    let e = i.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }, this.getPixelRatio = function() {
                    return es
                }, this.setPixelRatio = function(e) {
                    void 0 !== e && (es = e, this.setSize(er, ea, !1))
                }, this.getSize = function(e) {
                    return e.set(er, ea)
                }, this.setSize = function(e, t, i) {
                    if (eP.isPresenting) {
                        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                        return
                    }
                    er = e, ea = t, I.width = Math.floor(e * es), I.height = Math.floor(t * es), !1 !== i && (I.style.width = e + "px", I.style.height = t + "px"), this.setViewport(0, 0, e, t)
                }, this.getDrawingBufferSize = function(e) {
                    return e.set(er * es, ea * es).floor()
                }, this.setDrawingBufferSize = function(e, t, i) {
                    er = e, ea = t, es = i, I.width = Math.floor(e * i), I.height = Math.floor(t * i), this.setViewport(0, 0, e, t)
                }, this.getCurrentViewport = function(e) {
                    return e.copy(ee)
                }, this.getViewport = function(e) {
                    return e.copy(eu)
                }, this.setViewport = function(e, t, i, n) {
                    e.isVector4 ? eu.set(e.x, e.y, e.z, e.w) : eu.set(e, t, i, n), r.viewport(ee.copy(eu).multiplyScalar(es).floor())
                }, this.getScissor = function(e) {
                    return e.copy(ec)
                }, this.setScissor = function(e, t, i, n) {
                    e.isVector4 ? ec.set(e.x, e.y, e.z, e.w) : ec.set(e, t, i, n), r.scissor(et.copy(ec).multiplyScalar(es).floor())
                }, this.getScissorTest = function() {
                    return ed
                }, this.setScissorTest = function(e) {
                    r.setScissorTest(ed = e)
                }, this.setOpaqueSort = function(e) {
                    el = e
                }, this.setTransparentSort = function(e) {
                    eh = e
                }, this.getClearColor = function(e) {
                    return e.copy(b.getClearColor())
                }, this.setClearColor = function() {
                    b.setClearColor.apply(b, arguments)
                }, this.getClearAlpha = function() {
                    return b.getClearAlpha()
                }, this.setClearAlpha = function() {
                    b.setClearAlpha.apply(b, arguments)
                }, this.clear = function(e = !0, t = !0, i = !0) {
                    let n = 0;
                    e && (n |= 16384), t && (n |= 256), i && (n |= 1024), eb.clear(n)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    I.removeEventListener("webglcontextlost", eR, !1), I.removeEventListener("webglcontextrestored", eI, !1), I.removeEventListener("webglcontextcreationerror", eD, !1), _.dispose(), x.dispose(), s.dispose(), u.dispose(), c.dispose(), f.dispose(), A.dispose(), R.dispose(), g.dispose(), eP.dispose(), eP.removeEventListener("sessionstart", ez), eP.removeEventListener("sessionend", eU), eg && (eg.dispose(), eg = null), eB.stop()
                }, this.renderBufferDirect = function(e, t, i, a, o, l) {
                    let f;
                    null === t && (t = ey);
                    let g = o.isMesh && 0 > o.matrixWorld.determinant(),
                        _ = function(e, t, i, a, o) {
                            var l, d;
                            !0 !== t.isScene && (t = ey), h.resetTextureUnits();
                            let p = t.fog,
                                f = a.isMeshStandardMaterial ? t.environment : null,
                                g = null === Z ? q.outputEncoding : !0 === Z.isXRRenderTarget ? Z.texture.encoding : O,
                                _ = (a.isMeshStandardMaterial ? c : u).get(a.envMap || f),
                                x = !0 === a.vertexColors && !!i.attributes.color && 4 === i.attributes.color.itemSize,
                                M = !!a.normalMap && !!i.attributes.tangent,
                                b = !!i.morphAttributes.position,
                                w = !!i.morphAttributes.normal,
                                T = !!i.morphAttributes.color,
                                E = a.toneMapped ? q.toneMapping : m,
                                A = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color,
                                C = void 0 !== A ? A.length : 0,
                                L = s.get(a),
                                P = W.state.lights;
                            if (!0 === ef && (!0 === em || e !== Q)) {
                                let I = e === Q && a.id === K;
                                y.setState(a, e, I)
                            }
                            let D = !1;
                            a.version === L.__version ? L.needsLights && L.lightsStateVersion !== P.state.version ? D = !0 : L.outputEncoding !== g ? D = !0 : o.isInstancedMesh && !1 === L.instancing ? D = !0 : o.isInstancedMesh || !0 !== L.instancing ? o.isSkinnedMesh && !1 === L.skinning ? D = !0 : o.isSkinnedMesh || !0 !== L.skinning ? L.envMap !== _ ? D = !0 : !0 === a.fog && L.fog !== p ? D = !0 : void 0 !== L.numClippingPlanes && (L.numClippingPlanes !== y.numPlanes || L.numIntersection !== y.numIntersection) ? D = !0 : L.vertexAlphas !== x ? D = !0 : L.vertexTangents !== M ? D = !0 : L.morphTargets !== b ? D = !0 : L.morphNormals !== w ? D = !0 : L.morphColors !== T ? D = !0 : L.toneMapping !== E ? D = !0 : !0 === n.isWebGL2 && L.morphTargetsCount !== C && (D = !0) : D = !0 : D = !0 : (D = !0, L.__version = a.version);
                            let N = L.currentProgram;
                            !0 === D && (N = eV(a, t, o));
                            let z = !1,
                                U = !1,
                                B = !1,
                                F = N.getUniforms(),
                                k = L.uniforms;
                            if (r.useProgram(N.program) && (z = !0, U = !0, B = !0), a.id !== K && (K = a.id, U = !0), z || Q !== e) {
                                if (F.setValue(eb, "projectionMatrix", e.projectionMatrix), n.logarithmicDepthBuffer && F.setValue(eb, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), Q !== e && (Q = e, U = !0, B = !0), a.isShaderMaterial || a.isMeshPhongMaterial || a.isMeshToonMaterial || a.isMeshStandardMaterial || a.envMap) {
                                    let V = F.map.cameraPosition;
                                    void 0 !== V && V.setValue(eb, ex.setFromMatrixPosition(e.matrixWorld))
                                }(a.isMeshPhongMaterial || a.isMeshToonMaterial || a.isMeshLambertMaterial || a.isMeshBasicMaterial || a.isMeshStandardMaterial || a.isShaderMaterial) && F.setValue(eb, "isOrthographic", !0 === e.isOrthographicCamera), (a.isMeshPhongMaterial || a.isMeshToonMaterial || a.isMeshLambertMaterial || a.isMeshBasicMaterial || a.isMeshStandardMaterial || a.isShaderMaterial || a.isShadowMaterial || o.isSkinnedMesh) && F.setValue(eb, "viewMatrix", e.matrixWorldInverse)
                            }
                            if (o.isSkinnedMesh) {
                                F.setOptional(eb, o, "bindMatrix"), F.setOptional(eb, o, "bindMatrixInverse");
                                let G = o.skeleton;
                                G && (n.floatVertexTextures ? (null === G.boneTexture && G.computeBoneTexture(), F.setValue(eb, "boneTexture", G.boneTexture, h), F.setValue(eb, "boneTextureSize", G.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                            }
                            let H = i.morphAttributes;
                            if ((void 0 !== H.position || void 0 !== H.normal || void 0 !== H.color && !0 === n.isWebGL2) && S.update(o, i, a, N), (U || L.receiveShadow !== o.receiveShadow) && (L.receiveShadow = o.receiveShadow, F.setValue(eb, "receiveShadow", o.receiveShadow)), a.isMeshGouraudMaterial && null !== a.envMap && (k.envMap.value = _, k.flipEnvMap.value = _.isCubeTexture && !1 === _.isRenderTargetTexture ? -1 : 1), U && (F.setValue(eb, "toneMappingExposure", q.toneMappingExposure), L.needsLights && (l = k, d = B, l.ambientLightColor.needsUpdate = d, l.lightProbe.needsUpdate = d, l.directionalLights.needsUpdate = d, l.directionalLightShadows.needsUpdate = d, l.pointLights.needsUpdate = d, l.pointLightShadows.needsUpdate = d, l.spotLights.needsUpdate = d, l.spotLightShadows.needsUpdate = d, l.rectAreaLights.needsUpdate = d, l.hemisphereLights.needsUpdate = d), p && !0 === a.fog && v.refreshFogUniforms(k, p), v.refreshMaterialUniforms(k, a, es, ea, eg), nX.upload(eb, L.uniformsList, k, h)), a.isShaderMaterial && !0 === a.uniformsNeedUpdate && (nX.upload(eb, L.uniformsList, k, h), a.uniformsNeedUpdate = !1), a.isSpriteMaterial && F.setValue(eb, "center", o.center), F.setValue(eb, "modelViewMatrix", o.modelViewMatrix), F.setValue(eb, "normalMatrix", o.normalMatrix), F.setValue(eb, "modelMatrix", o.matrixWorld), a.isShaderMaterial || a.isRawShaderMaterial) {
                                let j = a.uniformsGroups;
                                for (let X = 0, J = j.length; X < J; X++)
                                    if (n.isWebGL2) {
                                        let Y = j[X];
                                        R.update(Y, N), R.bind(Y, N)
                                    } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                            }
                            return N
                        }(e, t, i, a, o);
                    r.setMaterial(a, g);
                    let x = i.index,
                        M = 1;
                    !0 === a.wireframe && (x = p.getWireframeAttribute(i), M = 2);
                    let b = i.drawRange,
                        E = i.attributes.position,
                        C = b.start * M,
                        L = (b.start + b.count) * M;
                    null !== l && (C = Math.max(C, l.start * M), L = Math.min(L, (l.start + l.count) * M)), null !== x ? (C = Math.max(C, 0), L = Math.min(L, x.count)) : null != E && (C = Math.max(C, 0), L = Math.min(L, E.count));
                    let P = L - C;
                    if (P < 0 || P === 1 / 0) return;
                    A.setup(o, a, _, i, x);
                    let I = w;
                    if (null !== x && (f = d.get(x), (I = T).setIndex(f)), o.isMesh) !0 === a.wireframe ? (r.setLineWidth(a.wireframeLinewidth * eM()), I.setMode(1)) : I.setMode(4);
                    else if (o.isLine) {
                        let D = a.linewidth;
                        void 0 === D && (D = 1), r.setLineWidth(D * eM()), o.isLineSegments ? I.setMode(1) : o.isLineLoop ? I.setMode(2) : I.setMode(3)
                    } else o.isPoints ? I.setMode(0) : o.isSprite && I.setMode(4);
                    if (o.isInstancedMesh) I.renderInstances(C, P, o.count);
                    else if (i.isInstancedBufferGeometry) {
                        let N = void 0 !== i._maxInstanceCount ? i._maxInstanceCount : 1 / 0,
                            z = Math.min(i.instanceCount, N);
                        I.renderInstances(C, P, z)
                    } else I.render(C, P)
                }, this.compile = function(e, t) {
                    function i(e, t, i) {
                        !0 === e.transparent && 3 === e.side ? (e.side = l, e.needsUpdate = !0, eV(e, t, i), e.side = o, e.needsUpdate = !0, eV(e, t, i), e.side = 3) : eV(e, t, i)
                    }(W = x.get(e)).init(), j.push(W), e.traverseVisible(function(e) {
                        e.isLight && e.layers.test(t.layers) && (W.pushLight(e), e.castShadow && W.pushShadow(e))
                    }), W.setupLights(q.physicallyCorrectLights), e.traverse(function(t) {
                        let n = t.material;
                        if (n) {
                            if (Array.isArray(n))
                                for (let r = 0; r < n.length; r++) {
                                    let a = n[r];
                                    i(a, e, t)
                                } else i(n, e, t)
                        }
                    }), j.pop(), W = null
                };
                let eO = null;

                function ez() {
                    eB.stop()
                }

                function eU() {
                    eB.start()
                }
                let eB = new ix;

                function eF(e, t, a, s) {
                    let o = e.opaque,
                        l = e.transmissive,
                        u = e.transparent;
                    W.setupLightsView(a), l.length > 0 && function(e, t, r) {
                        let a = n.isWebGL2;
                        null === eg && (eg = new eT(1, 1, {
                            generateMipmaps: !0,
                            type: i.has("EXT_color_buffer_half_float") ? 1016 : 1009,
                            minFilter: C,
                            samples: a && !0 === U ? 4 : 0
                        })), q.getDrawingBufferSize(e_), a ? eg.setSize(e_.x, e_.y) : eg.setSize($(e_.x), $(e_.y));
                        let s = q.getRenderTarget();
                        q.setRenderTarget(eg), q.clear();
                        let o = q.toneMapping;
                        q.toneMapping = m, ek(e, t, r), q.toneMapping = o, h.updateMultisampleRenderTarget(eg), h.updateRenderTargetMipmap(eg), q.setRenderTarget(s)
                    }(o, t, a), s && r.viewport(ee.copy(s)), o.length > 0 && ek(o, t, a), l.length > 0 && ek(l, t, a), u.length > 0 && ek(u, t, a), r.buffers.depth.setTest(!0), r.buffers.depth.setMask(!0), r.buffers.color.setMask(!0), r.setPolygonOffset(!1)
                }

                function ek(e, t, i) {
                    let n = !0 === t.isScene ? t.overrideMaterial : null;
                    for (let r = 0, a = e.length; r < a; r++) {
                        var s;
                        let h = e[r],
                            u = h.object,
                            c = h.geometry,
                            d = null === n ? h.material : n,
                            p = h.group;
                        u.layers.test(i.layers) && (s = d, u.onBeforeRender(q, t, i, c, s, p), u.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, u.matrixWorld), u.normalMatrix.getNormalMatrix(u.modelViewMatrix), s.onBeforeRender(q, t, i, c, u, p), !0 === s.transparent && 3 === s.side ? (s.side = l, s.needsUpdate = !0, q.renderBufferDirect(i, t, c, s, u, p), s.side = o, s.needsUpdate = !0, q.renderBufferDirect(i, t, c, s, u, p), s.side = 3) : q.renderBufferDirect(i, t, c, s, u, p), u.onAfterRender(q, t, i, c, s, p))
                    }
                }

                function eV(e, t, i) {
                    !0 !== t.isScene && (t = ey);
                    let n = s.get(e),
                        r = W.state.lights,
                        a = W.state.shadowsArray,
                        o = r.state.version,
                        l = g.getParameters(e, r.state, a, t, i),
                        h = g.getProgramCacheKey(l),
                        d = n.programs;
                    n.environment = e.isMeshStandardMaterial ? t.environment : null, n.fog = t.fog, n.envMap = (e.isMeshStandardMaterial ? c : u).get(e.envMap || n.environment), void 0 === d && (e.addEventListener("dispose", eN), d = new Map, n.programs = d);
                    let p = d.get(h);
                    if (void 0 !== p) {
                        if (n.currentProgram === p && n.lightsStateVersion === o) return eG(e, l), p
                    } else l.uniforms = g.getUniforms(e), e.onBuild(i, l, q), e.onBeforeCompile(l, q), p = g.acquireProgram(l, h), d.set(h, p), n.uniforms = l.uniforms;
                    let f = n.uniforms;
                    (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (f.clippingPlanes = y.uniform), eG(e, l), n.needsLights = e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights, n.lightsStateVersion = o, n.needsLights && (f.ambientLightColor.value = r.state.ambient, f.lightProbe.value = r.state.probe, f.directionalLights.value = r.state.directional, f.directionalLightShadows.value = r.state.directionalShadow, f.spotLights.value = r.state.spot, f.spotLightShadows.value = r.state.spotShadow, f.rectAreaLights.value = r.state.rectArea, f.ltc_1.value = r.state.rectAreaLTC1, f.ltc_2.value = r.state.rectAreaLTC2, f.pointLights.value = r.state.point, f.pointLightShadows.value = r.state.pointShadow, f.hemisphereLights.value = r.state.hemi, f.directionalShadowMap.value = r.state.directionalShadowMap, f.directionalShadowMatrix.value = r.state.directionalShadowMatrix, f.spotShadowMap.value = r.state.spotShadowMap, f.spotLightMatrix.value = r.state.spotLightMatrix, f.spotLightMap.value = r.state.spotLightMap, f.pointShadowMap.value = r.state.pointShadowMap, f.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    let m = p.getUniforms(),
                        v = nX.seqWithValue(m.seq, f);
                    return n.currentProgram = p, n.uniformsList = v, p
                }

                function eG(e, t) {
                    let i = s.get(e);
                    i.outputEncoding = t.outputEncoding, i.instancing = t.instancing, i.skinning = t.skinning, i.morphTargets = t.morphTargets, i.morphNormals = t.morphNormals, i.morphColors = t.morphColors, i.morphTargetsCount = t.morphTargetsCount, i.numClippingPlanes = t.numClippingPlanes, i.numIntersection = t.numClipIntersection, i.vertexAlphas = t.vertexAlphas, i.vertexTangents = t.vertexTangents, i.toneMapping = t.toneMapping
                }
                eB.setAnimationLoop(function(e) {
                    eO && eO(e)
                }), "undefined" != typeof self && eB.setContext(self), this.setAnimationLoop = function(e) {
                    eO = e, eP.setAnimationLoop(e), null === e ? eB.stop() : eB.start()
                }, eP.addEventListener("sessionstart", ez), eP.addEventListener("sessionend", eU), this.render = function(e, t) {
                    if (void 0 !== t && !0 !== t.isCamera) {
                        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                        return
                    }
                    if (!0 === X) return;
                    !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === eP.enabled && !0 === eP.isPresenting && (!0 === eP.cameraAutoUpdate && eP.updateCamera(t), t = eP.getCamera()), !0 === e.isScene && e.onBeforeRender(q, e, t, Z), (W = x.get(e, j.length)).init(), j.push(W), ev.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), ep.setFromProjectionMatrix(ev), em = this.localClippingEnabled, ef = y.init(this.clippingPlanes, em, t), (G = _.get(e, H.length)).init(), H.push(G),
                        function e(t, i, n, r) {
                            if (!1 === t.visible) return;
                            let s = t.layers.test(i.layers);
                            if (s) {
                                if (t.isGroup) n = t.renderOrder;
                                else if (t.isLOD) !0 === t.autoUpdate && t.update(i);
                                else if (t.isLight) W.pushLight(t), t.castShadow && W.pushShadow(t);
                                else if (t.isSprite) {
                                    if (!t.frustumCulled || ep.intersectsSprite(t)) {
                                        r && ex.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ev);
                                        let o = f.update(t),
                                            l = t.material;
                                        l.visible && G.push(t, o, l, n, ex.z, null)
                                    }
                                } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== a.render.frame && (t.skeleton.update(), t.skeleton.frame = a.render.frame), !t.frustumCulled || ep.intersectsObject(t))) {
                                    r && ex.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ev);
                                    let h = f.update(t),
                                        u = t.material;
                                    if (Array.isArray(u)) {
                                        let c = h.groups;
                                        for (let d = 0, p = c.length; d < p; d++) {
                                            let m = c[d],
                                                g = u[m.materialIndex];
                                            g && g.visible && G.push(t, h, g, n, ex.z, m)
                                        }
                                    } else u.visible && G.push(t, h, u, n, ex.z, null)
                                }
                            }
                            let v = t.children;
                            for (let _ = 0, x = v.length; _ < x; _++) e(v[_], i, n, r)
                        }(e, t, 0, q.sortObjects), G.finish(), !0 === q.sortObjects && G.sort(el, eh), !0 === ef && y.beginShadows();
                    let i = W.state.shadowsArray;
                    if (M.render(i, e, t), !0 === ef && y.endShadows(), !0 === this.info.autoReset && this.info.reset(), b.render(G, e), W.setupLights(q.physicallyCorrectLights), t.isArrayCamera) {
                        let n = t.cameras;
                        for (let r = 0, s = n.length; r < s; r++) {
                            let o = n[r];
                            eF(G, e, o, o.viewport)
                        }
                    } else eF(G, e, t);
                    null !== Z && (h.updateMultisampleRenderTarget(Z), h.updateRenderTargetMipmap(Z)), !0 === e.isScene && e.onAfterRender(q, e, t), A.resetDefaultState(), K = -1, Q = null, j.pop(), W = j.length > 0 ? j[j.length - 1] : null, H.pop(), G = H.length > 0 ? H[H.length - 1] : null
                }, this.getActiveCubeFace = function() {
                    return J
                }, this.getActiveMipmapLevel = function() {
                    return Y
                }, this.getRenderTarget = function() {
                    return Z
                }, this.setRenderTargetTextures = function(e, t, n) {
                    s.get(e.texture).__webglTexture = t, s.get(e.depthTexture).__webglTexture = n;
                    let r = s.get(e);
                    r.__hasExternalTextures = !0, r.__hasExternalTextures && (r.__autoAllocateDepthBuffer = void 0 === n, r.__autoAllocateDepthBuffer || !0 !== i.has("WEBGL_multisampled_render_to_texture") || (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), r.__useRenderToTexture = !1))
                }, this.setRenderTargetFramebuffer = function(e, t) {
                    let i = s.get(e);
                    i.__webglFramebuffer = t, i.__useDefaultFramebuffer = void 0 === t
                }, this.setRenderTarget = function(e, t = 0, i = 0) {
                    Z = e, J = t, Y = i;
                    let a = !0,
                        o = null,
                        l = !1,
                        u = !1;
                    if (e) {
                        let c = s.get(e);
                        void 0 !== c.__useDefaultFramebuffer ? (r.bindFramebuffer(36160, null), a = !1) : void 0 === c.__webglFramebuffer ? h.setupRenderTarget(e) : c.__hasExternalTextures && h.rebindTextures(e, s.get(e.texture).__webglTexture, s.get(e.depthTexture).__webglTexture);
                        let d = e.texture;
                        (d.isData3DTexture || d.isDataArrayTexture || d.isCompressedArrayTexture) && (u = !0);
                        let p = s.get(e).__webglFramebuffer;
                        e.isWebGLCubeRenderTarget ? (o = p[t], l = !0) : o = n.isWebGL2 && e.samples > 0 && !1 === h.useMultisampledRTT(e) ? s.get(e).__webglMultisampledFramebuffer : p, ee.copy(e.viewport), et.copy(e.scissor), ei = e.scissorTest
                    } else ee.copy(eu).multiplyScalar(es).floor(), et.copy(ec).multiplyScalar(es).floor(), ei = ed;
                    let f = r.bindFramebuffer(36160, o);
                    if (f && n.drawBuffers && a && r.drawBuffers(e, o), r.viewport(ee), r.scissor(et), r.setScissorTest(ei), l) {
                        let m = s.get(e.texture);
                        eb.framebufferTexture2D(36160, 36064, 34069 + t, m.__webglTexture, i)
                    } else if (u) {
                        let g = s.get(e.texture);
                        eb.framebufferTextureLayer(36160, 36064, g.__webglTexture, i || 0, t || 0)
                    }
                    K = -1
                }, this.readRenderTargetPixels = function(e, t, a, o, l, h, u) {
                    if (!(e && e.isWebGLRenderTarget)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        return
                    }
                    let c = s.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== u && (c = c[u]), c) {
                        r.bindFramebuffer(36160, c);
                        try {
                            let d = e.texture,
                                p = d.format,
                                f = d.type;
                            if (p !== P && E.convert(p) !== eb.getParameter(35739)) {
                                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                return
                            }
                            let m = 1016 === f && (i.has("EXT_color_buffer_half_float") || n.isWebGL2 && i.has("EXT_color_buffer_float"));
                            if (1009 !== f && E.convert(f) !== eb.getParameter(35738) && !(f === L && (n.isWebGL2 || i.has("OES_texture_float") || i.has("WEBGL_color_buffer_float"))) && !m) {
                                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                return
                            }
                            t >= 0 && t <= e.width - o && a >= 0 && a <= e.height - l && eb.readPixels(t, a, o, l, E.convert(p), E.convert(f), h)
                        } finally {
                            let g = null !== Z ? s.get(Z).__webglFramebuffer : null;
                            r.bindFramebuffer(36160, g)
                        }
                    }
                }, this.copyFramebufferToTexture = function(e, t, i = 0) {
                    let n = Math.pow(2, -i),
                        a = Math.floor(t.image.width * n),
                        s = Math.floor(t.image.height * n);
                    h.setTexture2D(t, 0), eb.copyTexSubImage2D(3553, i, 0, 0, e.x, e.y, a, s), r.unbindTexture()
                }, this.copyTextureToTexture = function(e, t, i, n = 0) {
                    let a = t.image.width,
                        s = t.image.height,
                        o = E.convert(i.format),
                        l = E.convert(i.type);
                    h.setTexture2D(i, 0), eb.pixelStorei(37440, i.flipY), eb.pixelStorei(37441, i.premultiplyAlpha), eb.pixelStorei(3317, i.unpackAlignment), t.isDataTexture ? eb.texSubImage2D(3553, n, e.x, e.y, a, s, o, l, t.image.data) : t.isCompressedTexture ? eb.compressedTexSubImage2D(3553, n, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : eb.texSubImage2D(3553, n, e.x, e.y, o, l, t.image), 0 === n && i.generateMipmaps && eb.generateMipmap(3553), r.unbindTexture()
                }, this.copyTextureToTexture3D = function(e, t, i, n, a = 0) {
                    let s;
                    if (q.isWebGL1Renderer) {
                        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                        return
                    }
                    let o = e.max.x - e.min.x + 1,
                        l = e.max.y - e.min.y + 1,
                        u = e.max.z - e.min.z + 1,
                        c = E.convert(n.format),
                        d = E.convert(n.type);
                    if (n.isData3DTexture) h.setTexture3D(n, 0), s = 32879;
                    else if (n.isDataArrayTexture) h.setTexture2DArray(n, 0), s = 35866;
                    else {
                        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        return
                    }
                    eb.pixelStorei(37440, n.flipY), eb.pixelStorei(37441, n.premultiplyAlpha), eb.pixelStorei(3317, n.unpackAlignment);
                    let p = eb.getParameter(3314),
                        f = eb.getParameter(32878),
                        m = eb.getParameter(3316),
                        g = eb.getParameter(3315),
                        v = eb.getParameter(32877),
                        _ = i.isCompressedTexture ? i.mipmaps[0] : i.image;
                    eb.pixelStorei(3314, _.width), eb.pixelStorei(32878, _.height), eb.pixelStorei(3316, e.min.x), eb.pixelStorei(3315, e.min.y), eb.pixelStorei(32877, e.min.z), i.isDataTexture || i.isData3DTexture ? eb.texSubImage3D(s, a, t.x, t.y, t.z, o, l, u, c, d, _.data) : i.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), eb.compressedTexSubImage3D(s, a, t.x, t.y, t.z, o, l, u, c, _.data)) : eb.texSubImage3D(s, a, t.x, t.y, t.z, o, l, u, c, d, _), eb.pixelStorei(3314, p), eb.pixelStorei(32878, f), eb.pixelStorei(3316, m), eb.pixelStorei(3315, g), eb.pixelStorei(32877, v), 0 === a && n.generateMipmaps && eb.generateMipmap(s), r.unbindTexture()
                }, this.initTexture = function(e) {
                    e.isCubeTexture ? h.setTextureCube(e, 0) : e.isData3DTexture ? h.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? h.setTexture2DArray(e, 0) : h.setTexture2D(e, 0), r.unbindTexture()
                }, this.resetState = function() {
                    J = 0, Y = 0, Z = null, r.reset(), A.reset()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }(class extends rA {}).prototype.isWebGL1Renderer = !0;
            class rC extends tx {
                constructor() {
                    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                copy(e, t) {
                    return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return null !== this.fog && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t.backgroundIntensity = this.backgroundIntensity), t
                }
                get autoUpdate() {
                    return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate
                }
                set autoUpdate(e) {
                    console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e
                }
            }
            class rL {
                constructor(e, t) {
                    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = 35044, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0, this.uuid = X()
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                copy(e) {
                    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
                }
                copyAt(e, t, i) {
                    e *= this.stride, i *= t.stride;
                    for (let n = 0, r = this.stride; n < r; n++) this.array[e + n] = t.array[i + n];
                    return this
                }
                set(e, t = 0) {
                    return this.array.set(e, t), this
                }
                clone(e) {
                    void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = X()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    let t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                        i = new this.constructor(t, this.stride);
                    return i.setUsage(this.usage), i
                }
                onUpload(e) {
                    return this.onUploadCallback = e, this
                }
                toJSON(e) {
                    return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = X()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            }
            let rP = new eC;
            class rR {
                constructor(e, t, i, n = !1) {
                    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = n
                }
                get count() {
                    return this.data.count
                }
                get array() {
                    return this.data.array
                }
                set needsUpdate(e) {
                    this.data.needsUpdate = e
                }
                applyMatrix4(e) {
                    for (let t = 0, i = this.data.count; t < i; t++) rP.fromBufferAttribute(this, t), rP.applyMatrix4(e), this.setXYZ(t, rP.x, rP.y, rP.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, i = this.count; t < i; t++) rP.fromBufferAttribute(this, t), rP.applyNormalMatrix(e), this.setXYZ(t, rP.x, rP.y, rP.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, i = this.count; t < i; t++) rP.fromBufferAttribute(this, t), rP.transformDirection(e), this.setXYZ(t, rP.x, rP.y, rP.z);
                    return this
                }
                setX(e, t) {
                    return this.normalized && (t = et(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
                }
                setY(e, t) {
                    return this.normalized && (t = et(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
                }
                setZ(e, t) {
                    return this.normalized && (t = et(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
                }
                setW(e, t) {
                    return this.normalized && (t = et(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
                }
                getX(e) {
                    let t = this.data.array[e * this.data.stride + this.offset];
                    return this.normalized && (t = ee(t, this.array)), t
                }
                getY(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 1];
                    return this.normalized && (t = ee(t, this.array)), t
                }
                getZ(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 2];
                    return this.normalized && (t = ee(t, this.array)), t
                }
                getW(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 3];
                    return this.normalized && (t = ee(t, this.array)), t
                }
                setXY(e, t, i) {
                    return e = e * this.data.stride + this.offset, this.normalized && (t = et(t, this.array), i = et(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this
                }
                setXYZ(e, t, i, n) {
                    return e = e * this.data.stride + this.offset, this.normalized && (t = et(t, this.array), i = et(i, this.array), n = et(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this
                }
                setXYZW(e, t, i, n, r) {
                    return e = e * this.data.stride + this.offset, this.normalized && (t = et(t, this.array), i = et(i, this.array), n = et(n, this.array), r = et(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this
                }
                clone(e) {
                    if (void 0 !== e) return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new rR(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized); {
                        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                        let t = [];
                        for (let i = 0; i < this.count; i++) {
                            let n = i * this.data.stride + this.offset;
                            for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[n + r])
                        }
                        return new tz(new this.array.constructor(t), this.itemSize, this.normalized)
                    }
                }
                toJSON(e) {
                    if (void 0 !== e) return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }; {
                        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                        let t = [];
                        for (let i = 0; i < this.count; i++) {
                            let n = i * this.data.stride + this.offset;
                            for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[n + r])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: t,
                            normalized: this.normalized
                        }
                    }
                }
            }
            let rI = new eC,
                rD = new ew,
                rN = new ew,
                rO = new eC,
                rz = new e4;
            class rU extends t7 {
                constructor(e, t) {
                    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new e4, this.bindMatrixInverse = new e4
                }
                copy(e, t) {
                    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
                }
                bind(e, t) {
                    this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
                }
                pose() {
                    this.skeleton.pose()
                }
                normalizeSkinWeights() {
                    let e = new ew,
                        t = this.geometry.attributes.skinWeight;
                    for (let i = 0, n = t.count; i < n; i++) {
                        e.fromBufferAttribute(t, i);
                        let r = 1 / e.manhattanLength();
                        r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w)
                    }
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                }
                boneTransform(e, t) {
                    let i = this.skeleton,
                        n = this.geometry;
                    rD.fromBufferAttribute(n.attributes.skinIndex, e), rN.fromBufferAttribute(n.attributes.skinWeight, e), rI.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                    for (let r = 0; r < 4; r++) {
                        let a = rN.getComponent(r);
                        if (0 !== a) {
                            let s = rD.getComponent(r);
                            rz.multiplyMatrices(i.bones[s].matrixWorld, i.boneInverses[s]), t.addScaledVector(rO.copy(rI).applyMatrix4(rz), a)
                        }
                    }
                    return t.applyMatrix4(this.bindMatrixInverse)
                }
            }
            class rB extends tx {
                constructor() {
                    super(), this.isBone = !0, this.type = "Bone"
                }
            }
            class rF extends eS {
                constructor(e = null, t = 1, i = 1, n, r, a, s, o, l = S, h = S, u, c) {
                    super(null, a, s, o, l, h, n, r, u, c), this.isDataTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: i
                    }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            let rk = new e4,
                rV = new e4;
            class rG {
                constructor(e = [], t = []) {
                    this.uuid = X(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
                }
                init() {
                    let e = this.bones,
                        t = this.boneInverses;
                    if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
                    else if (e.length !== t.length) {
                        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                        for (let i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new e4)
                    }
                }
                calculateInverses() {
                    this.boneInverses.length = 0;
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        let i = new e4;
                        this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i)
                    }
                }
                pose() {
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        let i = this.bones[e];
                        i && i.matrixWorld.copy(this.boneInverses[e]).invert()
                    }
                    for (let n = 0, r = this.bones.length; n < r; n++) {
                        let a = this.bones[n];
                        a && (a.parent && a.parent.isBone ? (a.matrix.copy(a.parent.matrixWorld).invert(), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale))
                    }
                }
                update() {
                    let e = this.bones,
                        t = this.boneInverses,
                        i = this.boneMatrices,
                        n = this.boneTexture;
                    for (let r = 0, a = e.length; r < a; r++) {
                        let s = e[r] ? e[r].matrixWorld : rV;
                        rk.multiplyMatrices(s, t[r]), rk.toArray(i, 16 * r)
                    }
                    null !== n && (n.needsUpdate = !0)
                }
                clone() {
                    return new rG(this.bones, this.boneInverses)
                }
                computeBoneTexture() {
                    let e = Math.sqrt(4 * this.bones.length);
                    e = Math.max(e = Q(e), 4);
                    let t = new Float32Array(e * e * 4);
                    t.set(this.boneMatrices);
                    let i = new rF(t, e, e, P, L);
                    return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this.boneTextureSize = e, this
                }
                getBoneByName(e) {
                    for (let t = 0, i = this.bones.length; t < i; t++) {
                        let n = this.bones[t];
                        if (n.name === e) return n
                    }
                }
                dispose() {
                    null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                }
                fromJSON(e, t) {
                    this.uuid = e.uuid;
                    for (let i = 0, n = e.bones.length; i < n; i++) {
                        let r = e.bones[i],
                            a = t[r];
                        void 0 === a && (console.warn("THREE.Skeleton: No bone found with UUID:", r), a = new rB), this.bones.push(a), this.boneInverses.push(new e4().fromArray(e.boneInverses[i]))
                    }
                    return this.init(), this
                }
                toJSON() {
                    let e = {
                        metadata: {
                            version: 4.5,
                            type: "Skeleton",
                            generator: "Skeleton.toJSON"
                        },
                        bones: [],
                        boneInverses: []
                    };
                    e.uuid = this.uuid;
                    let t = this.bones,
                        i = this.boneInverses;
                    for (let n = 0, r = t.length; n < r; n++) {
                        let a = t[n];
                        e.bones.push(a.uuid);
                        let s = i[n];
                        e.boneInverses.push(s.toArray())
                    }
                    return e
                }
            }
            class rW extends tz {
                constructor(e, t, i, n = 1) {
                    super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = n
                }
                copy(e) {
                    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
                }
            }
            let rH = new e4,
                rj = new e4,
                rq = [],
                rX = new e4,
                rJ = new t7;
            class rY extends t7 {
                constructor(e, t, i) {
                    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new rW(new Float32Array(16 * i), 16), this.instanceColor = null, this.count = i, this.frustumCulled = !1;
                    for (let n = 0; n < i; n++) this.setMatrixAt(n, rX)
                }
                copy(e, t) {
                    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this
                }
                getColorAt(e, t) {
                    t.fromArray(this.instanceColor.array, 3 * e)
                }
                getMatrixAt(e, t) {
                    t.fromArray(this.instanceMatrix.array, 16 * e)
                }
                raycast(e, t) {
                    let i = this.matrixWorld,
                        n = this.count;
                    if (rJ.geometry = this.geometry, rJ.material = this.material, void 0 !== rJ.material)
                        for (let r = 0; r < n; r++) {
                            this.getMatrixAt(r, rH), rj.multiplyMatrices(i, rH), rJ.matrixWorld = rj, rJ.raycast(e, rq);
                            for (let a = 0, s = rq.length; a < s; a++) {
                                let o = rq[a];
                                o.instanceId = r, o.object = this, t.push(o)
                            }
                            rq.length = 0
                        }
                }
                setColorAt(e, t) {
                    null === this.instanceColor && (this.instanceColor = new rW(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
                }
                setMatrixAt(e, t) {
                    t.toArray(this.instanceMatrix.array, 16 * e)
                }
                updateMorphTargets() {}
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            class rZ extends tI {
                constructor(e) {
                    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new e_(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
                }
            }
            let rK = new eC,
                rQ = new eC,
                r$ = new e4,
                r0 = new e2,
                r1 = new eY;
            class r3 extends tx {
                constructor(e = new tX, t = new rZ) {
                    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this
                }
                computeLineDistances() {
                    let e = this.geometry;
                    if (null === e.index) {
                        let t = e.attributes.position,
                            i = [0];
                        for (let n = 1, r = t.count; n < r; n++) rK.fromBufferAttribute(t, n - 1), rQ.fromBufferAttribute(t, n), i[n] = i[n - 1], i[n] += rK.distanceTo(rQ);
                        e.setAttribute("lineDistance", new tF(i, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    return this
                }
                raycast(e, t) {
                    let i = this.geometry,
                        n = this.matrixWorld,
                        r = e.params.Line.threshold,
                        a = i.drawRange;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), r1.copy(i.boundingSphere), r1.applyMatrix4(n), r1.radius += r, !1 === e.ray.intersectsSphere(r1)) return;
                    r$.copy(n).invert(), r0.copy(e.ray).applyMatrix4(r$);
                    let s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = s * s,
                        l = new eC,
                        h = new eC,
                        u = new eC,
                        c = new eC,
                        d = this.isLineSegments ? 2 : 1,
                        p = i.index,
                        f = i.attributes,
                        m = f.position;
                    if (null !== p) {
                        let g = Math.max(0, a.start),
                            v = Math.min(p.count, a.start + a.count);
                        for (let _ = g, x = v - 1; _ < x; _ += d) {
                            let y = p.getX(_),
                                M = p.getX(_ + 1);
                            l.fromBufferAttribute(m, y), h.fromBufferAttribute(m, M);
                            let b = r0.distanceSqToSegment(l, h, c, u);
                            if (b > o) continue;
                            c.applyMatrix4(this.matrixWorld);
                            let S = e.ray.origin.distanceTo(c);
                            S < e.near || S > e.far || t.push({
                                distance: S,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: _,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    } else {
                        let w = Math.max(0, a.start),
                            T = Math.min(m.count, a.start + a.count);
                        for (let E = w, A = T - 1; E < A; E += d) {
                            l.fromBufferAttribute(m, E), h.fromBufferAttribute(m, E + 1);
                            let C = r0.distanceSqToSegment(l, h, c, u);
                            if (C > o) continue;
                            c.applyMatrix4(this.matrixWorld);
                            let L = e.ray.origin.distanceTo(c);
                            L < e.near || L > e.far || t.push({
                                distance: L,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: E,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                }
                updateMorphTargets() {
                    let e = this.geometry,
                        t = e.morphAttributes,
                        i = Object.keys(t);
                    if (i.length > 0) {
                        let n = t[i[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let r = 0, a = n.length; r < a; r++) {
                                let s = n[r].name || String(r);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = r
                            }
                        }
                    }
                }
            }
            let r2 = new eC,
                r4 = new eC;
            class r5 extends r3 {
                constructor(e, t) {
                    super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
                }
                computeLineDistances() {
                    let e = this.geometry;
                    if (null === e.index) {
                        let t = e.attributes.position,
                            i = [];
                        for (let n = 0, r = t.count; n < r; n += 2) r2.fromBufferAttribute(t, n), r4.fromBufferAttribute(t, n + 1), i[n] = 0 === n ? 0 : i[n - 1], i[n + 1] = i[n] + r2.distanceTo(r4);
                        e.setAttribute("lineDistance", new tF(i, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    return this
                }
            }
            class r6 extends r3 {
                constructor(e, t) {
                    super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
                }
            }
            class r7 extends tI {
                constructor(e) {
                    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new e_(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
                }
            }
            let r8 = new e4,
                r9 = new e2,
                ae = new eY,
                at = new eC;
            class ai extends tx {
                constructor(e = new tX, t = new r7) {
                    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this
                }
                raycast(e, t) {
                    let i = this.geometry,
                        n = this.matrixWorld,
                        r = e.params.Points.threshold,
                        a = i.drawRange;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), ae.copy(i.boundingSphere), ae.applyMatrix4(n), ae.radius += r, !1 === e.ray.intersectsSphere(ae)) return;
                    r8.copy(n).invert(), r9.copy(e.ray).applyMatrix4(r8);
                    let s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = s * s,
                        l = i.index,
                        h = i.attributes,
                        u = h.position;
                    if (null !== l) {
                        let c = Math.max(0, a.start),
                            d = Math.min(l.count, a.start + a.count);
                        for (let p = c; p < d; p++) {
                            let f = l.getX(p);
                            at.fromBufferAttribute(u, f), an(at, f, o, n, e, t, this)
                        }
                    } else {
                        let m = Math.max(0, a.start),
                            g = Math.min(u.count, a.start + a.count);
                        for (let v = m; v < g; v++) at.fromBufferAttribute(u, v), an(at, v, o, n, e, t, this)
                    }
                }
                updateMorphTargets() {
                    let e = this.geometry,
                        t = e.morphAttributes,
                        i = Object.keys(t);
                    if (i.length > 0) {
                        let n = t[i[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let r = 0, a = n.length; r < a; r++) {
                                let s = n[r].name || String(r);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = r
                            }
                        }
                    }
                }
            }

            function an(e, t, i, n, r, a, s) {
                let o = r9.distanceSqToPoint(e);
                if (o < i) {
                    let l = new eC;
                    r9.closestPointToPoint(e, l), l.applyMatrix4(n);
                    let h = r.ray.origin.distanceTo(l);
                    if (h < r.near || h > r.far) return;
                    a.push({
                        distance: h,
                        distanceToRay: Math.sqrt(o),
                        point: l,
                        index: t,
                        face: null,
                        object: s
                    })
                }
            }
            class ar extends eS {
                constructor(e, t, i, n, r, a, s, o, l) {
                    super(e, t, i, n, r, a, s, o, l), this.isVideoTexture = !0, this.minFilter = void 0 !== a ? a : E, this.magFilter = void 0 !== r ? r : E, this.generateMipmaps = !1;
                    let h = this;
                    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function t() {
                        h.needsUpdate = !0, e.requestVideoFrameCallback(t)
                    })
                }
                clone() {
                    return new this.constructor(this.image).copy(this)
                }
                update() {
                    let e = this.image;
                    !1 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }
            class aa {
                constructor() {
                    this.type = "Curve", this.arcLengthDivisions = 200
                }
                getPoint() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                }
                getPointAt(e, t) {
                    let i = this.getUtoTmapping(e);
                    return this.getPoint(i, t)
                }
                getPoints(e = 5) {
                    let t = [];
                    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
                    return t
                }
                getSpacedPoints(e = 5) {
                    let t = [];
                    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
                    return t
                }
                getLength() {
                    let e = this.getLengths();
                    return e[e.length - 1]
                }
                getLengths(e = this.arcLengthDivisions) {
                    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    let t = [],
                        i, n = this.getPoint(0),
                        r = 0;
                    t.push(0);
                    for (let a = 1; a <= e; a++) t.push(r += (i = this.getPoint(a / e)).distanceTo(n)), n = i;
                    return this.cacheArcLengths = t, t
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.getLengths()
                }
                getUtoTmapping(e, t) {
                    let i;
                    let n = this.getLengths(),
                        r = 0,
                        a = n.length;
                    i = t || e * n[a - 1];
                    let s = 0,
                        o = a - 1,
                        l;
                    for (; s <= o;)
                        if ((l = n[r = Math.floor(s + (o - s) / 2)] - i) < 0) s = r + 1;
                        else if (l > 0) o = r - 1;
                    else {
                        o = r;
                        break
                    }
                    if (n[r = o] === i) return r / (a - 1);
                    let h = n[r],
                        u = n[r + 1],
                        c = (r + (i - h) / (u - h)) / (a - 1);
                    return c
                }
                getTangent(e, t) {
                    let i = e - 1e-4,
                        n = e + 1e-4;
                    i < 0 && (i = 0), n > 1 && (n = 1);
                    let r = this.getPoint(i),
                        a = this.getPoint(n),
                        s = t || (r.isVector2 ? new en : new eC);
                    return s.copy(a).sub(r).normalize(), s
                }
                getTangentAt(e, t) {
                    let i = this.getUtoTmapping(e);
                    return this.getTangent(i, t)
                }
                computeFrenetFrames(e, t) {
                    let i = new eC,
                        n = [],
                        r = [],
                        a = [],
                        s = new eC,
                        o = new e4;
                    for (let l = 0; l <= e; l++) {
                        let h = l / e;
                        n[l] = this.getTangentAt(h, new eC)
                    }
                    r[0] = new eC, a[0] = new eC;
                    let u = Number.MAX_VALUE,
                        c = Math.abs(n[0].x),
                        d = Math.abs(n[0].y),
                        p = Math.abs(n[0].z);
                    c <= u && (u = c, i.set(1, 0, 0)), d <= u && (u = d, i.set(0, 1, 0)), p <= u && i.set(0, 0, 1), s.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], s), a[0].crossVectors(n[0], r[0]);
                    for (let f = 1; f <= e; f++) {
                        if (r[f] = r[f - 1].clone(), a[f] = a[f - 1].clone(), s.crossVectors(n[f - 1], n[f]), s.length() > Number.EPSILON) {
                            s.normalize();
                            let m = Math.acos(J(n[f - 1].dot(n[f]), -1, 1));
                            r[f].applyMatrix4(o.makeRotationAxis(s, m))
                        }
                        a[f].crossVectors(n[f], r[f])
                    }
                    if (!0 === t) {
                        let g = Math.acos(J(r[0].dot(r[e]), -1, 1));
                        g /= e, n[0].dot(s.crossVectors(r[0], r[e])) > 0 && (g = -g);
                        for (let v = 1; v <= e; v++) r[v].applyMatrix4(o.makeRotationAxis(n[v], g * v)), a[v].crossVectors(n[v], r[v])
                    }
                    return {
                        tangents: n,
                        normals: r,
                        binormals: a
                    }
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
                toJSON() {
                    let e = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
                }
                fromJSON(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
            }
            class as extends aa {
                constructor(e = 0, t = 0, i = 1, n = 1, r = 0, a = 2 * Math.PI, s = !1, o = 0) {
                    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = a, this.aClockwise = s, this.aRotation = o
                }
                getPoint(e, t) {
                    let i = t || new en,
                        n = 2 * Math.PI,
                        r = this.aEndAngle - this.aStartAngle,
                        a = Math.abs(r) < Number.EPSILON;
                    for (; r < 0;) r += n;
                    for (; r > n;) r -= n;
                    r < Number.EPSILON && (r = a ? 0 : n), !0 !== this.aClockwise || a || (r === n ? r = -n : r -= n);
                    let s = this.aStartAngle + e * r,
                        o = this.aX + this.xRadius * Math.cos(s),
                        l = this.aY + this.yRadius * Math.sin(s);
                    if (0 !== this.aRotation) {
                        let h = Math.cos(this.aRotation),
                            u = Math.sin(this.aRotation),
                            c = o - this.aX,
                            d = l - this.aY;
                        o = c * h - d * u + this.aX, l = c * u + d * h + this.aY
                    }
                    return i.set(o, l)
                }
                copy(e) {
                    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                }
            }

            function ao() {
                let e = 0,
                    t = 0,
                    i = 0,
                    n = 0;

                function r(r, a, s, o) {
                    e = r, t = s, i = -3 * r + 3 * a - 2 * s - o, n = 2 * r - 2 * a + s + o
                }
                return {
                    initCatmullRom: function(e, t, i, n, a) {
                        r(t, i, a * (i - e), a * (n - t))
                    },
                    initNonuniformCatmullRom: function(e, t, i, n, a, s, o) {
                        let l = (t - e) / a - (i - e) / (a + s) + (i - t) / s,
                            h = (i - t) / s - (n - t) / (s + o) + (n - i) / o;
                        r(t, i, l *= s, h *= s)
                    },
                    calc: function(r) {
                        let a = r * r;
                        return e + t * r + i * a + n * (a * r)
                    }
                }
            }
            let al = new eC,
                ah = new ao,
                au = new ao,
                ac = new ao;

            function ad(e, t, i, n, r) {
                let a = (n - t) * .5,
                    s = (r - i) * .5,
                    o = e * e;
                return (2 * i - 2 * n + a + s) * (e * o) + (-3 * i + 3 * n - 2 * a - s) * o + a * e + i
            }

            function ap(e, t, i, n) {
                return function(e, t) {
                    let i = 1 - e;
                    return i * i * t
                }(e, t) + 2 * (1 - e) * e * i + e * e * n
            }

            function af(e, t, i, n, r) {
                return function(e, t) {
                    let i = 1 - e;
                    return i * i * i * t
                }(e, t) + function(e, t) {
                    let i = 1 - e;
                    return 3 * i * i * e * t
                }(e, i) + 3 * (1 - e) * e * e * n + e * e * e * r
            }
            class am extends aa {
                constructor(e = new en, t = new en, i = new en, n = new en) {
                    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n
                }
                getPoint(e, t = new en) {
                    let i = this.v0,
                        n = this.v1,
                        r = this.v2,
                        a = this.v3;
                    return t.set(af(e, i.x, n.x, r.x, a.x), af(e, i.y, n.y, r.y, a.y)), t
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                }
            }
            class ag extends aa {
                constructor(e = new en, t = new en) {
                    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t
                }
                getPoint(e, t = new en) {
                    return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
                }
                getPointAt(e, t) {
                    return this.getPoint(e, t)
                }
                getTangent(e, t) {
                    let i = t || new en;
                    return i.copy(this.v2).sub(this.v1).normalize(), i
                }
                copy(e) {
                    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class av extends aa {
                constructor(e = new en, t = new en, i = new en) {
                    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i
                }
                getPoint(e, t = new en) {
                    let i = this.v0,
                        n = this.v1,
                        r = this.v2;
                    return t.set(ap(e, i.x, n.x, r.x), ap(e, i.y, n.y, r.y)), t
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class a_ extends aa {
                constructor(e = new eC, t = new eC, i = new eC) {
                    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i
                }
                getPoint(e, t = new eC) {
                    let i = this.v0,
                        n = this.v1,
                        r = this.v2;
                    return t.set(ap(e, i.x, n.x, r.x), ap(e, i.y, n.y, r.y), ap(e, i.z, n.z, r.z)), t
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class ax extends aa {
                constructor(e = []) {
                    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e
                }
                getPoint(e, t = new en) {
                    let i = this.points,
                        n = (i.length - 1) * e,
                        r = Math.floor(n),
                        a = n - r,
                        s = i[0 === r ? r : r - 1],
                        o = i[r],
                        l = i[r > i.length - 2 ? i.length - 1 : r + 1],
                        h = i[r > i.length - 3 ? i.length - 1 : r + 2];
                    return t.set(ad(a, s.x, o.x, l.x, h.x), ad(a, s.y, o.y, l.y, h.y)), t
                }
                copy(e) {
                    super.copy(e), this.points = [];
                    for (let t = 0, i = e.points.length; t < i; t++) {
                        let n = e.points[t];
                        this.points.push(n.clone())
                    }
                    return this
                }
                toJSON() {
                    let e = super.toJSON();
                    e.points = [];
                    for (let t = 0, i = this.points.length; t < i; t++) {
                        let n = this.points[t];
                        e.points.push(n.toArray())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.points = [];
                    for (let t = 0, i = e.points.length; t < i; t++) {
                        let n = e.points[t];
                        this.points.push(new en().fromArray(n))
                    }
                    return this
                }
            }
            var ay = Object.freeze({
                __proto__: null,
                ArcCurve: class extends as {
                    constructor(e, t, i, n, r, a) {
                        super(e, t, i, i, n, r, a), this.isArcCurve = !0, this.type = "ArcCurve"
                    }
                },
                CatmullRomCurve3: class extends aa {
                    constructor(e = [], t = !1, i = "centripetal", n = .5) {
                        super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = n
                    }
                    getPoint(e, t = new eC) {
                        let i, n;
                        let r = this.points,
                            a = r.length,
                            s = (a - (this.closed ? 0 : 1)) * e,
                            o = Math.floor(s),
                            l = s - o;
                        this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / a) + 1) * a : 0 === l && o === a - 1 && (o = a - 2, l = 1), this.closed || o > 0 ? i = r[(o - 1) % a] : (al.subVectors(r[0], r[1]).add(r[0]), i = al);
                        let h = r[o % a],
                            u = r[(o + 1) % a];
                        if (this.closed || o + 2 < a ? n = r[(o + 2) % a] : (al.subVectors(r[a - 1], r[a - 2]).add(r[a - 1]), n = al), "centripetal" === this.curveType || "chordal" === this.curveType) {
                            let c = "chordal" === this.curveType ? .5 : .25,
                                d = Math.pow(i.distanceToSquared(h), c),
                                p = Math.pow(h.distanceToSquared(u), c),
                                f = Math.pow(u.distanceToSquared(n), c);
                            p < 1e-4 && (p = 1), d < 1e-4 && (d = p), f < 1e-4 && (f = p), ah.initNonuniformCatmullRom(i.x, h.x, u.x, n.x, d, p, f), au.initNonuniformCatmullRom(i.y, h.y, u.y, n.y, d, p, f), ac.initNonuniformCatmullRom(i.z, h.z, u.z, n.z, d, p, f)
                        } else "catmullrom" === this.curveType && (ah.initCatmullRom(i.x, h.x, u.x, n.x, this.tension), au.initCatmullRom(i.y, h.y, u.y, n.y, this.tension), ac.initCatmullRom(i.z, h.z, u.z, n.z, this.tension));
                        return t.set(ah.calc(l), au.calc(l), ac.calc(l)), t
                    }
                    copy(e) {
                        super.copy(e), this.points = [];
                        for (let t = 0, i = e.points.length; t < i; t++) {
                            let n = e.points[t];
                            this.points.push(n.clone())
                        }
                        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                    }
                    toJSON() {
                        let e = super.toJSON();
                        e.points = [];
                        for (let t = 0, i = this.points.length; t < i; t++) {
                            let n = this.points[t];
                            e.points.push(n.toArray())
                        }
                        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
                    }
                    fromJSON(e) {
                        super.fromJSON(e), this.points = [];
                        for (let t = 0, i = e.points.length; t < i; t++) {
                            let n = e.points[t];
                            this.points.push(new eC().fromArray(n))
                        }
                        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                    }
                },
                CubicBezierCurve: am,
                CubicBezierCurve3: class extends aa {
                    constructor(e = new eC, t = new eC, i = new eC, n = new eC) {
                        super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n
                    }
                    getPoint(e, t = new eC) {
                        let i = this.v0,
                            n = this.v1,
                            r = this.v2,
                            a = this.v3;
                        return t.set(af(e, i.x, n.x, r.x, a.x), af(e, i.y, n.y, r.y, a.y), af(e, i.z, n.z, r.z, a.z)), t
                    }
                    copy(e) {
                        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                    }
                    toJSON() {
                        let e = super.toJSON();
                        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                    }
                },
                EllipseCurve: as,
                LineCurve: ag,
                LineCurve3: class extends aa {
                    constructor(e = new eC, t = new eC) {
                        super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t
                    }
                    getPoint(e, t = new eC) {
                        return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
                    }
                    getPointAt(e, t) {
                        return this.getPoint(e, t)
                    }
                    copy(e) {
                        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                    }
                    toJSON() {
                        let e = super.toJSON();
                        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                    }
                },
                QuadraticBezierCurve: av,
                QuadraticBezierCurve3: a_,
                SplineCurve: ax
            });
            class aM extends aa {
                constructor() {
                    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                }
                add(e) {
                    this.curves.push(e)
                }
                closePath() {
                    let e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    e.equals(t) || this.curves.push(new ag(t, e))
                }
                getPoint(e, t) {
                    let i = e * this.getLength(),
                        n = this.getCurveLengths(),
                        r = 0;
                    for (; r < n.length;) {
                        if (n[r] >= i) {
                            let a = n[r] - i,
                                s = this.curves[r],
                                o = s.getLength(),
                                l = 0 === o ? 0 : 1 - a / o;
                            return s.getPointAt(l, t)
                        }
                        r++
                    }
                    return null
                }
                getLength() {
                    let e = this.getCurveLengths();
                    return e[e.length - 1]
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                }
                getCurveLengths() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    let e = [],
                        t = 0;
                    for (let i = 0, n = this.curves.length; i < n; i++) e.push(t += this.curves[i].getLength());
                    return this.cacheLengths = e, e
                }
                getSpacedPoints(e = 40) {
                    let t = [];
                    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
                    return this.autoClose && t.push(t[0]), t
                }
                getPoints(e = 12) {
                    let t;
                    let i = [];
                    for (let n = 0, r = this.curves; n < r.length; n++) {
                        let a = r[n],
                            s = a.isEllipseCurve ? 2 * e : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e,
                            o = a.getPoints(s);
                        for (let l = 0; l < o.length; l++) {
                            let h = o[l];
                            t && t.equals(h) || (i.push(h), t = h)
                        }
                    }
                    return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
                }
                copy(e) {
                    super.copy(e), this.curves = [];
                    for (let t = 0, i = e.curves.length; t < i; t++) {
                        let n = e.curves[t];
                        this.curves.push(n.clone())
                    }
                    return this.autoClose = e.autoClose, this
                }
                toJSON() {
                    let e = super.toJSON();
                    e.autoClose = this.autoClose, e.curves = [];
                    for (let t = 0, i = this.curves.length; t < i; t++) {
                        let n = this.curves[t];
                        e.curves.push(n.toJSON())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
                    for (let t = 0, i = e.curves.length; t < i; t++) {
                        let n = e.curves[t];
                        this.curves.push(new ay[n.type]().fromJSON(n))
                    }
                    return this
                }
            }
            class ab extends aM {
                constructor(e) {
                    super(), this.type = "Path", this.currentPoint = new en, e && this.setFromPoints(e)
                }
                setFromPoints(e) {
                    this.moveTo(e[0].x, e[0].y);
                    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
                    return this
                }
                moveTo(e, t) {
                    return this.currentPoint.set(e, t), this
                }
                lineTo(e, t) {
                    let i = new ag(this.currentPoint.clone(), new en(e, t));
                    return this.curves.push(i), this.currentPoint.set(e, t), this
                }
                quadraticCurveTo(e, t, i, n) {
                    let r = new av(this.currentPoint.clone(), new en(e, t), new en(i, n));
                    return this.curves.push(r), this.currentPoint.set(i, n), this
                }
                bezierCurveTo(e, t, i, n, r, a) {
                    let s = new am(this.currentPoint.clone(), new en(e, t), new en(i, n), new en(r, a));
                    return this.curves.push(s), this.currentPoint.set(r, a), this
                }
                splineThru(e) {
                    let t = [this.currentPoint.clone()].concat(e),
                        i = new ax(t);
                    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this
                }
                arc(e, t, i, n, r, a) {
                    let s = this.currentPoint.x,
                        o = this.currentPoint.y;
                    return this.absarc(e + s, t + o, i, n, r, a), this
                }
                absarc(e, t, i, n, r, a) {
                    return this.absellipse(e, t, i, i, n, r, a), this
                }
                ellipse(e, t, i, n, r, a, s, o) {
                    let l = this.currentPoint.x,
                        h = this.currentPoint.y;
                    return this.absellipse(e + l, t + h, i, n, r, a, s, o), this
                }
                absellipse(e, t, i, n, r, a, s, o) {
                    let l = new as(e, t, i, n, r, a, s, o);
                    if (this.curves.length > 0) {
                        let h = l.getPoint(0);
                        h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
                    }
                    this.curves.push(l);
                    let u = l.getPoint(1);
                    return this.currentPoint.copy(u), this
                }
                copy(e) {
                    return super.copy(e), this.currentPoint.copy(e.currentPoint), this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.currentPoint = this.currentPoint.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
                }
            }
            class aS extends tX {
                constructor(e = [new en(0, -.5), new en(.5, 0), new en(0, .5)], t = 12, i = 0, n = 2 * Math.PI) {
                    super(), this.type = "LatheGeometry", this.parameters = {
                        points: e,
                        segments: t,
                        phiStart: i,
                        phiLength: n
                    }, t = Math.floor(t), n = J(n, 0, 2 * Math.PI);
                    let r = [],
                        a = [],
                        s = [],
                        o = [],
                        l = [],
                        h = 1 / t,
                        u = new eC,
                        c = new en,
                        d = new eC,
                        p = new eC,
                        f = new eC,
                        m = 0,
                        g = 0;
                    for (let v = 0; v <= e.length - 1; v++) switch (v) {
                        case 0:
                            m = e[v + 1].x - e[v].x, g = e[v + 1].y - e[v].y, d.x = 1 * g, d.y = -m, d.z = 0 * g, f.copy(d), d.normalize(), o.push(d.x, d.y, d.z);
                            break;
                        case e.length - 1:
                            o.push(f.x, f.y, f.z);
                            break;
                        default:
                            m = e[v + 1].x - e[v].x, g = e[v + 1].y - e[v].y, d.x = 1 * g, d.y = -m, d.z = 0 * g, p.copy(d), d.x += f.x, d.y += f.y, d.z += f.z, d.normalize(), o.push(d.x, d.y, d.z), f.copy(p)
                    }
                    for (let _ = 0; _ <= t; _++) {
                        let x = i + _ * h * n,
                            y = Math.sin(x),
                            M = Math.cos(x);
                        for (let b = 0; b <= e.length - 1; b++) {
                            u.x = e[b].x * y, u.y = e[b].y, u.z = e[b].x * M, a.push(u.x, u.y, u.z), c.x = _ / t, c.y = b / (e.length - 1), s.push(c.x, c.y);
                            let S = o[3 * b + 0] * y,
                                w = o[3 * b + 1],
                                T = o[3 * b + 0] * M;
                            l.push(S, w, T)
                        }
                    }
                    for (let E = 0; E < t; E++)
                        for (let A = 0; A < e.length - 1; A++) {
                            let C = A + E * e.length,
                                L = C + e.length,
                                P = C + e.length + 1,
                                R = C + 1;
                            r.push(C, L, R), r.push(P, R, L)
                        }
                    this.setIndex(r), this.setAttribute("position", new tF(a, 3)), this.setAttribute("uv", new tF(s, 2)), this.setAttribute("normal", new tF(l, 3))
                }
                static fromJSON(e) {
                    return new aS(e.points, e.segments, e.phiStart, e.phiLength)
                }
            }
            class aw extends aS {
                constructor(e = 1, t = 1, i = 4, n = 8) {
                    let r = new ab;
                    r.absarc(0, -t / 2, e, 1.5 * Math.PI, 0), r.absarc(0, t / 2, e, 0, .5 * Math.PI), super(r.getPoints(i), n), this.type = "CapsuleGeometry", this.parameters = {
                        radius: e,
                        height: t,
                        capSegments: i,
                        radialSegments: n
                    }
                }
                static fromJSON(e) {
                    return new aw(e.radius, e.length, e.capSegments, e.radialSegments)
                }
            }
            class aT extends tX {
                constructor(e = 1, t = 32, i = 0, n = 2 * Math.PI) {
                    super(), this.type = "CircleGeometry", this.parameters = {
                        radius: e,
                        segments: t,
                        thetaStart: i,
                        thetaLength: n
                    }, t = Math.max(3, t);
                    let r = [],
                        a = [],
                        s = [],
                        o = [],
                        l = new eC,
                        h = new en;
                    a.push(0, 0, 0), s.push(0, 0, 1), o.push(.5, .5);
                    for (let u = 0, c = 3; u <= t; u++, c += 3) {
                        let d = i + u / t * n;
                        l.x = e * Math.cos(d), l.y = e * Math.sin(d), a.push(l.x, l.y, l.z), s.push(0, 0, 1), h.x = (a[c] / e + 1) / 2, h.y = (a[c + 1] / e + 1) / 2, o.push(h.x, h.y)
                    }
                    for (let p = 1; p <= t; p++) r.push(p, p + 1, 0);
                    this.setIndex(r), this.setAttribute("position", new tF(a, 3)), this.setAttribute("normal", new tF(s, 3)), this.setAttribute("uv", new tF(o, 2))
                }
                static fromJSON(e) {
                    return new aT(e.radius, e.segments, e.thetaStart, e.thetaLength)
                }
            }
            class aE extends tX {
                constructor(e = 1, t = 1, i = 1, n = 32, r = 1, a = !1, s = 0, o = 2 * Math.PI) {
                    super(), this.type = "CylinderGeometry", this.parameters = {
                        radiusTop: e,
                        radiusBottom: t,
                        height: i,
                        radialSegments: n,
                        heightSegments: r,
                        openEnded: a,
                        thetaStart: s,
                        thetaLength: o
                    };
                    let l = this;
                    n = Math.floor(n), r = Math.floor(r);
                    let h = [],
                        u = [],
                        c = [],
                        d = [],
                        p = 0,
                        f = [],
                        m = i / 2,
                        g = 0;

                    function v(i) {
                        let r = p,
                            a = new en,
                            f = new eC,
                            v = 0,
                            _ = !0 === i ? e : t,
                            x = !0 === i ? 1 : -1;
                        for (let y = 1; y <= n; y++) u.push(0, m * x, 0), c.push(0, x, 0), d.push(.5, .5), p++;
                        let M = p;
                        for (let b = 0; b <= n; b++) {
                            let S = b / n,
                                w = S * o + s,
                                T = Math.cos(w),
                                E = Math.sin(w);
                            f.x = _ * E, f.y = m * x, f.z = _ * T, u.push(f.x, f.y, f.z), c.push(0, x, 0), a.x = .5 * T + .5, a.y = .5 * E * x + .5, d.push(a.x, a.y), p++
                        }
                        for (let A = 0; A < n; A++) {
                            let C = r + A,
                                L = M + A;
                            !0 === i ? h.push(L, L + 1, C) : h.push(L + 1, L, C), v += 3
                        }
                        l.addGroup(g, v, !0 === i ? 1 : 2), g += v
                    }(function() {
                        let a = new eC,
                            v = new eC,
                            _ = 0,
                            x = (t - e) / i;
                        for (let y = 0; y <= r; y++) {
                            let M = [],
                                b = y / r,
                                S = b * (t - e) + e;
                            for (let w = 0; w <= n; w++) {
                                let T = w / n,
                                    E = T * o + s,
                                    A = Math.sin(E),
                                    C = Math.cos(E);
                                v.x = S * A, v.y = -b * i + m, v.z = S * C, u.push(v.x, v.y, v.z), a.set(A, x, C).normalize(), c.push(a.x, a.y, a.z), d.push(T, 1 - b), M.push(p++)
                            }
                            f.push(M)
                        }
                        for (let L = 0; L < n; L++)
                            for (let P = 0; P < r; P++) {
                                let R = f[P][L],
                                    I = f[P + 1][L],
                                    D = f[P + 1][L + 1],
                                    N = f[P][L + 1];
                                h.push(R, I, N), h.push(I, D, N), _ += 6
                            }
                        l.addGroup(g, _, 0), g += _
                    })(), !1 === a && (e > 0 && v(!0), t > 0 && v(!1)), this.setIndex(h), this.setAttribute("position", new tF(u, 3)), this.setAttribute("normal", new tF(c, 3)), this.setAttribute("uv", new tF(d, 2))
                }
                static fromJSON(e) {
                    return new aE(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
                }
            }
            class aA extends aE {
                constructor(e = 1, t = 1, i = 32, n = 1, r = !1, a = 0, s = 2 * Math.PI) {
                    super(0, e, t, i, n, r, a, s), this.type = "ConeGeometry", this.parameters = {
                        radius: e,
                        height: t,
                        radialSegments: i,
                        heightSegments: n,
                        openEnded: r,
                        thetaStart: a,
                        thetaLength: s
                    }
                }
                static fromJSON(e) {
                    return new aA(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
                }
            }
            class aC extends tX {
                constructor(e = [], t = [], i = 1, n = 0) {
                    super(), this.type = "PolyhedronGeometry", this.parameters = {
                        vertices: e,
                        indices: t,
                        radius: i,
                        detail: n
                    };
                    let r = [],
                        a = [];

                    function s(e) {
                        r.push(e.x, e.y, e.z)
                    }

                    function o(t, i) {
                        let n = 3 * t;
                        i.x = e[n + 0], i.y = e[n + 1], i.z = e[n + 2]
                    }

                    function l(e, t, i, n) {
                        n < 0 && 1 === e.x && (a[t] = e.x - 1), 0 === i.x && 0 === i.z && (a[t] = n / 2 / Math.PI + .5)
                    }

                    function h(e) {
                        return Math.atan2(e.z, -e.x)
                    }(function(e) {
                        let i = new eC,
                            n = new eC,
                            r = new eC;
                        for (let a = 0; a < t.length; a += 3) o(t[a + 0], i), o(t[a + 1], n), o(t[a + 2], r),
                            function(e, t, i, n) {
                                let r = n + 1,
                                    a = [];
                                for (let o = 0; o <= r; o++) {
                                    a[o] = [];
                                    let l = e.clone().lerp(i, o / r),
                                        h = t.clone().lerp(i, o / r),
                                        u = r - o;
                                    for (let c = 0; c <= u; c++) 0 === c && o === r ? a[o][c] = l : a[o][c] = l.clone().lerp(h, c / u)
                                }
                                for (let d = 0; d < r; d++)
                                    for (let p = 0; p < 2 * (r - d) - 1; p++) {
                                        let f = Math.floor(p / 2);
                                        p % 2 == 0 ? (s(a[d][f + 1]), s(a[d + 1][f]), s(a[d][f])) : (s(a[d][f + 1]), s(a[d + 1][f + 1]), s(a[d + 1][f]))
                                    }
                            }(i, n, r, e)
                    })(n),
                    function(e) {
                        let t = new eC;
                        for (let i = 0; i < r.length; i += 3) t.x = r[i + 0], t.y = r[i + 1], t.z = r[i + 2], t.normalize().multiplyScalar(e), r[i + 0] = t.x, r[i + 1] = t.y, r[i + 2] = t.z
                    }(i),
                    function() {
                        let e = new eC;
                        for (let t = 0; t < r.length; t += 3) {
                            e.x = r[t + 0], e.y = r[t + 1], e.z = r[t + 2];
                            let i = h(e) / 2 / Math.PI + .5,
                                n = Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5;
                            a.push(i, 1 - n)
                        }(function() {
                            let e = new eC,
                                t = new eC,
                                i = new eC,
                                n = new eC,
                                s = new en,
                                o = new en,
                                u = new en;
                            for (let c = 0, d = 0; c < r.length; c += 9, d += 6) {
                                e.set(r[c + 0], r[c + 1], r[c + 2]), t.set(r[c + 3], r[c + 4], r[c + 5]), i.set(r[c + 6], r[c + 7], r[c + 8]), s.set(a[d + 0], a[d + 1]), o.set(a[d + 2], a[d + 3]), u.set(a[d + 4], a[d + 5]), n.copy(e).add(t).add(i).divideScalar(3);
                                let p = h(n);
                                l(s, d + 0, e, p), l(o, d + 2, t, p), l(u, d + 4, i, p)
                            }
                        })(),
                        function() {
                            for (let e = 0; e < a.length; e += 6) {
                                let t = a[e + 0],
                                    i = a[e + 2],
                                    n = a[e + 4],
                                    r = Math.max(t, i, n),
                                    s = Math.min(t, i, n);
                                r > .9 && s < .1 && (t < .2 && (a[e + 0] += 1), i < .2 && (a[e + 2] += 1), n < .2 && (a[e + 4] += 1))
                            }
                        }()
                    }(), this.setAttribute("position", new tF(r, 3)), this.setAttribute("normal", new tF(r.slice(), 3)), this.setAttribute("uv", new tF(a, 2)), 0 === n ? this.computeVertexNormals() : this.normalizeNormals()
                }
                static fromJSON(e) {
                    return new aC(e.vertices, e.indices, e.radius, e.details)
                }
            }
            class aL extends aC {
                constructor(e = 1, t = 0) {
                    let i = (1 + Math.sqrt(5)) / 2,
                        n = 1 / i;
                    super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new aL(e.radius, e.detail)
                }
            }
            class aP extends ab {
                constructor(e) {
                    super(e), this.uuid = X(), this.type = "Shape", this.holes = []
                }
                getPointsHoles(e) {
                    let t = [];
                    for (let i = 0, n = this.holes.length; i < n; i++) t[i] = this.holes[i].getPoints(e);
                    return t
                }
                extractPoints(e) {
                    return {
                        shape: this.getPoints(e),
                        holes: this.getPointsHoles(e)
                    }
                }
                copy(e) {
                    super.copy(e), this.holes = [];
                    for (let t = 0, i = e.holes.length; t < i; t++) {
                        let n = e.holes[t];
                        this.holes.push(n.clone())
                    }
                    return this
                }
                toJSON() {
                    let e = super.toJSON();
                    e.uuid = this.uuid, e.holes = [];
                    for (let t = 0, i = this.holes.length; t < i; t++) {
                        let n = this.holes[t];
                        e.holes.push(n.toJSON())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
                    for (let t = 0, i = e.holes.length; t < i; t++) {
                        let n = e.holes[t];
                        this.holes.push(new ab().fromJSON(n))
                    }
                    return this
                }
            }
            let aR = {
                triangulate: function(e, t, i = 2) {
                    let n, r, a, s, o, l, h;
                    let u = t && t.length,
                        c = u ? t[0] * i : e.length,
                        d = aI(e, 0, c, i, !0),
                        p = [];
                    if (!d || d.next === d.prev) return p;
                    if (u && (d = function(e, t, i, n) {
                            let r, a, s, o, l;
                            let h = [];
                            for (r = 0, a = t.length; r < a; r++) s = t[r] * n, o = r < a - 1 ? t[r + 1] * n : e.length, (l = aI(e, s, o, n, !1)) === l.next && (l.steiner = !0), h.push(function(e) {
                                let t = e,
                                    i = e;
                                do(t.x < i.x || t.x === i.x && t.y < i.y) && (i = t), t = t.next; while (t !== e);
                                return i
                            }(l));
                            for (h.sort(aN), r = 0; r < h.length; r++) i = function(e, t) {
                                let i = function(e, t) {
                                    let i = t,
                                        n = -1 / 0,
                                        r, a = e.x,
                                        s = e.y;
                                    do {
                                        if (s <= i.y && s >= i.next.y && i.next.y !== i.y) {
                                            let o = i.x + (s - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                                            if (o <= a && o > n && (n = o, r = i.x < i.next.x ? i : i.next, o === a)) return r
                                        }
                                        i = i.next
                                    } while (i !== t);
                                    if (!r) return null;
                                    let l = r,
                                        h = r.x,
                                        u = r.y,
                                        c = 1 / 0,
                                        d;
                                    i = r;
                                    do {
                                        var p, f;
                                        a >= i.x && i.x >= h && a !== i.x && az(s < u ? a : n, s, h, u, s < u ? n : a, s, i.x, i.y) && (d = Math.abs(s - i.y) / (a - i.x), aG(i, e) && (d < c || d === c && (i.x > r.x || i.x === r.x && (p = r, f = i, 0 > aU(p.prev, p, f.prev) && 0 > aU(f.next, p, p.next)))) && (r = i, c = d)), i = i.next
                                    } while (i !== l);
                                    return r
                                }(e, t);
                                if (!i) return t;
                                let n = aW(i, e);
                                return aD(n, n.next), aD(i, i.next)
                            }(h[r], i);
                            return i
                        }(e, t, d, i)), e.length > 80 * i) {
                        n = a = e[0], r = s = e[1];
                        for (let f = i; f < c; f += i) o = e[f], l = e[f + 1], o < n && (n = o), l < r && (r = l), o > a && (a = o), l > s && (s = l);
                        h = 0 !== (h = Math.max(a - n, s - r)) ? 32767 / h : 0
                    }
                    return function e(t, i, n, r, a, s, o) {
                        if (!t) return;
                        !o && s && function(e, t, i, n) {
                            let r = e;
                            do 0 === r.z && (r.z = aO(r.x, r.y, t, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== e);
                            r.prevZ.nextZ = null, r.prevZ = null,
                                function(e) {
                                    let t, i, n, r, a, s, o, l, h = 1;
                                    do {
                                        for (i = e, e = null, a = null, s = 0; i;) {
                                            for (s++, n = i, o = 0, t = 0; t < h && (o++, n = n.nextZ); t++);
                                            for (l = h; o > 0 || l > 0 && n;) 0 !== o && (0 === l || !n || i.z <= n.z) ? (r = i, i = i.nextZ, o--) : (r = n, n = n.nextZ, l--), a ? a.nextZ = r : e = r, r.prevZ = a, a = r;
                                            i = n
                                        }
                                        a.nextZ = null, h *= 2
                                    } while (s > 1)
                                }(r)
                        }(t, r, a, s);
                        let l = t,
                            h, u;
                        for (; t.prev !== t.next;) {
                            if (h = t.prev, u = t.next, s ? function(e, t, i, n) {
                                    let r = e.prev,
                                        a = e.next;
                                    if (aU(r, e, a) >= 0) return !1;
                                    let s = r.x,
                                        o = e.x,
                                        l = a.x,
                                        h = r.y,
                                        u = e.y,
                                        c = a.y,
                                        d = s < o ? s < l ? s : l : o < l ? o : l,
                                        p = h < u ? h < c ? h : c : u < c ? u : c,
                                        f = s > o ? s > l ? s : l : o > l ? o : l,
                                        m = h > u ? h > c ? h : c : u > c ? u : c,
                                        g = aO(d, p, t, i, n),
                                        v = aO(f, m, t, i, n),
                                        _ = e.prevZ,
                                        x = e.nextZ;
                                    for (; _ && _.z >= g && x && x.z <= v;) {
                                        if (_.x >= d && _.x <= f && _.y >= p && _.y <= m && _ !== r && _ !== a && az(s, h, o, u, l, c, _.x, _.y) && aU(_.prev, _, _.next) >= 0 || (_ = _.prevZ, x.x >= d && x.x <= f && x.y >= p && x.y <= m && x !== r && x !== a && az(s, h, o, u, l, c, x.x, x.y) && aU(x.prev, x, x.next) >= 0)) return !1;
                                        x = x.nextZ
                                    }
                                    for (; _ && _.z >= g;) {
                                        if (_.x >= d && _.x <= f && _.y >= p && _.y <= m && _ !== r && _ !== a && az(s, h, o, u, l, c, _.x, _.y) && aU(_.prev, _, _.next) >= 0) return !1;
                                        _ = _.prevZ
                                    }
                                    for (; x && x.z <= v;) {
                                        if (x.x >= d && x.x <= f && x.y >= p && x.y <= m && x !== r && x !== a && az(s, h, o, u, l, c, x.x, x.y) && aU(x.prev, x, x.next) >= 0) return !1;
                                        x = x.nextZ
                                    }
                                    return !0
                                }(t, r, a, s) : function(e) {
                                    let t = e.prev,
                                        i = e.next;
                                    if (aU(t, e, i) >= 0) return !1;
                                    let n = t.x,
                                        r = e.x,
                                        a = i.x,
                                        s = t.y,
                                        o = e.y,
                                        l = i.y,
                                        h = n < r ? n < a ? n : a : r < a ? r : a,
                                        u = s < o ? s < l ? s : l : o < l ? o : l,
                                        c = n > r ? n > a ? n : a : r > a ? r : a,
                                        d = s > o ? s > l ? s : l : o > l ? o : l,
                                        p = i.next;
                                    for (; p !== t;) {
                                        if (p.x >= h && p.x <= c && p.y >= u && p.y <= d && az(n, s, r, o, a, l, p.x, p.y) && aU(p.prev, p, p.next) >= 0) return !1;
                                        p = p.next
                                    }
                                    return !0
                                }(t)) {
                                i.push(h.i / n | 0), i.push(t.i / n | 0), i.push(u.i / n | 0), aj(t), t = u.next, l = u.next;
                                continue
                            }
                            if ((t = u) === l) {
                                o ? 1 === o ? e(t = function(e, t, i) {
                                    let n = e;
                                    do {
                                        let r = n.prev,
                                            a = n.next.next;
                                        !aB(r, a) && aF(r, n, n.next, a) && aG(r, a) && aG(a, r) && (t.push(r.i / i | 0), t.push(n.i / i | 0), t.push(a.i / i | 0), aj(n), aj(n.next), n = e = a), n = n.next
                                    } while (n !== e);
                                    return aD(n)
                                }(aD(t), i, n), i, n, r, a, s, 2) : 2 === o && function(t, i, n, r, a, s) {
                                    let o = t;
                                    do {
                                        let l = o.next.next;
                                        for (; l !== o.prev;) {
                                            var h, u;
                                            if (o.i !== l.i && (h = o, u = l, h.next.i !== u.i && h.prev.i !== u.i && ! function(e, t) {
                                                    let i = e;
                                                    do {
                                                        if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && aF(i, i.next, e, t)) return !0;
                                                        i = i.next
                                                    } while (i !== e);
                                                    return !1
                                                }(h, u) && (aG(h, u) && aG(u, h) && function(e, t) {
                                                    let i = e,
                                                        n = !1,
                                                        r = (e.x + t.x) / 2,
                                                        a = (e.y + t.y) / 2;
                                                    do i.y > a != i.next.y > a && i.next.y !== i.y && r < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next; while (i !== e);
                                                    return n
                                                }(h, u) && (aU(h.prev, h, u.prev) || aU(h, u.prev, u)) || aB(h, u) && aU(h.prev, h, h.next) > 0 && aU(u.prev, u, u.next) > 0))) {
                                                let c = aW(o, l);
                                                o = aD(o, o.next), c = aD(c, c.next), e(o, i, n, r, a, s, 0), e(c, i, n, r, a, s, 0);
                                                return
                                            }
                                            l = l.next
                                        }
                                        o = o.next
                                    } while (o !== t)
                                }(t, i, n, r, a, s) : e(aD(t), i, n, r, a, s, 1);
                                break
                            }
                        }
                    }(d, p, i, n, r, h, 0), p
                }
            };

            function aI(e, t, i, n, r) {
                let a, s;
                if (r === function(e, t, i, n) {
                        let r = 0;
                        for (let a = t, s = i - n; a < i; a += n) r += (e[s] - e[a]) * (e[a + 1] + e[s + 1]), s = a;
                        return r
                    }(e, t, i, n) > 0)
                    for (a = t; a < i; a += n) s = aH(a, e[a], e[a + 1], s);
                else
                    for (a = i - n; a >= t; a -= n) s = aH(a, e[a], e[a + 1], s);
                return s && aB(s, s.next) && (aj(s), s = s.next), s
            }

            function aD(e, t) {
                if (!e) return e;
                t || (t = e);
                let i = e,
                    n;
                do
                    if (n = !1, !i.steiner && (aB(i, i.next) || 0 === aU(i.prev, i, i.next))) {
                        if (aj(i), (i = t = i.prev) === i.next) break;
                        n = !0
                    } else i = i.next; while (n || i !== t);
                return t
            }

            function aN(e, t) {
                return e.x - t.x
            }

            function aO(e, t, i, n, r) {
                return (e = ((e = ((e = ((e = ((e = (e - i) * r | 0) | e << 8) & 16711935) | e << 4) & 252645135) | e << 2) & 858993459) | e << 1) & 1431655765) | (t = ((t = ((t = ((t = ((t = (t - n) * r | 0) | t << 8) & 16711935) | t << 4) & 252645135) | t << 2) & 858993459) | t << 1) & 1431655765) << 1
            }

            function az(e, t, i, n, r, a, s, o) {
                return (r - s) * (t - o) >= (e - s) * (a - o) && (e - s) * (n - o) >= (i - s) * (t - o) && (i - s) * (a - o) >= (r - s) * (n - o)
            }

            function aU(e, t, i) {
                return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)
            }

            function aB(e, t) {
                return e.x === t.x && e.y === t.y
            }

            function aF(e, t, i, n) {
                let r = aV(aU(e, t, i)),
                    a = aV(aU(e, t, n)),
                    s = aV(aU(i, n, e)),
                    o = aV(aU(i, n, t));
                return !!(r !== a && s !== o || 0 === r && ak(e, i, t) || 0 === a && ak(e, n, t) || 0 === s && ak(i, e, n) || 0 === o && ak(i, t, n))
            }

            function ak(e, t, i) {
                return t.x <= Math.max(e.x, i.x) && t.x >= Math.min(e.x, i.x) && t.y <= Math.max(e.y, i.y) && t.y >= Math.min(e.y, i.y)
            }

            function aV(e) {
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }

            function aG(e, t) {
                return 0 > aU(e.prev, e, e.next) ? aU(e, t, e.next) >= 0 && aU(e, e.prev, t) >= 0 : 0 > aU(e, t, e.prev) || 0 > aU(e, e.next, t)
            }

            function aW(e, t) {
                let i = new aq(e.i, e.x, e.y),
                    n = new aq(t.i, t.x, t.y),
                    r = e.next,
                    a = t.prev;
                return e.next = t, t.prev = e, i.next = r, r.prev = i, n.next = i, i.prev = n, a.next = n, n.prev = a, n
            }

            function aH(e, t, i, n) {
                let r = new aq(e, t, i);
                return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r
            }

            function aj(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }

            function aq(e, t, i) {
                this.i = e, this.x = t, this.y = i, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            class aX {
                static area(e) {
                    let t = e.length,
                        i = 0;
                    for (let n = t - 1, r = 0; r < t; n = r++) i += e[n].x * e[r].y - e[r].x * e[n].y;
                    return .5 * i
                }
                static isClockWise(e) {
                    return 0 > aX.area(e)
                }
                static triangulateShape(e, t) {
                    let i = [],
                        n = [],
                        r = [];
                    aJ(e), aY(i, e);
                    let a = e.length;
                    t.forEach(aJ);
                    for (let s = 0; s < t.length; s++) n.push(a), a += t[s].length, aY(i, t[s]);
                    let o = aR.triangulate(i, n);
                    for (let l = 0; l < o.length; l += 3) r.push(o.slice(l, l + 3));
                    return r
                }
            }

            function aJ(e) {
                let t = e.length;
                t > 2 && e[t - 1].equals(e[0]) && e.pop()
            }

            function aY(e, t) {
                for (let i = 0; i < t.length; i++) e.push(t[i].x), e.push(t[i].y)
            }
            class aZ extends tX {
                constructor(e = new aP([new en(.5, .5), new en(-.5, .5), new en(-.5, -.5), new en(.5, -.5)]), t = {}) {
                    super(), this.type = "ExtrudeGeometry", this.parameters = {
                        shapes: e,
                        options: t
                    }, e = Array.isArray(e) ? e : [e];
                    let i = this,
                        n = [],
                        r = [];
                    for (let a = 0, s = e.length; a < s; a++) {
                        let o = e[a];
                        ! function(e) {
                            let a, s, o, l;
                            let h = [],
                                u = void 0 !== t.curveSegments ? t.curveSegments : 12,
                                c = void 0 !== t.steps ? t.steps : 1,
                                d = void 0 !== t.depth ? t.depth : 1,
                                p = void 0 === t.bevelEnabled || t.bevelEnabled,
                                f = void 0 !== t.bevelThickness ? t.bevelThickness : .2,
                                m = void 0 !== t.bevelSize ? t.bevelSize : f - .1,
                                g = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                                v = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                                _ = t.extrudePath,
                                x = void 0 !== t.UVGenerator ? t.UVGenerator : aK,
                                y, M = !1;
                            _ && (y = _.getSpacedPoints(c), M = !0, p = !1, a = _.computeFrenetFrames(c, !1), s = new eC, o = new eC, l = new eC), p || (v = 0, f = 0, m = 0, g = 0);
                            let b = e.extractPoints(u),
                                S = b.shape,
                                w = b.holes,
                                T = !aX.isClockWise(S);
                            if (T) {
                                S = S.reverse();
                                for (let E = 0, A = w.length; E < A; E++) {
                                    let C = w[E];
                                    aX.isClockWise(C) && (w[E] = C.reverse())
                                }
                            }
                            let L = aX.triangulateShape(S, w),
                                P = S;
                            for (let R = 0, I = w.length; R < I; R++) {
                                let D = w[R];
                                S = S.concat(D)
                            }

                            function N(e, t, i) {
                                return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(i).add(e)
                            }
                            let O = S.length,
                                z = L.length;

                            function U(e, t, i) {
                                let n, r, a;
                                let s = e.x - t.x,
                                    o = e.y - t.y,
                                    l = i.x - e.x,
                                    h = i.y - e.y,
                                    u = s * s + o * o;
                                if (Math.abs(s * h - o * l) > Number.EPSILON) {
                                    let c = Math.sqrt(u),
                                        d = Math.sqrt(l * l + h * h),
                                        p = t.x - o / c,
                                        f = t.y + s / c,
                                        m = i.x - h / d,
                                        g = i.y + l / d,
                                        v = ((m - p) * h - (g - f) * l) / (s * h - o * l);
                                    n = p + s * v - e.x, r = f + o * v - e.y;
                                    let _ = n * n + r * r;
                                    if (_ <= 2) return new en(n, r);
                                    a = Math.sqrt(_ / 2)
                                } else {
                                    let x = !1;
                                    s > Number.EPSILON ? l > Number.EPSILON && (x = !0) : s < -Number.EPSILON ? l < -Number.EPSILON && (x = !0) : Math.sign(o) === Math.sign(h) && (x = !0), x ? (n = -o, r = s, a = Math.sqrt(u)) : (n = s, r = o, a = Math.sqrt(u / 2))
                                }
                                return new en(n / a, r / a)
                            }
                            let B = [];
                            for (let F = 0, k = P.length, V = k - 1, G = F + 1; F < k; F++, V++, G++) V === k && (V = 0), G === k && (G = 0), B[F] = U(P[F], P[V], P[G]);
                            let W = [],
                                H, j = B.concat();
                            for (let q = 0, X = w.length; q < X; q++) {
                                let J = w[q];
                                H = [];
                                for (let Y = 0, Z = J.length, K = Z - 1, Q = Y + 1; Y < Z; Y++, K++, Q++) K === Z && (K = 0), Q === Z && (Q = 0), H[Y] = U(J[Y], J[K], J[Q]);
                                W.push(H), j = j.concat(H)
                            }
                            for (let $ = 0; $ < v; $++) {
                                let ee = $ / v,
                                    et = f * Math.cos(ee * Math.PI / 2),
                                    ei = m * Math.sin(ee * Math.PI / 2) + g;
                                for (let er = 0, ea = P.length; er < ea; er++) {
                                    let es = N(P[er], B[er], ei);
                                    eN(es.x, es.y, -et)
                                }
                                for (let eo = 0, el = w.length; eo < el; eo++) {
                                    let eh = w[eo];
                                    H = W[eo];
                                    for (let eu = 0, ec = eh.length; eu < ec; eu++) {
                                        let ed = N(eh[eu], H[eu], ei);
                                        eN(ed.x, ed.y, -et)
                                    }
                                }
                            }
                            let ep = m + g;
                            for (let ef = 0; ef < O; ef++) {
                                let em = p ? N(S[ef], j[ef], ep) : S[ef];
                                M ? (o.copy(a.normals[0]).multiplyScalar(em.x), s.copy(a.binormals[0]).multiplyScalar(em.y), l.copy(y[0]).add(o).add(s), eN(l.x, l.y, l.z)) : eN(em.x, em.y, 0)
                            }
                            for (let eg = 1; eg <= c; eg++)
                                for (let ev = 0; ev < O; ev++) {
                                    let e_ = p ? N(S[ev], j[ev], ep) : S[ev];
                                    M ? (o.copy(a.normals[eg]).multiplyScalar(e_.x), s.copy(a.binormals[eg]).multiplyScalar(e_.y), l.copy(y[eg]).add(o).add(s), eN(l.x, l.y, l.z)) : eN(e_.x, e_.y, d / c * eg)
                                }
                            for (let ex = v - 1; ex >= 0; ex--) {
                                let ey = ex / v,
                                    eM = f * Math.cos(ey * Math.PI / 2),
                                    eb = m * Math.sin(ey * Math.PI / 2) + g;
                                for (let eS = 0, ew = P.length; eS < ew; eS++) {
                                    let eT = N(P[eS], B[eS], eb);
                                    eN(eT.x, eT.y, d + eM)
                                }
                                for (let eE = 0, eA = w.length; eE < eA; eE++) {
                                    let eL = w[eE];
                                    H = W[eE];
                                    for (let eP = 0, eR = eL.length; eP < eR; eP++) {
                                        let eI = N(eL[eP], H[eP], eb);
                                        M ? eN(eI.x, eI.y + y[c - 1].y, y[c - 1].x + eM) : eN(eI.x, eI.y, d + eM)
                                    }
                                }
                            }

                            function eD(e, t) {
                                let r = e.length;
                                for (; --r >= 0;) {
                                    let a = r,
                                        s = r - 1;
                                    s < 0 && (s = e.length - 1);
                                    for (let o = 0, l = c + 2 * v; o < l; o++) {
                                        let h = O * o,
                                            u = O * (o + 1),
                                            d = t + a + h,
                                            p = t + s + h,
                                            f = t + s + u,
                                            m = t + a + u;
                                        ! function(e, t, r, a) {
                                            ez(e), ez(t), ez(a), ez(t), ez(r), ez(a);
                                            let s = n.length / 3,
                                                o = x.generateSideWallUV(i, n, s - 6, s - 3, s - 2, s - 1);
                                            eU(o[0]), eU(o[1]), eU(o[3]), eU(o[1]), eU(o[2]), eU(o[3])
                                        }(d, p, f, m)
                                    }
                                }
                            }

                            function eN(e, t, i) {
                                h.push(e), h.push(t), h.push(i)
                            }

                            function eO(e, t, r) {
                                ez(e), ez(t), ez(r);
                                let a = n.length / 3,
                                    s = x.generateTopUV(i, n, a - 3, a - 2, a - 1);
                                eU(s[0]), eU(s[1]), eU(s[2])
                            }

                            function ez(e) {
                                n.push(h[3 * e + 0]), n.push(h[3 * e + 1]), n.push(h[3 * e + 2])
                            }

                            function eU(e) {
                                r.push(e.x), r.push(e.y)
                            }(function() {
                                let e = n.length / 3;
                                if (p) {
                                    let t = 0 * O;
                                    for (let r = 0; r < z; r++) {
                                        let a = L[r];
                                        eO(a[2] + t, a[1] + t, a[0] + t)
                                    }
                                    t = O * (c + 2 * v);
                                    for (let s = 0; s < z; s++) {
                                        let o = L[s];
                                        eO(o[0] + t, o[1] + t, o[2] + t)
                                    }
                                } else {
                                    for (let l = 0; l < z; l++) {
                                        let h = L[l];
                                        eO(h[2], h[1], h[0])
                                    }
                                    for (let u = 0; u < z; u++) {
                                        let d = L[u];
                                        eO(d[0] + O * c, d[1] + O * c, d[2] + O * c)
                                    }
                                }
                                i.addGroup(e, n.length / 3 - e, 0)
                            })(),
                            function() {
                                let e = n.length / 3,
                                    t = 0;
                                eD(P, 0), t += P.length;
                                for (let r = 0, a = w.length; r < a; r++) {
                                    let s = w[r];
                                    eD(s, t), t += s.length
                                }
                                i.addGroup(e, n.length / 3 - e, 1)
                            }()
                        }(o)
                    }
                    this.setAttribute("position", new tF(n, 3)), this.setAttribute("uv", new tF(r, 2)), this.computeVertexNormals()
                }
                toJSON() {
                    let e = super.toJSON(),
                        t = this.parameters.shapes,
                        i = this.parameters.options;
                    return function(e, t, i) {
                        if (i.shapes = [], Array.isArray(e))
                            for (let n = 0, r = e.length; n < r; n++) {
                                let a = e[n];
                                i.shapes.push(a.uuid)
                            } else i.shapes.push(e.uuid);
                        return i.options = Object.assign({}, t), void 0 !== t.extrudePath && (i.options.extrudePath = t.extrudePath.toJSON()), i
                    }(t, i, e)
                }
                static fromJSON(e, t) {
                    let i = [];
                    for (let n = 0, r = e.shapes.length; n < r; n++) {
                        let a = t[e.shapes[n]];
                        i.push(a)
                    }
                    let s = e.options.extrudePath;
                    return void 0 !== s && (e.options.extrudePath = new ay[s.type]().fromJSON(s)), new aZ(i, e.options)
                }
            }
            let aK = {
                generateTopUV: function(e, t, i, n, r) {
                    let a = t[3 * i],
                        s = t[3 * i + 1],
                        o = t[3 * n],
                        l = t[3 * n + 1],
                        h = t[3 * r],
                        u = t[3 * r + 1];
                    return [new en(a, s), new en(o, l), new en(h, u)]
                },
                generateSideWallUV: function(e, t, i, n, r, a) {
                    let s = t[3 * i],
                        o = t[3 * i + 1],
                        l = t[3 * i + 2],
                        h = t[3 * n],
                        u = t[3 * n + 1],
                        c = t[3 * n + 2],
                        d = t[3 * r],
                        p = t[3 * r + 1],
                        f = t[3 * r + 2],
                        m = t[3 * a],
                        g = t[3 * a + 1],
                        v = t[3 * a + 2];
                    return Math.abs(o - u) < Math.abs(s - h) ? [new en(s, 1 - l), new en(h, 1 - c), new en(d, 1 - f), new en(m, 1 - v)] : [new en(o, 1 - l), new en(u, 1 - c), new en(p, 1 - f), new en(g, 1 - v)]
                }
            };
            class aQ extends aC {
                constructor(e = 1, t = 0) {
                    let i = (1 + Math.sqrt(5)) / 2;
                    super([-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new aQ(e.radius, e.detail)
                }
            }
            class a$ extends aC {
                constructor(e = 1, t = 0) {
                    super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new a$(e.radius, e.detail)
                }
            }
            class a0 extends tX {
                constructor(e = .5, t = 1, i = 32, n = 1, r = 0, a = 2 * Math.PI) {
                    super(), this.type = "RingGeometry", this.parameters = {
                        innerRadius: e,
                        outerRadius: t,
                        thetaSegments: i,
                        phiSegments: n,
                        thetaStart: r,
                        thetaLength: a
                    }, i = Math.max(3, i), n = Math.max(1, n);
                    let s = [],
                        o = [],
                        l = [],
                        h = [],
                        u = e,
                        c = (t - e) / n,
                        d = new eC,
                        p = new en;
                    for (let f = 0; f <= n; f++) {
                        for (let m = 0; m <= i; m++) {
                            let g = r + m / i * a;
                            d.x = u * Math.cos(g), d.y = u * Math.sin(g), o.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / t + 1) / 2, p.y = (d.y / t + 1) / 2, h.push(p.x, p.y)
                        }
                        u += c
                    }
                    for (let v = 0; v < n; v++) {
                        let _ = v * (i + 1);
                        for (let x = 0; x < i; x++) {
                            let y = x + _,
                                M = y + i + 1,
                                b = y + i + 2,
                                S = y + 1;
                            s.push(y, M, S), s.push(M, b, S)
                        }
                    }
                    this.setIndex(s), this.setAttribute("position", new tF(o, 3)), this.setAttribute("normal", new tF(l, 3)), this.setAttribute("uv", new tF(h, 2))
                }
                static fromJSON(e) {
                    return new a0(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength)
                }
            }
            class a1 extends tX {
                constructor(e = new aP([new en(0, .5), new en(-.5, -.5), new en(.5, -.5)]), t = 12) {
                    super(), this.type = "ShapeGeometry", this.parameters = {
                        shapes: e,
                        curveSegments: t
                    };
                    let i = [],
                        n = [],
                        r = [],
                        a = [],
                        s = 0,
                        o = 0;
                    if (!1 === Array.isArray(e)) h(e);
                    else
                        for (let l = 0; l < e.length; l++) h(e[l]), this.addGroup(s, o, l), s += o, o = 0;

                    function h(e) {
                        let s = n.length / 3,
                            l = e.extractPoints(t),
                            h = l.shape,
                            u = l.holes;
                        !1 === aX.isClockWise(h) && (h = h.reverse());
                        for (let c = 0, d = u.length; c < d; c++) {
                            let p = u[c];
                            !0 === aX.isClockWise(p) && (u[c] = p.reverse())
                        }
                        let f = aX.triangulateShape(h, u);
                        for (let m = 0, g = u.length; m < g; m++) {
                            let v = u[m];
                            h = h.concat(v)
                        }
                        for (let _ = 0, x = h.length; _ < x; _++) {
                            let y = h[_];
                            n.push(y.x, y.y, 0), r.push(0, 0, 1), a.push(y.x, y.y)
                        }
                        for (let M = 0, b = f.length; M < b; M++) {
                            let S = f[M],
                                w = S[0] + s,
                                T = S[1] + s,
                                E = S[2] + s;
                            i.push(w, T, E), o += 3
                        }
                    }
                    this.setIndex(i), this.setAttribute("position", new tF(n, 3)), this.setAttribute("normal", new tF(r, 3)), this.setAttribute("uv", new tF(a, 2))
                }
                toJSON() {
                    let e = super.toJSON(),
                        t = this.parameters.shapes;
                    return function(e, t) {
                        if (t.shapes = [], Array.isArray(e))
                            for (let i = 0, n = e.length; i < n; i++) {
                                let r = e[i];
                                t.shapes.push(r.uuid)
                            } else t.shapes.push(e.uuid);
                        return t
                    }(t, e)
                }
                static fromJSON(e, t) {
                    let i = [];
                    for (let n = 0, r = e.shapes.length; n < r; n++) {
                        let a = t[e.shapes[n]];
                        i.push(a)
                    }
                    return new a1(i, e.curveSegments)
                }
            }
            class a3 extends tX {
                constructor(e = 1, t = 32, i = 16, n = 0, r = 2 * Math.PI, a = 0, s = Math.PI) {
                    super(), this.type = "SphereGeometry", this.parameters = {
                        radius: e,
                        widthSegments: t,
                        heightSegments: i,
                        phiStart: n,
                        phiLength: r,
                        thetaStart: a,
                        thetaLength: s
                    }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
                    let o = Math.min(a + s, Math.PI),
                        l = 0,
                        h = [],
                        u = new eC,
                        c = new eC,
                        d = [],
                        p = [],
                        f = [],
                        m = [];
                    for (let g = 0; g <= i; g++) {
                        let v = [],
                            _ = g / i,
                            x = 0;
                        0 == g && 0 == a ? x = .5 / t : g == i && o == Math.PI && (x = -.5 / t);
                        for (let y = 0; y <= t; y++) {
                            let M = y / t;
                            u.x = -e * Math.cos(n + M * r) * Math.sin(a + _ * s), u.y = e * Math.cos(a + _ * s), u.z = e * Math.sin(n + M * r) * Math.sin(a + _ * s), p.push(u.x, u.y, u.z), c.copy(u).normalize(), f.push(c.x, c.y, c.z), m.push(M + x, 1 - _), v.push(l++)
                        }
                        h.push(v)
                    }
                    for (let b = 0; b < i; b++)
                        for (let S = 0; S < t; S++) {
                            let w = h[b][S + 1],
                                T = h[b][S],
                                E = h[b + 1][S],
                                A = h[b + 1][S + 1];
                            (0 !== b || a > 0) && d.push(w, T, A), (b !== i - 1 || o < Math.PI) && d.push(T, E, A)
                        }
                    this.setIndex(d), this.setAttribute("position", new tF(p, 3)), this.setAttribute("normal", new tF(f, 3)), this.setAttribute("uv", new tF(m, 2))
                }
                static fromJSON(e) {
                    return new a3(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
                }
            }
            class a2 extends aC {
                constructor(e = 1, t = 0) {
                    super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new a2(e.radius, e.detail)
                }
            }
            class a4 extends tX {
                constructor(e = 1, t = .4, i = 12, n = 48, r = 2 * Math.PI) {
                    super(), this.type = "TorusGeometry", this.parameters = {
                        radius: e,
                        tube: t,
                        radialSegments: i,
                        tubularSegments: n,
                        arc: r
                    }, i = Math.floor(i), n = Math.floor(n);
                    let a = [],
                        s = [],
                        o = [],
                        l = [],
                        h = new eC,
                        u = new eC,
                        c = new eC;
                    for (let d = 0; d <= i; d++)
                        for (let p = 0; p <= n; p++) {
                            let f = p / n * r,
                                m = d / i * Math.PI * 2;
                            u.x = (e + t * Math.cos(m)) * Math.cos(f), u.y = (e + t * Math.cos(m)) * Math.sin(f), u.z = t * Math.sin(m), s.push(u.x, u.y, u.z), h.x = e * Math.cos(f), h.y = e * Math.sin(f), c.subVectors(u, h).normalize(), o.push(c.x, c.y, c.z), l.push(p / n), l.push(d / i)
                        }
                    for (let g = 1; g <= i; g++)
                        for (let v = 1; v <= n; v++) {
                            let _ = (n + 1) * g + v - 1,
                                x = (n + 1) * (g - 1) + v - 1,
                                y = (n + 1) * (g - 1) + v,
                                M = (n + 1) * g + v;
                            a.push(_, x, M), a.push(x, y, M)
                        }
                    this.setIndex(a), this.setAttribute("position", new tF(s, 3)), this.setAttribute("normal", new tF(o, 3)), this.setAttribute("uv", new tF(l, 2))
                }
                static fromJSON(e) {
                    return new a4(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
                }
            }
            class a5 extends tX {
                constructor(e = 1, t = .4, i = 64, n = 8, r = 2, a = 3) {
                    super(), this.type = "TorusKnotGeometry", this.parameters = {
                        radius: e,
                        tube: t,
                        tubularSegments: i,
                        radialSegments: n,
                        p: r,
                        q: a
                    }, i = Math.floor(i), n = Math.floor(n);
                    let s = [],
                        o = [],
                        l = [],
                        h = [],
                        u = new eC,
                        c = new eC,
                        d = new eC,
                        p = new eC,
                        f = new eC,
                        m = new eC,
                        g = new eC;
                    for (let v = 0; v <= i; ++v) {
                        let _ = v / i * r * Math.PI * 2;
                        L(_, r, a, e, d), L(_ + .01, r, a, e, p), m.subVectors(p, d), g.addVectors(p, d), f.crossVectors(m, g), g.crossVectors(f, m), f.normalize(), g.normalize();
                        for (let x = 0; x <= n; ++x) {
                            let y = x / n * Math.PI * 2,
                                M = -t * Math.cos(y),
                                b = t * Math.sin(y);
                            u.x = d.x + (M * g.x + b * f.x), u.y = d.y + (M * g.y + b * f.y), u.z = d.z + (M * g.z + b * f.z), o.push(u.x, u.y, u.z), c.subVectors(u, d).normalize(), l.push(c.x, c.y, c.z), h.push(v / i), h.push(x / n)
                        }
                    }
                    for (let S = 1; S <= i; S++)
                        for (let w = 1; w <= n; w++) {
                            let T = (n + 1) * (S - 1) + (w - 1),
                                E = (n + 1) * S + (w - 1),
                                A = (n + 1) * S + w,
                                C = (n + 1) * (S - 1) + w;
                            s.push(T, E, C), s.push(E, A, C)
                        }

                    function L(e, t, i, n, r) {
                        let a = i / t * e,
                            s = Math.cos(a);
                        r.x = n * (2 + s) * .5 * Math.cos(e), r.y = n * (2 + s) * Math.sin(e) * .5, r.z = n * Math.sin(a) * .5
                    }
                    this.setIndex(s), this.setAttribute("position", new tF(o, 3)), this.setAttribute("normal", new tF(l, 3)), this.setAttribute("uv", new tF(h, 2))
                }
                static fromJSON(e) {
                    return new a5(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q)
                }
            }
            class a6 extends tX {
                constructor(e = new a_(new eC(-1, -1, 0), new eC(-1, 1, 0), new eC(1, 1, 0)), t = 64, i = 1, n = 8, r = !1) {
                    super(), this.type = "TubeGeometry", this.parameters = {
                        path: e,
                        tubularSegments: t,
                        radius: i,
                        radialSegments: n,
                        closed: r
                    };
                    let a = e.computeFrenetFrames(t, r);
                    this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
                    let s = new eC,
                        o = new eC,
                        l = new en,
                        h = new eC,
                        u = [],
                        c = [],
                        d = [],
                        p = [];

                    function f(r) {
                        h = e.getPointAt(r / t, h);
                        let l = a.normals[r],
                            d = a.binormals[r];
                        for (let p = 0; p <= n; p++) {
                            let f = p / n * Math.PI * 2,
                                m = Math.sin(f),
                                g = -Math.cos(f);
                            o.x = g * l.x + m * d.x, o.y = g * l.y + m * d.y, o.z = g * l.z + m * d.z, o.normalize(), c.push(o.x, o.y, o.z), s.x = h.x + i * o.x, s.y = h.y + i * o.y, s.z = h.z + i * o.z, u.push(s.x, s.y, s.z)
                        }
                    }(function() {
                        for (let e = 0; e < t; e++) f(e);
                        f(!1 === r ? t : 0),
                            function() {
                                for (let e = 0; e <= t; e++)
                                    for (let i = 0; i <= n; i++) l.x = e / t, l.y = i / n, d.push(l.x, l.y)
                            }(),
                            function() {
                                for (let e = 1; e <= t; e++)
                                    for (let i = 1; i <= n; i++) {
                                        let r = (n + 1) * (e - 1) + (i - 1),
                                            a = (n + 1) * e + (i - 1),
                                            s = (n + 1) * e + i,
                                            o = (n + 1) * (e - 1) + i;
                                        p.push(r, a, o), p.push(a, s, o)
                                    }
                            }()
                    })(), this.setIndex(p), this.setAttribute("position", new tF(u, 3)), this.setAttribute("normal", new tF(c, 3)), this.setAttribute("uv", new tF(d, 2))
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.path = this.parameters.path.toJSON(), e
                }
                static fromJSON(e) {
                    return new a6(new ay[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed)
                }
            }
            class a7 extends tI {
                constructor(e) {
                    super(), this.isMeshStandardMaterial = !0, this.defines = {
                        STANDARD: ""
                    }, this.type = "MeshStandardMaterial", this.color = new e_(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new e_(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = B, this.normalScale = new en(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        STANDARD: ""
                    }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                }
            }
            class a8 extends a7 {
                constructor(e) {
                    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new en(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                        get: function() {
                            return J(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                        },
                        set: function(e) {
                            this.ior = (1 + .4 * e) / (1 - .4 * e)
                        }
                    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new e_(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new e_(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new e_(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e)
                }
                get sheen() {
                    return this._sheen
                }
                set sheen(e) {
                    this._sheen > 0 != e > 0 && this.version++, this._sheen = e
                }
                get clearcoat() {
                    return this._clearcoat
                }
                set clearcoat(e) {
                    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
                }
                get iridescence() {
                    return this._iridescence
                }
                set iridescence(e) {
                    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
                }
                get transmission() {
                    return this._transmission
                }
                set transmission(e) {
                    this._transmission > 0 != e > 0 && this.version++, this._transmission = e
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
                }
            }
            class a9 extends tI {
                constructor(e) {
                    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new e_(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new e_(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = B, this.normalScale = new en(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                }
            }

            function se(e, t, i) {
                return si(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i)
            }

            function st(e, t, i) {
                return e && (i || e.constructor !== t) ? "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) : e
            }

            function si(e) {
                return ArrayBuffer.isView(e) && !(e instanceof DataView)
            }

            function sn(e, t, i) {
                let n = e.length,
                    r = new e.constructor(n);
                for (let a = 0, s = 0; s !== n; ++a) {
                    let o = i[a] * t;
                    for (let l = 0; l !== t; ++l) r[s++] = e[o + l]
                }
                return r
            }

            function sr(e, t, i, n) {
                let r = 1,
                    a = e[0];
                for (; void 0 !== a && void 0 === a[n];) a = e[r++];
                if (void 0 === a) return;
                let s = a[n];
                if (void 0 !== s) {
                    if (Array.isArray(s))
                        do void 0 !== (s = a[n]) && (t.push(a.time), i.push.apply(i, s)), a = e[r++]; while (void 0 !== a);
                    else if (void 0 !== s.toArray)
                        do void 0 !== (s = a[n]) && (t.push(a.time), s.toArray(i, i.length)), a = e[r++]; while (void 0 !== a);
                    else
                        do void 0 !== (s = a[n]) && (t.push(a.time), i.push(s)), a = e[r++]; while (void 0 !== a)
                }
            }
            class sa {
                constructor(e, t, i, n) {
                    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {}
                }
                evaluate(e) {
                    let t = this.parameterPositions,
                        i = this._cachedIndex,
                        n = t[i],
                        r = t[i - 1];
                    e: {
                        t: {
                            let a;i: {
                                n: if (!(e < n)) {
                                    for (let s = i + 2;;) {
                                        if (void 0 === n) {
                                            if (e < r) break n;
                                            return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1)
                                        }
                                        if (i === s) break;
                                        if (r = n, e < (n = t[++i])) break t
                                    }
                                    a = t.length;
                                    break i
                                }if (!(e >= r)) {
                                    let o = t[1];
                                    e < o && (i = 2, r = o);
                                    for (let l = i - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                                        if (i === l) break;
                                        if (n = r, e >= (r = t[--i - 1])) break t
                                    }
                                    a = i, i = 0;
                                    break i
                                }
                                break e
                            }
                            for (; i < a;) {
                                let h = i + a >>> 1;
                                e < t[h] ? a = h : i = h + 1
                            }
                            if (n = t[i], void 0 === (r = t[i - 1])) return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (void 0 === n) return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1)
                        }
                        this._cachedIndex = i,
                        this.intervalChanged_(i, r, n)
                    }
                    return this.interpolate_(i, r, e, n)
                }
                getSettings_() {
                    return this.settings || this.DefaultSettings_
                }
                copySampleValue_(e) {
                    let t = this.resultBuffer,
                        i = this.sampleValues,
                        n = this.valueSize,
                        r = e * n;
                    for (let a = 0; a !== n; ++a) t[a] = i[r + a];
                    return t
                }
                interpolate_() {
                    throw Error("call to abstract method")
                }
                intervalChanged_() {}
            }
            class ss extends sa {
                constructor(e, t, i, n) {
                    super(e, t, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                        endingStart: 2400,
                        endingEnd: 2400
                    }
                }
                intervalChanged_(e, t, i) {
                    let n = this.parameterPositions,
                        r = e - 2,
                        a = e + 1,
                        s = n[r],
                        o = n[a];
                    if (void 0 === s) switch (this.getSettings_().endingStart) {
                        case 2401:
                            r = e, s = 2 * t - i;
                            break;
                        case 2402:
                            r = n.length - 2, s = t + n[r] - n[r + 1];
                            break;
                        default:
                            r = e, s = i
                    }
                    if (void 0 === o) switch (this.getSettings_().endingEnd) {
                        case 2401:
                            a = e, o = 2 * i - t;
                            break;
                        case 2402:
                            a = 1, o = i + n[1] - n[0];
                            break;
                        default:
                            a = e - 1, o = t
                    }
                    let l = (i - t) * .5,
                        h = this.valueSize;
                    this._weightPrev = l / (t - s), this._weightNext = l / (o - i), this._offsetPrev = r * h, this._offsetNext = a * h
                }
                interpolate_(e, t, i, n) {
                    let r = this.resultBuffer,
                        a = this.sampleValues,
                        s = this.valueSize,
                        o = e * s,
                        l = o - s,
                        h = this._offsetPrev,
                        u = this._offsetNext,
                        c = this._weightPrev,
                        d = this._weightNext,
                        p = (i - t) / (n - t),
                        f = p * p,
                        m = f * p,
                        g = -c * m + 2 * c * f - c * p,
                        v = (1 + c) * m + (-1.5 - 2 * c) * f + (-.5 + c) * p + 1,
                        _ = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                        x = d * m - d * f;
                    for (let y = 0; y !== s; ++y) r[y] = g * a[h + y] + v * a[l + y] + _ * a[o + y] + x * a[u + y];
                    return r
                }
            }
            class so extends sa {
                constructor(e, t, i, n) {
                    super(e, t, i, n)
                }
                interpolate_(e, t, i, n) {
                    let r = this.resultBuffer,
                        a = this.sampleValues,
                        s = this.valueSize,
                        o = e * s,
                        l = o - s,
                        h = (i - t) / (n - t),
                        u = 1 - h;
                    for (let c = 0; c !== s; ++c) r[c] = a[l + c] * u + a[o + c] * h;
                    return r
                }
            }
            class sl extends sa {
                constructor(e, t, i, n) {
                    super(e, t, i, n)
                }
                interpolate_(e) {
                    return this.copySampleValue_(e - 1)
                }
            }
            class sh {
                constructor(e, t, i, n) {
                    if (void 0 === e) throw Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === t || 0 === t.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                    this.name = e, this.times = st(t, this.TimeBufferType), this.values = st(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
                }
                static toJSON(e) {
                    let t;
                    let i = e.constructor;
                    if (i.toJSON !== this.toJSON) t = i.toJSON(e);
                    else {
                        t = {
                            name: e.name,
                            times: st(e.times, Array),
                            values: st(e.values, Array)
                        };
                        let n = e.getInterpolation();
                        n !== e.DefaultInterpolation && (t.interpolation = n)
                    }
                    return t.type = e.ValueTypeName, t
                }
                InterpolantFactoryMethodDiscrete(e) {
                    return new sl(this.times, this.values, this.getValueSize(), e)
                }
                InterpolantFactoryMethodLinear(e) {
                    return new so(this.times, this.values, this.getValueSize(), e)
                }
                InterpolantFactoryMethodSmooth(e) {
                    return new ss(this.times, this.values, this.getValueSize(), e)
                }
                setInterpolation(e) {
                    let t;
                    switch (e) {
                        case R:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case I:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case 2302:
                            t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === t) {
                        let i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                            else throw Error(i)
                        }
                        return console.warn("THREE.KeyframeTrack:", i), this
                    }
                    return this.createInterpolant = t, this
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return R;
                        case this.InterpolantFactoryMethodLinear:
                            return I;
                        case this.InterpolantFactoryMethodSmooth:
                            return 2302
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length
                }
                shift(e) {
                    if (0 !== e) {
                        let t = this.times;
                        for (let i = 0, n = t.length; i !== n; ++i) t[i] += e
                    }
                    return this
                }
                scale(e) {
                    if (1 !== e) {
                        let t = this.times;
                        for (let i = 0, n = t.length; i !== n; ++i) t[i] *= e
                    }
                    return this
                }
                trim(e, t) {
                    let i = this.times,
                        n = i.length,
                        r = 0,
                        a = n - 1;
                    for (; r !== n && i[r] < e;) ++r;
                    for (; - 1 !== a && i[a] > t;) --a;
                    if (++a, 0 !== r || a !== n) {
                        r >= a && (r = (a = Math.max(a, 1)) - 1);
                        let s = this.getValueSize();
                        this.times = se(i, r, a), this.values = se(this.values, r * s, a * s)
                    }
                    return this
                }
                validate() {
                    let e = !0,
                        t = this.getValueSize();
                    t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                    let i = this.times,
                        n = this.values,
                        r = i.length;
                    0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                    let a = null;
                    for (let s = 0; s !== r; s++) {
                        let o = i[s];
                        if ("number" == typeof o && isNaN(o)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, s, o), e = !1;
                            break
                        }
                        if (null !== a && a > o) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, s, o, a), e = !1;
                            break
                        }
                        a = o
                    }
                    if (void 0 !== n && si(n))
                        for (let l = 0, h = n.length; l !== h; ++l) {
                            let u = n[l];
                            if (isNaN(u)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, l, u), e = !1;
                                break
                            }
                        }
                    return e
                }
                optimize() {
                    let e = se(this.times),
                        t = se(this.values),
                        i = this.getValueSize(),
                        n = 2302 === this.getInterpolation(),
                        r = e.length - 1,
                        a = 1;
                    for (let s = 1; s < r; ++s) {
                        let o = !1,
                            l = e[s],
                            h = e[s + 1];
                        if (l !== h && (1 !== s || l !== e[0])) {
                            if (n) o = !0;
                            else {
                                let u = s * i,
                                    c = u - i,
                                    d = u + i;
                                for (let p = 0; p !== i; ++p) {
                                    let f = t[u + p];
                                    if (f !== t[c + p] || f !== t[d + p]) {
                                        o = !0;
                                        break
                                    }
                                }
                            }
                        }
                        if (o) {
                            if (s !== a) {
                                e[a] = e[s];
                                let m = s * i,
                                    g = a * i;
                                for (let v = 0; v !== i; ++v) t[g + v] = t[m + v]
                            }++a
                        }
                    }
                    if (r > 0) {
                        e[a] = e[r];
                        for (let _ = r * i, x = a * i, y = 0; y !== i; ++y) t[x + y] = t[_ + y];
                        ++a
                    }
                    return a !== e.length ? (this.times = se(e, 0, a), this.values = se(t, 0, a * i)) : (this.times = e, this.values = t), this
                }
                clone() {
                    let e = se(this.times, 0),
                        t = se(this.values, 0),
                        i = this.constructor,
                        n = new i(this.name, e, t);
                    return n.createInterpolant = this.createInterpolant, n
                }
            }
            sh.prototype.TimeBufferType = Float32Array, sh.prototype.ValueBufferType = Float32Array, sh.prototype.DefaultInterpolation = I;
            class su extends sh {}
            su.prototype.ValueTypeName = "bool", su.prototype.ValueBufferType = Array, su.prototype.DefaultInterpolation = R, su.prototype.InterpolantFactoryMethodLinear = void 0, su.prototype.InterpolantFactoryMethodSmooth = void 0;
            class sc extends sh {}
            sc.prototype.ValueTypeName = "color";
            class sd extends sh {}
            sd.prototype.ValueTypeName = "number";
            class sp extends sa {
                constructor(e, t, i, n) {
                    super(e, t, i, n)
                }
                interpolate_(e, t, i, n) {
                    let r = this.resultBuffer,
                        a = this.sampleValues,
                        s = this.valueSize,
                        o = (i - t) / (n - t),
                        l = e * s;
                    for (let h = l + s; l !== h; l += 4) eA.slerpFlat(r, 0, a, l - s, a, l, o);
                    return r
                }
            }
            class sf extends sh {
                InterpolantFactoryMethodLinear(e) {
                    return new sp(this.times, this.values, this.getValueSize(), e)
                }
            }
            sf.prototype.ValueTypeName = "quaternion", sf.prototype.DefaultInterpolation = I, sf.prototype.InterpolantFactoryMethodSmooth = void 0;
            class sm extends sh {}
            sm.prototype.ValueTypeName = "string", sm.prototype.ValueBufferType = Array, sm.prototype.DefaultInterpolation = R, sm.prototype.InterpolantFactoryMethodLinear = void 0, sm.prototype.InterpolantFactoryMethodSmooth = void 0;
            class sg extends sh {}
            sg.prototype.ValueTypeName = "vector";
            class sv {
                constructor(e, t = -1, i, n = 2500) {
                    this.name = e, this.tracks = i, this.duration = t, this.blendMode = n, this.uuid = X(), this.duration < 0 && this.resetDuration()
                }
                static parse(e) {
                    let t = [],
                        i = e.tracks,
                        n = 1 / (e.fps || 1);
                    for (let r = 0, a = i.length; r !== a; ++r) t.push((function(e) {
                        if (void 0 === e.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
                        let t = function(e) {
                            switch (e.toLowerCase()) {
                                case "scalar":
                                case "double":
                                case "float":
                                case "number":
                                case "integer":
                                    return sd;
                                case "vector":
                                case "vector2":
                                case "vector3":
                                case "vector4":
                                    return sg;
                                case "color":
                                    return sc;
                                case "quaternion":
                                    return sf;
                                case "bool":
                                case "boolean":
                                    return su;
                                case "string":
                                    return sm
                            }
                            throw Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                        }(e.type);
                        if (void 0 === e.times) {
                            let i = [],
                                n = [];
                            sr(e.keys, i, n, "value"), e.times = i, e.values = n
                        }
                        return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
                    })(i[r]).scale(n));
                    let s = new this(e.name, e.duration, t, e.blendMode);
                    return s.uuid = e.uuid, s
                }
                static toJSON(e) {
                    let t = [],
                        i = e.tracks,
                        n = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid,
                            blendMode: e.blendMode
                        };
                    for (let r = 0, a = i.length; r !== a; ++r) t.push(sh.toJSON(i[r]));
                    return n
                }
                static CreateFromMorphTargetSequence(e, t, i, n) {
                    let r = t.length,
                        a = [];
                    for (let s = 0; s < r; s++) {
                        let o = [],
                            l = [];
                        o.push((s + r - 1) % r, s, (s + 1) % r), l.push(0, 1, 0);
                        let h = function(e) {
                            let t = e.length,
                                i = Array(t);
                            for (let n = 0; n !== t; ++n) i[n] = n;
                            return i.sort(function(t, i) {
                                return e[t] - e[i]
                            }), i
                        }(o);
                        o = sn(o, 1, h), l = sn(l, 1, h), n || 0 !== o[0] || (o.push(r), l.push(l[0])), a.push(new sd(".morphTargetInfluences[" + t[s].name + "]", o, l).scale(1 / i))
                    }
                    return new this(e, -1, a)
                }
                static findByName(e, t) {
                    let i = e;
                    Array.isArray(e) || (i = e.geometry && e.geometry.animations || e.animations);
                    for (let n = 0; n < i.length; n++)
                        if (i[n].name === t) return i[n];
                    return null
                }
                static CreateClipsFromMorphTargetSequences(e, t, i) {
                    let n = {},
                        r = /^([\w-]*?)([\d]+)$/;
                    for (let a = 0, s = e.length; a < s; a++) {
                        let o = e[a],
                            l = o.name.match(r);
                        if (l && l.length > 1) {
                            let h = l[1],
                                u = n[h];
                            u || (n[h] = u = []), u.push(o)
                        }
                    }
                    let c = [];
                    for (let d in n) c.push(this.CreateFromMorphTargetSequence(d, n[d], t, i));
                    return c
                }
                static parseAnimation(e, t) {
                    if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    let i = function(e, t, i, n, r) {
                            if (0 !== i.length) {
                                let a = [],
                                    s = [];
                                sr(i, a, s, n), 0 !== a.length && r.push(new e(t, a, s))
                            }
                        },
                        n = [],
                        r = e.name || "default",
                        a = e.fps || 30,
                        s = e.blendMode,
                        o = e.length || -1,
                        l = e.hierarchy || [];
                    for (let h = 0; h < l.length; h++) {
                        let u = l[h].keys;
                        if (u && 0 !== u.length) {
                            if (u[0].morphTargets) {
                                let c;
                                let d = {};
                                for (c = 0; c < u.length; c++)
                                    if (u[c].morphTargets)
                                        for (let p = 0; p < u[c].morphTargets.length; p++) d[u[c].morphTargets[p]] = -1;
                                for (let f in d) {
                                    let m = [],
                                        g = [];
                                    for (let v = 0; v !== u[c].morphTargets.length; ++v) {
                                        let _ = u[c];
                                        m.push(_.time), g.push(_.morphTarget === f ? 1 : 0)
                                    }
                                    n.push(new sd(".morphTargetInfluence[" + f + "]", m, g))
                                }
                                o = d.length * a
                            } else {
                                let x = ".bones[" + t[h].name + "]";
                                i(sg, x + ".position", u, "pos", n), i(sf, x + ".quaternion", u, "rot", n), i(sg, x + ".scale", u, "scl", n)
                            }
                        }
                    }
                    if (0 === n.length) return null;
                    let y = new this(r, o, n, s);
                    return y
                }
                resetDuration() {
                    let e = this.tracks,
                        t = 0;
                    for (let i = 0, n = e.length; i !== n; ++i) {
                        let r = this.tracks[i];
                        t = Math.max(t, r.times[r.times.length - 1])
                    }
                    return this.duration = t, this
                }
                trim() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                    return this
                }
                validate() {
                    let e = !0;
                    for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                    return e
                }
                optimize() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                    return this
                }
                clone() {
                    let e = [];
                    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                    return new this.constructor(this.name, this.duration, e, this.blendMode)
                }
                toJSON() {
                    return this.constructor.toJSON(this)
                }
            }
            let s_ = {
                    enabled: !1,
                    files: {},
                    add: function(e, t) {
                        !1 !== this.enabled && (this.files[e] = t)
                    },
                    get: function(e) {
                        if (!1 !== this.enabled) return this.files[e]
                    },
                    remove: function(e) {
                        delete this.files[e]
                    },
                    clear: function() {
                        this.files = {}
                    }
                },
                sx = new class {
                    constructor(e, t, i) {
                        let n;
                        let r = this,
                            a = !1,
                            s = 0,
                            o = 0,
                            l = [];
                        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(e) {
                            o++, !1 === a && void 0 !== r.onStart && r.onStart(e, s, o), a = !0
                        }, this.itemEnd = function(e) {
                            s++, void 0 !== r.onProgress && r.onProgress(e, s, o), s === o && (a = !1, void 0 !== r.onLoad && r.onLoad())
                        }, this.itemError = function(e) {
                            void 0 !== r.onError && r.onError(e)
                        }, this.resolveURL = function(e) {
                            return n ? n(e) : e
                        }, this.setURLModifier = function(e) {
                            return n = e, this
                        }, this.addHandler = function(e, t) {
                            return l.push(e, t), this
                        }, this.removeHandler = function(e) {
                            let t = l.indexOf(e);
                            return -1 !== t && l.splice(t, 2), this
                        }, this.getHandler = function(e) {
                            for (let t = 0, i = l.length; t < i; t += 2) {
                                let n = l[t],
                                    r = l[t + 1];
                                if (n.global && (n.lastIndex = 0), n.test(e)) return r
                            }
                            return null
                        }
                    }
                };
            class sy {
                constructor(e) {
                    this.manager = void 0 !== e ? e : sx, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                }
                load() {}
                loadAsync(e, t) {
                    let i = this;
                    return new Promise(function(n, r) {
                        i.load(e, n, t, r)
                    })
                }
                parse() {}
                setCrossOrigin(e) {
                    return this.crossOrigin = e, this
                }
                setWithCredentials(e) {
                    return this.withCredentials = e, this
                }
                setPath(e) {
                    return this.path = e, this
                }
                setResourcePath(e) {
                    return this.resourcePath = e, this
                }
                setRequestHeader(e) {
                    return this.requestHeader = e, this
                }
            }
            let sM = {};
            class sb extends Error {
                constructor(e, t) {
                    super(e), this.response = t
                }
            }
            class sS extends sy {
                constructor(e) {
                    super(e)
                }
                load(e, t, i, n) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    let r = s_.get(e);
                    if (void 0 !== r) return this.manager.itemStart(e), setTimeout(() => {
                        t && t(r), this.manager.itemEnd(e)
                    }, 0), r;
                    if (void 0 !== sM[e]) {
                        sM[e].push({
                            onLoad: t,
                            onProgress: i,
                            onError: n
                        });
                        return
                    }
                    sM[e] = [], sM[e].push({
                        onLoad: t,
                        onProgress: i,
                        onError: n
                    });
                    let a = new Request(e, {
                            headers: new Headers(this.requestHeader),
                            credentials: this.withCredentials ? "include" : "same-origin"
                        }),
                        s = this.mimeType,
                        o = this.responseType;
                    fetch(a).then(t => {
                        if (200 === t.status || 0 === t.status) {
                            if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t;
                            let i = sM[e],
                                n = t.body.getReader(),
                                r = t.headers.get("Content-Length") || t.headers.get("X-File-Size"),
                                a = r ? parseInt(r) : 0,
                                s = 0 !== a,
                                o = 0,
                                l = new ReadableStream({
                                    start(e) {
                                        (function t() {
                                            n.read().then(({
                                                done: n,
                                                value: r
                                            }) => {
                                                if (n) e.close();
                                                else {
                                                    o += r.byteLength;
                                                    let l = new ProgressEvent("progress", {
                                                        lengthComputable: s,
                                                        loaded: o,
                                                        total: a
                                                    });
                                                    for (let h = 0, u = i.length; h < u; h++) {
                                                        let c = i[h];
                                                        c.onProgress && c.onProgress(l)
                                                    }
                                                    e.enqueue(r), t()
                                                }
                                            })
                                        })()
                                    }
                                });
                            return new Response(l)
                        }
                        throw new sb(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`, t)
                    }).then(e => {
                        switch (o) {
                            case "arraybuffer":
                                return e.arrayBuffer();
                            case "blob":
                                return e.blob();
                            case "document":
                                return e.text().then(e => {
                                    let t = new DOMParser;
                                    return t.parseFromString(e, s)
                                });
                            case "json":
                                return e.json();
                            default:
                                if (void 0 === s) return e.text(); {
                                    let t = /charset="?([^;"\s]*)"?/i.exec(s),
                                        i = t && t[1] ? t[1].toLowerCase() : void 0,
                                        n = new TextDecoder(i);
                                    return e.arrayBuffer().then(e => n.decode(e))
                                }
                        }
                    }).then(t => {
                        s_.add(e, t);
                        let i = sM[e];
                        delete sM[e];
                        for (let n = 0, r = i.length; n < r; n++) {
                            let a = i[n];
                            a.onLoad && a.onLoad(t)
                        }
                    }).catch(t => {
                        let i = sM[e];
                        if (void 0 === i) throw this.manager.itemError(e), t;
                        delete sM[e];
                        for (let n = 0, r = i.length; n < r; n++) {
                            let a = i[n];
                            a.onError && a.onError(t)
                        }
                        this.manager.itemError(e)
                    }).finally(() => {
                        this.manager.itemEnd(e)
                    }), this.manager.itemStart(e)
                }
                setResponseType(e) {
                    return this.responseType = e, this
                }
                setMimeType(e) {
                    return this.mimeType = e, this
                }
            }
            class sw extends sy {
                constructor(e) {
                    super(e)
                }
                load(e, t, i, n) {
                    void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    let r = this,
                        a = s_.get(e);
                    if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function() {
                        t && t(a), r.manager.itemEnd(e)
                    }, 0), a;
                    let s = eo("img");

                    function o() {
                        h(), s_.add(e, this), t && t(this), r.manager.itemEnd(e)
                    }

                    function l(t) {
                        h(), n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    }

                    function h() {
                        s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1)
                    }
                    return s.addEventListener("load", o, !1), s.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(e), s.src = e, s
                }
            }
            class sT extends sy {
                constructor(e) {
                    super(e)
                }
                load(e, t, i, n) {
                    let r = new ih,
                        a = new sw(this.manager);
                    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
                    let s = 0;
                    for (let o = 0; o < e.length; ++o) ! function(i) {
                        a.load(e[i], function(e) {
                            r.images[i] = e, 6 == ++s && (r.needsUpdate = !0, t && t(r))
                        }, void 0, n)
                    }(o);
                    return r
                }
            }
            class sE extends sy {
                constructor(e) {
                    super(e)
                }
                load(e, t, i, n) {
                    let r = new eS,
                        a = new sw(this.manager);
                    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(e) {
                        r.image = e, r.needsUpdate = !0, void 0 !== t && t(r)
                    }, i, n), r
                }
            }
            class sA extends tx {
                constructor(e, t = 1) {
                    super(), this.isLight = !0, this.type = "Light", this.color = new e_(e), this.intensity = t
                }
                dispose() {}
                copy(e, t) {
                    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
                }
                toJSON(e) {
                    let t = super.toJSON(e);
                    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
                }
            }
            let sC = new e4,
                sL = new eC,
                sP = new eC;
            class sR {
                constructor(e) {
                    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new en(512, 512), this.map = null, this.mapPass = null, this.matrix = new e4, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new i_, this._frameExtents = new en(1, 1), this._viewportCount = 1, this._viewports = [new ew(0, 0, 1, 1)]
                }
                getViewportCount() {
                    return this._viewportCount
                }
                getFrustum() {
                    return this._frustum
                }
                updateMatrices(e) {
                    let t = this.camera,
                        i = this.matrix;
                    sL.setFromMatrixPosition(e.matrixWorld), t.position.copy(sL), sP.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(sP), t.updateMatrixWorld(), sC.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(sC), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(sC)
                }
                getViewport(e) {
                    return this._viewports[e]
                }
                getFrameExtents() {
                    return this._frameExtents
                }
                dispose() {
                    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                }
                copy(e) {
                    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                toJSON() {
                    let e = {};
                    return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), (512 !== this.mapSize.x || 512 !== this.mapSize.y) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
                }
            }
            class sI extends sR {
                constructor() {
                    super(new io(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
                }
                updateMatrices(e) {
                    let t = this.camera,
                        i = 2 * q * e.angle * this.focus,
                        n = this.mapSize.width / this.mapSize.height,
                        r = e.distance || t.far;
                    (i !== t.fov || n !== t.aspect || r !== t.far) && (t.fov = i, t.aspect = n, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e)
                }
                copy(e) {
                    return super.copy(e), this.focus = e.focus, this
                }
            }
            class sD extends sA {
                constructor(e, t, i = 0, n = Math.PI / 3, r = 0, a = 2) {
                    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(tx.DefaultUp), this.updateMatrix(), this.target = new tx, this.distance = i, this.angle = n, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new sI
                }
                get power() {
                    return this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / Math.PI
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e, t) {
                    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }
            let sN = new e4,
                sO = new eC,
                sz = new eC;
            class sU extends sR {
                constructor() {
                    super(new io(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new en(4, 2), this._viewportCount = 6, this._viewports = [new ew(2, 1, 1, 1), new ew(0, 1, 1, 1), new ew(3, 1, 1, 1), new ew(1, 1, 1, 1), new ew(3, 0, 1, 1), new ew(1, 0, 1, 1)], this._cubeDirections = [new eC(1, 0, 0), new eC(-1, 0, 0), new eC(0, 0, 1), new eC(0, 0, -1), new eC(0, 1, 0), new eC(0, -1, 0)], this._cubeUps = [new eC(0, 1, 0), new eC(0, 1, 0), new eC(0, 1, 0), new eC(0, 1, 0), new eC(0, 0, 1), new eC(0, 0, -1)]
                }
                updateMatrices(e, t = 0) {
                    let i = this.camera,
                        n = this.matrix,
                        r = e.distance || i.far;
                    r !== i.far && (i.far = r, i.updateProjectionMatrix()), sO.setFromMatrixPosition(e.matrixWorld), i.position.copy(sO), sz.copy(i.position), sz.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(sz), i.updateMatrixWorld(), n.makeTranslation(-sO.x, -sO.y, -sO.z), sN.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(sN)
                }
            }
            class sB extends sA {
                constructor(e, t, i = 0, n = 2) {
                    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new sU
                }
                get power() {
                    return 4 * this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / (4 * Math.PI)
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e, t) {
                    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                }
            }
            class sF extends sR {
                constructor() {
                    super(new iI(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
                }
            }
            class sk extends sA {
                constructor(e, t) {
                    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(tx.DefaultUp), this.updateMatrix(), this.target = new tx, this.shadow = new sF
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e) {
                    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }
            class sV extends sA {
                constructor(e, t) {
                    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
                }
            }
            class sG {
                static decodeText(e) {
                    if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(e);
                    let t = "";
                    for (let i = 0, n = e.length; i < n; i++) t += String.fromCharCode(e[i]);
                    try {
                        return decodeURIComponent(escape(t))
                    } catch (r) {
                        return t
                    }
                }
                static extractUrlBase(e) {
                    let t = e.lastIndexOf("/");
                    return -1 === t ? "./" : e.slice(0, t + 1)
                }
                static resolveURL(e, t) {
                    return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e)) ? e : t + e
                }
            }
            class sW extends tX {
                constructor() {
                    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                }
                copy(e) {
                    return super.copy(e), this.instanceCount = e.instanceCount, this
                }
                toJSON() {
                    let e = super.toJSON();
                    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
                }
            }
            class sH extends sy {
                constructor(e) {
                    super(e), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                        premultiplyAlpha: "none"
                    }
                }
                setOptions(e) {
                    return this.options = e, this
                }
                load(e, t, i, n) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    let r = this,
                        a = s_.get(e);
                    if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function() {
                        t && t(a), r.manager.itemEnd(e)
                    }, 0), a;
                    let s = {};
                    s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s.headers = this.requestHeader, fetch(e, s).then(function(e) {
                        return e.blob()
                    }).then(function(e) {
                        return createImageBitmap(e, Object.assign(r.options, {
                            colorSpaceConversion: "none"
                        }))
                    }).then(function(i) {
                        s_.add(e, i), t && t(i), r.manager.itemEnd(e)
                    }).catch(function(t) {
                        n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    }), r.manager.itemStart(e)
                }
            }
            class sj {
                constructor(e = !0) {
                    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                }
                start() {
                    this.startTime = sq(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                }
                stop() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                }
                getElapsedTime() {
                    return this.getDelta(), this.elapsedTime
                }
                getDelta() {
                    let e = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        let t = sq();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            }

            function sq() {
                return ("undefined" == typeof performance ? Date : performance).now()
            }
            class sX {
                constructor(e, t, i) {
                    let n, r, a;
                    switch (this.binding = e, this.valueSize = i, t) {
                        case "quaternion":
                            n = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i), this._workIndex = 5;
                            break;
                        case "string":
                        case "bool":
                            n = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = Array(5 * i);
                            break;
                        default:
                            n = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i)
                    }
                    this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                }
                accumulate(e, t) {
                    let i = this.buffer,
                        n = this.valueSize,
                        r = e * n + n,
                        a = this.cumulativeWeight;
                    if (0 === a) {
                        for (let s = 0; s !== n; ++s) i[r + s] = i[s];
                        a = t
                    } else {
                        a += t;
                        let o = t / a;
                        this._mixBufferRegion(i, r, 0, o, n)
                    }
                    this.cumulativeWeight = a
                }
                accumulateAdditive(e) {
                    let t = this.buffer,
                        i = this.valueSize,
                        n = i * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, n, 0, e, i), this.cumulativeWeightAdditive += e
                }
                apply(e) {
                    let t = this.valueSize,
                        i = this.buffer,
                        n = e * t + t,
                        r = this.cumulativeWeight,
                        a = this.cumulativeWeightAdditive,
                        s = this.binding;
                    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                        let o = t * this._origIndex;
                        this._mixBufferRegion(i, n, o, 1 - r, t)
                    }
                    a > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * t, 1, t);
                    for (let l = t, h = t + t; l !== h; ++l)
                        if (i[l] !== i[l + t]) {
                            s.setValue(i, n);
                            break
                        }
                }
                saveOriginalState() {
                    let e = this.binding,
                        t = this.buffer,
                        i = this.valueSize,
                        n = i * this._origIndex;
                    e.getValue(t, n);
                    for (let r = i; r !== n; ++r) t[r] = t[n + r % i];
                    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                }
                restoreOriginalState() {
                    let e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e)
                }
                _setAdditiveIdentityNumeric() {
                    let e = this._addIndex * this.valueSize,
                        t = e + this.valueSize;
                    for (let i = e; i < t; i++) this.buffer[i] = 0
                }
                _setAdditiveIdentityQuaternion() {
                    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                }
                _setAdditiveIdentityOther() {
                    let e = this._origIndex * this.valueSize,
                        t = this._addIndex * this.valueSize;
                    for (let i = 0; i < this.valueSize; i++) this.buffer[t + i] = this.buffer[e + i]
                }
                _select(e, t, i, n, r) {
                    if (n >= .5)
                        for (let a = 0; a !== r; ++a) e[t + a] = e[i + a]
                }
                _slerp(e, t, i, n) {
                    eA.slerpFlat(e, t, e, t, e, i, n)
                }
                _slerpAdditive(e, t, i, n, r) {
                    let a = this._workIndex * r;
                    eA.multiplyQuaternionsFlat(e, a, e, t, e, i), eA.slerpFlat(e, t, e, t, e, a, n)
                }
                _lerp(e, t, i, n, r) {
                    let a = 1 - n;
                    for (let s = 0; s !== r; ++s) {
                        let o = t + s;
                        e[o] = e[o] * a + e[i + s] * n
                    }
                }
                _lerpAdditive(e, t, i, n, r) {
                    for (let a = 0; a !== r; ++a) {
                        let s = t + a;
                        e[s] = e[s] + e[i + a] * n
                    }
                }
            }
            let sJ = "\\[\\]\\.:\\/",
                sY = RegExp("[" + sJ + "]", "g"),
                sZ = "[^" + sJ + "]",
                sK = "[^" + sJ.replace("\\.", "") + "]",
                sQ = /((?:WC+[\/:])*)/.source.replace("WC", sZ),
                s$ = /(WCOD+)?/.source.replace("WCOD", sK),
                s0 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", sZ),
                s1 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", sZ),
                s3 = RegExp("^" + sQ + s$ + s0 + s1 + "$"),
                s2 = ["material", "materials", "bones", "map"];
            class s4 {
                constructor(e, t, i) {
                    this.path = t, this.parsedPath = i || s4.parseTrackName(t), this.node = s4.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
                static create(e, t, i) {
                    return e && e.isAnimationObjectGroup ? new s4.Composite(e, t, i) : new s4(e, t, i)
                }
                static sanitizeNodeName(e) {
                    return e.replace(/\s/g, "_").replace(sY, "")
                }
                static parseTrackName(e) {
                    let t = s3.exec(e);
                    if (null === t) throw Error("PropertyBinding: Cannot parse trackName: " + e);
                    let i = {
                            nodeName: t[2],
                            objectName: t[3],
                            objectIndex: t[4],
                            propertyName: t[5],
                            propertyIndex: t[6]
                        },
                        n = i.nodeName && i.nodeName.lastIndexOf(".");
                    if (void 0 !== n && -1 !== n) {
                        let r = i.nodeName.substring(n + 1); - 1 !== s2.indexOf(r) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = r)
                    }
                    if (null === i.propertyName || 0 === i.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return i
                }
                static findNode(e, t) {
                    if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                    if (e.skeleton) {
                        let i = e.skeleton.getBoneByName(t);
                        if (void 0 !== i) return i
                    }
                    if (e.children) {
                        let n = function(e) {
                                for (let i = 0; i < e.length; i++) {
                                    let r = e[i];
                                    if (r.name === t || r.uuid === t) return r;
                                    let a = n(r.children);
                                    if (a) return a
                                }
                                return null
                            },
                            r = n(e.children);
                        if (r) return r
                    }
                    return null
                }
                _getValue_unavailable() {}
                _setValue_unavailable() {}
                _getValue_direct(e, t) {
                    e[t] = this.targetObject[this.propertyName]
                }
                _getValue_array(e, t) {
                    let i = this.resolvedProperty;
                    for (let n = 0, r = i.length; n !== r; ++n) e[t++] = i[n]
                }
                _getValue_arrayElement(e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }
                _getValue_toArray(e, t) {
                    this.resolvedProperty.toArray(e, t)
                }
                _setValue_direct(e, t) {
                    this.targetObject[this.propertyName] = e[t]
                }
                _setValue_direct_setNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_array(e, t) {
                    let i = this.resolvedProperty;
                    for (let n = 0, r = i.length; n !== r; ++n) i[n] = e[t++]
                }
                _setValue_array_setNeedsUpdate(e, t) {
                    let i = this.resolvedProperty;
                    for (let n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
                    this.targetObject.needsUpdate = !0
                }
                _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                    let i = this.resolvedProperty;
                    for (let n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_arrayElement(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t]
                }
                _setValue_arrayElement_setNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_fromArray(e, t) {
                    this.resolvedProperty.fromArray(e, t)
                }
                _setValue_fromArray_setNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _getValue_unbound(e, t) {
                    this.bind(), this.getValue(e, t)
                }
                _setValue_unbound(e, t) {
                    this.bind(), this.setValue(e, t)
                }
                bind() {
                    let e = this.node,
                        t = this.parsedPath,
                        i = t.objectName,
                        n = t.propertyName,
                        r = t.propertyIndex;
                    if (e || (e = s4.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
                        console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                        return
                    }
                    if (i) {
                        let a = t.objectIndex;
                        switch (i) {
                            case "materials":
                                if (!e.material) {
                                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!e.material.materials) {
                                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    return
                                }
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton) {
                                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    return
                                }
                                e = e.skeleton.bones;
                                for (let s = 0; s < e.length; s++)
                                    if (e[s].name === a) {
                                        a = s;
                                        break
                                    }
                                break;
                            case "map":
                                if ("map" in e) {
                                    e = e.map;
                                    break
                                }
                                if (!e.material) {
                                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!e.material.map) {
                                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                    return
                                }
                                e = e.material.map;
                                break;
                            default:
                                if (void 0 === e[i]) {
                                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    return
                                }
                                e = e[i]
                        }
                        if (void 0 !== a) {
                            if (void 0 === e[a]) {
                                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                                return
                            }
                            e = e[a]
                        }
                    }
                    let o = e[n];
                    if (void 0 === o) {
                        let l = t.nodeName;
                        console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + n + " but it wasn't found.", e);
                        return
                    }
                    let h = this.Versioning.None;
                    this.targetObject = e, void 0 !== e.needsUpdate ? h = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (h = this.Versioning.MatrixWorldNeedsUpdate);
                    let u = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === n) {
                            if (!e.geometry) {
                                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                return
                            }
                            if (!e.geometry.morphAttributes) {
                                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                return
                            }
                            void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                        }
                        u = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
                    } else void 0 !== o.fromArray && void 0 !== o.toArray ? (u = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (u = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[u], this.setValue = this.SetterByBindingTypeAndVersioning[u][h]
                }
                unbind() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }
            s4.Composite = class {
                constructor(e, t, i) {
                    let n = i || s4.parseTrackName(t);
                    this._targetGroup = e, this._bindings = e.subscribe_(t, n)
                }
                getValue(e, t) {
                    this.bind();
                    let i = this._targetGroup.nCachedObjects_,
                        n = this._bindings[i];
                    void 0 !== n && n.getValue(e, t)
                }
                setValue(e, t) {
                    let i = this._bindings;
                    for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(e, t)
                }
                bind() {
                    let e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
                }
                unbind() {
                    let e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
                }
            }, s4.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            }, s4.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            }, s4.prototype.GetterByBindingType = [s4.prototype._getValue_direct, s4.prototype._getValue_array, s4.prototype._getValue_arrayElement, s4.prototype._getValue_toArray], s4.prototype.SetterByBindingTypeAndVersioning = [
                [s4.prototype._setValue_direct, s4.prototype._setValue_direct_setNeedsUpdate, s4.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                [s4.prototype._setValue_array, s4.prototype._setValue_array_setNeedsUpdate, s4.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                [s4.prototype._setValue_arrayElement, s4.prototype._setValue_arrayElement_setNeedsUpdate, s4.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                [s4.prototype._setValue_fromArray, s4.prototype._setValue_fromArray_setNeedsUpdate, s4.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
            ];
            class s5 {
                constructor(e, t, i = null, n = t.blendMode) {
                    this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = n;
                    let r = t.tracks,
                        a = r.length,
                        s = Array(a),
                        o = {
                            endingStart: 2400,
                            endingEnd: 2400
                        };
                    for (let l = 0; l !== a; ++l) {
                        let h = r[l].createInterpolant(null);
                        s[l] = h, h.settings = o
                    }
                    this._interpolantSettings = o, this._interpolants = s, this._propertyBindings = Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                }
                play() {
                    return this._mixer._activateAction(this), this
                }
                stop() {
                    return this._mixer._deactivateAction(this), this.reset()
                }
                reset() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                }
                isRunning() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                }
                isScheduled() {
                    return this._mixer._isActiveAction(this)
                }
                startAt(e) {
                    return this._startTime = e, this
                }
                setLoop(e, t) {
                    return this.loop = e, this.repetitions = t, this
                }
                setEffectiveWeight(e) {
                    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
                }
                getEffectiveWeight() {
                    return this._effectiveWeight
                }
                fadeIn(e) {
                    return this._scheduleFading(e, 0, 1)
                }
                fadeOut(e) {
                    return this._scheduleFading(e, 1, 0)
                }
                crossFadeFrom(e, t, i) {
                    if (e.fadeOut(t), this.fadeIn(t), i) {
                        let n = this._clip.duration,
                            r = e._clip.duration;
                        e.warp(1, r / n, t), this.warp(n / r, 1, t)
                    }
                    return this
                }
                crossFadeTo(e, t, i) {
                    return e.crossFadeFrom(this, t, i)
                }
                stopFading() {
                    let e = this._weightInterpolant;
                    return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                }
                setEffectiveTimeScale(e) {
                    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
                }
                getEffectiveTimeScale() {
                    return this._effectiveTimeScale
                }
                setDuration(e) {
                    return this.timeScale = this._clip.duration / e, this.stopWarping()
                }
                syncWith(e) {
                    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
                }
                halt(e) {
                    return this.warp(this._effectiveTimeScale, 0, e)
                }
                warp(e, t, i) {
                    let n = this._mixer,
                        r = n.time,
                        a = this.timeScale,
                        s = this._timeScaleInterpolant;
                    null === s && (s = n._lendControlInterpolant(), this._timeScaleInterpolant = s);
                    let o = s.parameterPositions,
                        l = s.sampleValues;
                    return o[0] = r, o[1] = r + i, l[0] = e / a, l[1] = t / a, this
                }
                stopWarping() {
                    let e = this._timeScaleInterpolant;
                    return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                }
                getMixer() {
                    return this._mixer
                }
                getClip() {
                    return this._clip
                }
                getRoot() {
                    return this._localRoot || this._mixer._root
                }
                _update(e, t, i, n) {
                    if (!this.enabled) {
                        this._updateWeight(e);
                        return
                    }
                    let r = this._startTime;
                    if (null !== r) {
                        let a = (e - r) * i;
                        a < 0 || 0 === i ? t = 0 : (this._startTime = null, t = i * a)
                    }
                    t *= this._updateTimeScale(e);
                    let s = this._updateTime(t),
                        o = this._updateWeight(e);
                    if (o > 0) {
                        let l = this._interpolants,
                            h = this._propertyBindings;
                        if (2501 === this.blendMode)
                            for (let u = 0, c = l.length; u !== c; ++u) l[u].evaluate(s), h[u].accumulateAdditive(o);
                        else
                            for (let d = 0, p = l.length; d !== p; ++d) l[d].evaluate(s), h[d].accumulate(n, o)
                    }
                }
                _updateWeight(e) {
                    let t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        let i = this._weightInterpolant;
                        if (null !== i) {
                            let n = i.evaluate(e)[0];
                            t *= n, e > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = t, t
                }
                _updateTimeScale(e) {
                    let t = 0;
                    if (!this.paused) {
                        t = this.timeScale;
                        let i = this._timeScaleInterpolant;
                        if (null !== i) {
                            let n = i.evaluate(e)[0];
                            t *= n, e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                        }
                    }
                    return this._effectiveTimeScale = t, t
                }
                _updateTime(e) {
                    let t = this._clip.duration,
                        i = this.loop,
                        n = this.time + e,
                        r = this._loopCount,
                        a = 2202 === i;
                    if (0 === e) return -1 === r ? n : a && (1 & r) == 1 ? t - n : n;
                    if (2200 === i) {
                        -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        r: {
                            if (n >= t) n = t;
                            else if (n < 0) n = 0;
                            else {
                                this.time = n;
                                break r
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = n,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === r && (e >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), n >= t || n < 0) {
                            let s = Math.floor(n / t);
                            n -= t * s, r += Math.abs(s);
                            let o = this.repetitions - r;
                            if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, n = e > 0 ? t : 0, this.time = n, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e > 0 ? 1 : -1
                            });
                            else {
                                if (1 === o) {
                                    let l = e < 0;
                                    this._setEndings(l, !l, a)
                                } else this._setEndings(!1, !1, a);
                                this._loopCount = r, this.time = n, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: s
                                })
                            }
                        } else this.time = n;
                        if (a && (1 & r) == 1) return t - n
                    }
                    return n
                }
                _setEndings(e, t, i) {
                    let n = this._interpolantSettings;
                    i ? (n.endingStart = 2401, n.endingEnd = 2401) : (e ? n.endingStart = this.zeroSlopeAtStart ? 2401 : 2400 : n.endingStart = 2402, t ? n.endingEnd = this.zeroSlopeAtEnd ? 2401 : 2400 : n.endingEnd = 2402)
                }
                _scheduleFading(e, t, i) {
                    let n = this._mixer,
                        r = n.time,
                        a = this._weightInterpolant;
                    null === a && (a = n._lendControlInterpolant(), this._weightInterpolant = a);
                    let s = a.parameterPositions,
                        o = a.sampleValues;
                    return s[0] = r, o[0] = t, s[1] = r + e, o[1] = i, this
                }
            }
            let s6 = new Float32Array(1);
            class s7 extends G {
                constructor(e) {
                    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                }
                _bindAction(e, t) {
                    let i = e._localRoot || this._root,
                        n = e._clip.tracks,
                        r = n.length,
                        a = e._propertyBindings,
                        s = e._interpolants,
                        o = i.uuid,
                        l = this._bindingsByRootAndName,
                        h = l[o];
                    void 0 === h && (h = {}, l[o] = h);
                    for (let u = 0; u !== r; ++u) {
                        let c = n[u],
                            d = c.name,
                            p = h[d];
                        if (void 0 !== p) ++p.referenceCount, a[u] = p;
                        else {
                            if (void 0 !== (p = a[u])) {
                                null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, o, d));
                                continue
                            }
                            let f = t && t._propertyBindings[u].binding.parsedPath;
                            p = new sX(s4.create(i, d, f), c.ValueTypeName, c.getValueSize()), ++p.referenceCount, this._addInactiveBinding(p, o, d), a[u] = p
                        }
                        s[u].resultBuffer = p.buffer
                    }
                }
                _activateAction(e) {
                    if (!this._isActiveAction(e)) {
                        if (null === e._cacheIndex) {
                            let t = (e._localRoot || this._root).uuid,
                                i = e._clip.uuid,
                                n = this._actionsByClip[i];
                            this._bindAction(e, n && n.knownActions[0]), this._addInactiveAction(e, i, t)
                        }
                        let r = e._propertyBindings;
                        for (let a = 0, s = r.length; a !== s; ++a) {
                            let o = r[a];
                            0 == o.useCount++ && (this._lendBinding(o), o.saveOriginalState())
                        }
                        this._lendAction(e)
                    }
                }
                _deactivateAction(e) {
                    if (this._isActiveAction(e)) {
                        let t = e._propertyBindings;
                        for (let i = 0, n = t.length; i !== n; ++i) {
                            let r = t[i];
                            0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                        }
                        this._takeBackAction(e)
                    }
                }
                _initMemoryManager() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    let e = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return e._actions.length
                            },
                            get inUse() {
                                return e._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return e._bindings.length
                            },
                            get inUse() {
                                return e._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return e._controlInterpolants.length
                            },
                            get inUse() {
                                return e._nActiveControlInterpolants
                            }
                        }
                    }
                }
                _isActiveAction(e) {
                    let t = e._cacheIndex;
                    return null !== t && t < this._nActiveActions
                }
                _addInactiveAction(e, t, i) {
                    let n = this._actions,
                        r = this._actionsByClip,
                        a = r[t];
                    if (void 0 === a) a = {
                        knownActions: [e],
                        actionByRoot: {}
                    }, e._byClipCacheIndex = 0, r[t] = a;
                    else {
                        let s = a.knownActions;
                        e._byClipCacheIndex = s.length, s.push(e)
                    }
                    e._cacheIndex = n.length, n.push(e), a.actionByRoot[i] = e
                }
                _removeInactiveAction(e) {
                    let t = this._actions,
                        i = t[t.length - 1],
                        n = e._cacheIndex;
                    i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null;
                    let r = e._clip.uuid,
                        a = this._actionsByClip,
                        s = a[r],
                        o = s.knownActions,
                        l = o[o.length - 1],
                        h = e._byClipCacheIndex;
                    l._byClipCacheIndex = h, o[h] = l, o.pop(), e._byClipCacheIndex = null;
                    let u = s.actionByRoot,
                        c = (e._localRoot || this._root).uuid;
                    delete u[c], 0 === o.length && delete a[r], this._removeInactiveBindingsForAction(e)
                }
                _removeInactiveBindingsForAction(e) {
                    let t = e._propertyBindings;
                    for (let i = 0, n = t.length; i !== n; ++i) {
                        let r = t[i];
                        0 == --r.referenceCount && this._removeInactiveBinding(r)
                    }
                }
                _lendAction(e) {
                    let t = this._actions,
                        i = e._cacheIndex,
                        n = this._nActiveActions++,
                        r = t[n];
                    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
                }
                _takeBackAction(e) {
                    let t = this._actions,
                        i = e._cacheIndex,
                        n = --this._nActiveActions,
                        r = t[n];
                    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
                }
                _addInactiveBinding(e, t, i) {
                    let n = this._bindingsByRootAndName,
                        r = this._bindings,
                        a = n[t];
                    void 0 === a && (a = {}, n[t] = a), a[i] = e, e._cacheIndex = r.length, r.push(e)
                }
                _removeInactiveBinding(e) {
                    let t = this._bindings,
                        i = e.binding,
                        n = i.rootNode.uuid,
                        r = i.path,
                        a = this._bindingsByRootAndName,
                        s = a[n],
                        o = t[t.length - 1],
                        l = e._cacheIndex;
                    o._cacheIndex = l, t[l] = o, t.pop(), delete s[r], 0 === Object.keys(s).length && delete a[n]
                }
                _lendBinding(e) {
                    let t = this._bindings,
                        i = e._cacheIndex,
                        n = this._nActiveBindings++,
                        r = t[n];
                    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
                }
                _takeBackBinding(e) {
                    let t = this._bindings,
                        i = e._cacheIndex,
                        n = --this._nActiveBindings,
                        r = t[n];
                    e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
                }
                _lendControlInterpolant() {
                    let e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++,
                        i = e[t];
                    return void 0 === i && ((i = new so(new Float32Array(2), new Float32Array(2), 1, s6)).__cacheIndex = t, e[t] = i), i
                }
                _takeBackControlInterpolant(e) {
                    let t = this._controlInterpolants,
                        i = e.__cacheIndex,
                        n = --this._nActiveControlInterpolants,
                        r = t[n];
                    e.__cacheIndex = n, t[n] = e, r.__cacheIndex = i, t[i] = r
                }
                clipAction(e, t, i) {
                    let n = t || this._root,
                        r = n.uuid,
                        a = "string" == typeof e ? sv.findByName(n, e) : e,
                        s = null !== a ? a.uuid : e,
                        o = this._actionsByClip[s],
                        l = null;
                    if (void 0 === i && (i = null !== a ? a.blendMode : 2500), void 0 !== o) {
                        let h = o.actionByRoot[r];
                        if (void 0 !== h && h.blendMode === i) return h;
                        l = o.knownActions[0], null === a && (a = l._clip)
                    }
                    if (null === a) return null;
                    let u = new s5(this, a, t, i);
                    return this._bindAction(u, l), this._addInactiveAction(u, s, r), u
                }
                existingAction(e, t) {
                    let i = t || this._root,
                        n = i.uuid,
                        r = "string" == typeof e ? sv.findByName(i, e) : e,
                        a = r ? r.uuid : e,
                        s = this._actionsByClip[a];
                    return void 0 !== s && s.actionByRoot[n] || null
                }
                stopAllAction() {
                    let e = this._actions,
                        t = this._nActiveActions;
                    for (let i = t - 1; i >= 0; --i) e[i].stop();
                    return this
                }
                update(e) {
                    e *= this.timeScale;
                    let t = this._actions,
                        i = this._nActiveActions,
                        n = this.time += e,
                        r = Math.sign(e),
                        a = this._accuIndex ^= 1;
                    for (let s = 0; s !== i; ++s) {
                        let o = t[s];
                        o._update(n, e, r, a)
                    }
                    let l = this._bindings,
                        h = this._nActiveBindings;
                    for (let u = 0; u !== h; ++u) l[u].apply(a);
                    return this
                }
                setTime(e) {
                    this.time = 0;
                    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                    return this.update(e)
                }
                getRoot() {
                    return this._root
                }
                uncacheClip(e) {
                    let t = this._actions,
                        i = e.uuid,
                        n = this._actionsByClip,
                        r = n[i];
                    if (void 0 !== r) {
                        let a = r.knownActions;
                        for (let s = 0, o = a.length; s !== o; ++s) {
                            let l = a[s];
                            this._deactivateAction(l);
                            let h = l._cacheIndex,
                                u = t[t.length - 1];
                            l._cacheIndex = null, l._byClipCacheIndex = null, u._cacheIndex = h, t[h] = u, t.pop(), this._removeInactiveBindingsForAction(l)
                        }
                        delete n[i]
                    }
                }
                uncacheRoot(e) {
                    let t = e.uuid,
                        i = this._actionsByClip;
                    for (let n in i) {
                        let r = i[n].actionByRoot,
                            a = r[t];
                        void 0 !== a && (this._deactivateAction(a), this._removeInactiveAction(a))
                    }
                    let s = this._bindingsByRootAndName,
                        o = s[t];
                    if (void 0 !== o)
                        for (let l in o) {
                            let h = o[l];
                            h.restoreOriginalState(), this._removeInactiveBinding(h)
                        }
                }
                uncacheAction(e, t) {
                    let i = this.existingAction(e, t);
                    null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                }
            }
            class s8 {
                constructor(e, t, i = 0, n = 1 / 0) {
                    this.ray = new e2(e, t), this.near = i, this.far = n, this.camera = null, this.layers = new ta, this.params = {
                        Mesh: {},
                        Line: {
                            threshold: 1
                        },
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    }
                }
                set(e, t) {
                    this.ray.set(e, t)
                }
                setFromCamera(e, t) {
                    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
                }
                intersectObject(e, t = !0, i = []) {
                    return oe(e, this, i, t), i.sort(s9), i
                }
                intersectObjects(e, t = !0, i = []) {
                    for (let n = 0, r = e.length; n < r; n++) oe(e[n], this, i, t);
                    return i.sort(s9), i
                }
            }

            function s9(e, t) {
                return e.distance - t.distance
            }

            function oe(e, t, i, n) {
                if (e.layers.test(t.layers) && e.raycast(t, i), !0 === n) {
                    let r = e.children;
                    for (let a = 0, s = r.length; a < s; a++) oe(r[a], t, i, !0)
                }
            }
            class ot {
                constructor(e = 1, t = 0, i = 0) {
                    return this.radius = e, this.phi = t, this.theta = i, this
                }
                set(e, t, i) {
                    return this.radius = e, this.phi = t, this.theta = i, this
                }
                copy(e) {
                    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                }
                makeSafe() {
                    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                }
                setFromVector3(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
                setFromCartesianCoords(e, t, i) {
                    return this.radius = Math.sqrt(e * e + t * t + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(J(t / this.radius, -1, 1))), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            class oi extends r5 {
                constructor(e = 1) {
                    let t = new tX;
                    t.setAttribute("position", new tF([0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], 3)), t.setAttribute("color", new tF([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                    let i = new rZ({
                        vertexColors: !0,
                        toneMapped: !1
                    });
                    super(t, i), this.type = "AxesHelper"
                }
                setColors(e, t, i) {
                    let n = new e_,
                        r = this.geometry.attributes.color.array;
                    return n.set(e), n.toArray(r, 0), n.toArray(r, 3), n.set(t), n.toArray(r, 6), n.toArray(r, 9), n.set(i), n.toArray(r, 12), n.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: "148"
                }
            })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "148")
        }
    }
]);